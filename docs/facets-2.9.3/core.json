{"(metadata)":{"source":["var"],"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"}],"copyrights":[{"holder":"Thomas Sawyer","year":"2004","license":"Ruby"}],"replacements":[],"alternatives":[],"requirements":[{"name":"lemon","groups":["test"],"development":null},{"name":"qed","groups":["test"],"development":null},{"name":"detroit","groups":["build"],"development":null}],"dependencies":[],"conflicts":[],"repositories":[{"uri":"git@github.com:rubyworks/facets.git","scm":"git","name":"upstream"}],"resources":{"home":"http://rubyworks.github.com/facets","code":"http://github.com/rubyworks/facets","docs":"http://rubyworks.github.com/facets/learn.html","wiki":"http://wiki.github.com/rubyworks/facets","talk":"http://groups.google.com/group/facets-universal"},"extra":{},"load_path":["lib/core","lib/standard"],"revision":null,"created":"2004-12-16","summary":"Premium Ruby Extensions","title":"Facets","version":"2.9.3","scm_uri":"https://github.com/rubyworks/facets/tree/master","name":"facets","description":"Facets is the premier collection of extension methods for the Ruby programming language. Facets extensions are unique by virtue of thier atomicity. They are stored in individual files allowing for highly granular control of requirements. In addition, Facets includes a few additional classes and mixins suitable to wide variety of applications.","organization":"rubyworks","date":"2012-01-02","path":"(metadata)","markup":"rdoc"},"NA = ArgumentError.new":{"!":"class","superclass":"Object","path":"NA = ArgumentError.new","name":"NA = ArgumentError.new","namespace":"","comment":"N/A exception is useful for specifying non-argument defaults when +nil+\nis a valid value.\n\n  def f(x=NA)\n  end\n\nNA is also used to represent an argument \"slot\" for Proc#partial.\n\nNA is an instance of ArgumentError.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/core/facets/na.rb"],"tags":{}},"NA = ArgumentError.new.inspect":{"!":"method","declarations":["class","public"],"path":"NA = ArgumentError.new.inspect","name":"inspect","namespace":"NA = ArgumentError.new","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/core/facets/na.rb","line":null,"source":"def inspect ; 'N/A' ; end","language":"ruby","dynamic":null,"tags":{}},"Lazy":{"!":"module","path":"Lazy","name":"Lazy","namespace":"","comment":"Everything you need for Lazy evaluation in Ruby.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["Lazy::DivergenceError","Lazy::LazyException","Lazy::Promise","Lazy::PromiseSafe","Lazy::Future"],"methods":[],"accessors":[],"files":["/lib/core/facets/lazy.rb"],"tags":{"author":"MenTaLguY"}},"Lazy::DivergenceError":{"!":"class","superclass":"Exception","path":"Lazy::DivergenceError","name":"DivergenceError","namespace":"Lazy","comment":"Raised when a demanded computation diverges (e.g. if it tries to directly\nuse its own result)","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Lazy::DivergenceError#initialize"],"accessors":[],"files":["/lib/core/facets/lazy.rb"],"tags":{}},"Lazy::DivergenceError#initialize":{"!":"method","declarations":["instance","public"],"path":"Lazy::DivergenceError#initialize","name":"initialize","namespace":"Lazy::DivergenceError","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(message=\"Computation diverges\")","arguments":[{"name":"message","default":"\"Computation diverges\""}]}],"returns":[{"type":"DivergenceError","comment":"a new instance of DivergenceError"}],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def initialize( message=\"Computation diverges\" )\n  super( message )\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::LazyException":{"!":"class","superclass":"Lazy::DivergenceError","path":"Lazy::LazyException","name":"LazyException","namespace":"Lazy","comment":"Wraps an exception raised by a lazy computation.\n\nThe reason we wrap such exceptions in LazyException is that they need to\nbe distinguishable from similar exceptions which might normally be raised\nby whatever strict code we happen to be in at the time.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Lazy::LazyException#reason","Lazy::LazyException#initialize"],"accessors":["Lazy::LazyException#reason"],"files":["/lib/core/facets/lazy.rb"],"tags":{}},"Lazy::LazyException#reason":{"!":"method","declarations":["instance","public"],"path":"Lazy::LazyException#reason","name":"reason","namespace":"Lazy::LazyException","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reason","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def reason\n  @reason\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::LazyException#initialize":{"!":"method","declarations":["instance","public"],"path":"Lazy::LazyException#initialize","name":"initialize","namespace":"Lazy::LazyException","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(reason)","arguments":[{"name":"reason"}]}],"returns":[{"type":"LazyException","comment":"a new instance of LazyException"}],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def initialize( reason )\n  @reason = reason\n  super( \"Exception in lazy computation: #{ reason } (#{ reason.class })\" )\n  set_backtrace( reason.backtrace.dup ) if reason\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise":{"!":"class","superclass":"Object","path":"Lazy::Promise","name":"Promise","namespace":"Lazy","comment":":nodoc:","format":"rdoc","constants":["Lazy::Promise::DIVERGES"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Lazy::Promise#__class__","Lazy::Promise#initialize","Lazy::Promise#__synchronize__","Lazy::Promise#__result__","Lazy::Promise#inspect","Lazy::Promise#respond_to?","Lazy::Promise#method_missing"],"accessors":[],"files":["/lib/core/facets/lazy.rb"],"tags":{}},"Lazy::Promise::DIVERGES":{"!":"constant","path":"Lazy::Promise::DIVERGES","name":"DIVERGES","namespace":"Lazy::Promise","comment":"Create this once here, rather than creating a proc object for every evaluation.","format":"rdoc","value":"lambda { raise DivergenceError.new }","tags":{},"files":["/lib/core/facets/lazy.rb"]},"Lazy::Promise#__class__":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#__class__","name":"__class__","namespace":"Lazy::Promise","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__class__","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"alias __class__ class","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise#initialize":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#initialize","name":"initialize","namespace":"Lazy::Promise","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(&computation)","arguments":[],"block":{"name":"&computation"}}],"returns":[{"type":"Promise","comment":"a new instance of Promise"}],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def initialize( &computation ) #:nodoc:\n  @computation = computation\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise#__synchronize__":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#__synchronize__","name":"__synchronize__","namespace":"Lazy::Promise","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__synchronize__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def __synchronize__ #:nodoc:\n  yield\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise.lambda { raise DivergenceErrorlambda { raise DivergenceError.new }.inspect":{"!":"method","declarations":["class","public"],"path":"Lazy::Promise.lambda { raise DivergenceErrorlambda { raise DivergenceError.new }.inspect","name":"inspect","namespace":"Lazy::Promise.lambda { raise DivergenceErrorlambda { raise DivergenceError.new }","comment":"Differentiate inspection of DIVERGES lambda.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect(.)","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def DIVERGES.inspect\n  \"DIVERGES\"\nend","language":"ruby","dynamic":null,"tags":{}},"Integer":{"!":"class","superclass":"Object","path":"Integer","name":"Integer","namespace":"","comment":"","format":"rdoc","constants":["Integer::ROMAN_MAX","Integer::ROMAN_VALUES"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Integer#roman","Integer#of","Integer#times_collect","Integer#times_map","Integer#odd?","Integer#even?","Integer#bit","Integer#bit_clear","Integer#bit?","Integer#bitmask","Integer#bitmask?","Integer#ordinal","Integer#ordinalize","Integer#multiple?","Integer#factorial","Integer#fac"],"accessors":[],"files":["/lib/core/facets/roman.rb","/lib/core/facets/integer/of.rb","/lib/core/facets/integer/odd.rb","/lib/core/facets/integer/bitmask.rb","/lib/core/facets/integer/ordinal.rb","/lib/core/facets/integer/multiple.rb","/lib/core/facets/integer/factorial.rb"],"tags":{}},"Integer::ROMAN_MAX":{"!":"constant","path":"Integer::ROMAN_MAX","name":"ROMAN_MAX","namespace":"Integer","comment":"","format":"rdoc","value":"3999","tags":{},"files":["/lib/core/facets/roman.rb"]},"Integer::ROMAN_VALUES":{"!":"constant","path":"Integer::ROMAN_VALUES","name":"ROMAN_VALUES","namespace":"Integer","comment":"","format":"rdoc","value":"[\n  [\"M\", 1000],\n  [\"CM\", 900],\n  [\"D\",  500],\n  [\"CD\", 400],\n  [\"C\",  100],\n  [\"XC\",  90],\n  [\"L\",   50],\n  [\"XL\",  40],\n  [\"X\",   10],\n  [\"IX\",   9],\n  [\"V\",    5],\n  [\"IV\",   4],\n  [\"I\",    1]\n]","tags":{},"files":["/lib/core/facets/roman.rb"]},"Integer#roman":{"!":"method","declarations":["instance","public"],"path":"Integer#roman","name":"roman","namespace":"Integer","comment":"Converts this integer to a roman numeral.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"roman()","arguments":[]}],"returns":[],"file":"/lib/core/facets/roman.rb","line":null,"source":"def roman\n  int = self\n  #return nil if integer > ROMAN_MAX\n  return \"-#{(-int).roman}\" if int < 0\n  return \"\" if int == 0\n  ROMAN_VALUES.each do |(i, v)|\n    return(i + (int-v).roman) if v <= int \n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/integer/roman'"}},"String":{"!":"class","superclass":"Object","path":"String","name":"String","namespace":"","comment":"--\n= Developer's Notes\n\nOld definition of start_with? written by Lucas Carlson\nand Blaine Cook was ...\n\n  index(prefix) == 0\n\nI like the simplicity of this definition, but I could not\nfind a way define #end_with? in similar terms and still\naccept regular expressions for the suffix. So I had to use\nRegexp match. On th upside, we can get MatchData\nwhich might be more useful.\n++","format":"rdoc","constants":["String::ROMAN","String::ROMAN_VALUES","String::BRA2KET"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["String#roman","String#roman?","String#to_b","String#tab","String#^","String#file","String#file_send","String#fold","String#to_re","String#to_rx","String#blank?","String#store","String#lines","String#align","String#align_right","String#align_left","String#align_center","String#range","String#range_all","String#range_of_line","String#mscan","String#bytes","String#quote","String#unquote","String#tabto","String#words","String#nchar","String#_crypt","String#crypt","String#splice","String#cleave","String#indent","String#indent!","String#unindent","String#unindent!","String#unfold","String#natcmp","String#margin","String#divide","String#-","String#lchomp","String#lchomp!","String#squish","String#squish!","String#/","String#pathize","String#shatter","String#exclude?","String#rewrite","String#cmp","String#bracket","String#bracket!","String#unbracket","String#unbracket!","String#acronym","String#modulize","String#newlines","String#each_char","String#snakecase","String#underscore","String#methodize","String#titlecase","String#briefcase","String#word_wrap","String#word_wrap!","String#camelcase","String#upper_camelcase","String#lower_camelcase","String#line_wrap","String#uppercase","String#lowercase","String#each_word","String#index_all","String#start_with?","String#end_with?","String#starts_with?","String#ends_with?","String#characters","String#expand_tabs","String#expand_tab","String#variablize","String#similarity","String#cleanlines","String.interpolate","String#capitalized?","String#downcase?","String#upcase?","String#object_state","String#edit_distance","String.random_binary","String#compress_lines"],"accessors":[],"files":["/lib/core/facets/string/start_with.rb","/lib/core/facets/roman.rb","/lib/core/facets/boolean.rb","/lib/core/facets/string/tab.rb","/lib/core/facets/string/xor.rb","/lib/core/facets/string/file.rb","/lib/core/facets/string/fold.rb","/lib/core/facets/string/to_re.rb","/lib/core/facets/kernel/blank.rb","/lib/core/facets/string/store.rb","/lib/core/facets/string/lines.rb","/lib/core/facets/string/align.rb","/lib/core/facets/string/range.rb","/lib/core/facets/string/mscan.rb","/lib/core/facets/string/bytes.rb","/lib/core/facets/string/quote.rb","/lib/core/facets/string/tabto.rb","/lib/core/facets/string/words.rb","/lib/core/facets/string/nchar.rb","/lib/core/facets/string/crypt.rb","/lib/core/facets/string/splice.rb","/lib/core/facets/string/cleave.rb","/lib/core/facets/string/indent.rb","/lib/core/facets/string/unfold.rb","/lib/core/facets/string/natcmp.rb","/lib/core/facets/string/margin.rb","/lib/core/facets/string/divide.rb","/lib/core/facets/string/op_sub.rb","/lib/core/facets/string/lchomp.rb","/lib/core/facets/string/squish.rb","/lib/core/facets/string/op_div.rb","/lib/core/facets/string/pathize.rb","/lib/core/facets/string/shatter.rb","/lib/core/facets/string/exclude.rb","/lib/core/facets/string/rewrite.rb","/lib/core/facets/comparable/cmp.rb","/lib/core/facets/string/bracket.rb","/lib/core/facets/string/acronym.rb","/lib/core/facets/string/modulize.rb","/lib/core/facets/string/newlines.rb","/lib/core/facets/string/each_char.rb","/lib/core/facets/string/snakecase.rb","/lib/core/facets/string/methodize.rb","/lib/core/facets/string/titlecase.rb","/lib/core/facets/string/word_wrap.rb","/lib/core/facets/string/camelcase.rb","/lib/core/facets/string/line_wrap.rb","/lib/core/facets/string/uppercase.rb","/lib/core/facets/string/each_word.rb","/lib/core/facets/string/index_all.rb","/lib/core/facets/string/characters.rb","/lib/core/facets/string/expand_tab.rb","/lib/core/facets/string/variablize.rb","/lib/core/facets/string/similarity.rb","/lib/core/facets/string/cleanlines.rb","/lib/core/facets/string/interpolate.rb","/lib/core/facets/string/capitalized.rb","/lib/core/facets/object/object_state.rb","/lib/core/facets/string/edit_distance.rb","/lib/core/facets/string/random_binary.rb","/lib/core/facets/string/compress_lines.rb"],"tags":{}},"String::ROMAN":{"!":"constant","path":"String::ROMAN","name":"ROMAN","namespace":"String","comment":"","format":"rdoc","value":"/^M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$/i","tags":{},"files":["/lib/core/facets/roman.rb"]},"String::ROMAN_VALUES":{"!":"constant","path":"String::ROMAN_VALUES","name":"ROMAN_VALUES","namespace":"String","comment":"","format":"rdoc","value":"Integer::ROMAN_VALUES.inject({}) do |h,(r,a)|\n  h[r] = a; h\nend","tags":{},"files":["/lib/core/facets/roman.rb"]},"String::BRA2KET":{"!":"constant","path":"String::BRA2KET","name":"BRA2KET","namespace":"String","comment":"","format":"rdoc","value":"{ '['=>']', '('=>')', '{'=>'}', '<'=>'>' }","tags":{},"files":["/lib/core/facets/string/bracket.rb"]},"String#roman":{"!":"method","declarations":["instance","public"],"path":"String#roman","name":"roman","namespace":"String","comment":"Considers string a Roman numeral numeral,\nand converts it to the corresponding integer.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"roman()","arguments":[]}],"returns":[],"file":"/lib/core/facets/roman.rb","line":null,"source":"def roman\n  roman = upcase\n  raise unless roman?\n  last = roman[-1,1]\n  roman.reverse.split('').inject(0) do |result, c|\n    if ROMAN_VALUES[c] < ROMAN_VALUES[last]\n      result -= ROMAN_VALUES[c]\n    else\n      last = c\n      result += ROMAN_VALUES[c]\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/string/roman'"}},"String#roman?":{"!":"method","declarations":["instance","public"],"path":"String#roman?","name":"roman?","namespace":"String","comment":"Returns true iif the subject is a valid Roman numeral.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"roman?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/roman.rb","line":null,"source":"def roman?\n  ROMAN =~ upcase\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/string/roman'"}},"Fixnum":{"!":"class","superclass":"Object","path":"Fixnum","name":"Fixnum","namespace":"","comment":"","format":"rdoc","constants":["Fixnum::MAX","Fixnum::MIN"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/core/facets/fixnum.rb"],"tags":{}},"Fixnum::MAX":{"!":"constant","path":"Fixnum::MAX","name":"MAX","namespace":"Fixnum","comment":"","format":"rdoc","value":"2 ** (n_bits - 2) - 1","tags":{},"files":["/lib/core/facets/fixnum.rb"]},"Fixnum::MIN":{"!":"constant","path":"Fixnum::MIN","name":"MIN","namespace":"Fixnum","comment":"","format":"rdoc","value":"- 1","tags":{},"files":["/lib/core/facets/fixnum.rb"]},"Hash":{"!":"class","superclass":"Object","path":"Hash","name":"Hash","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["Hash::Recursor"],"methods":["Hash#at","Hash#to_b","Hash#to_h","Hash#to_hash","Hash.zip","Hash#has_keys?","Hash#keys?","Hash#has_only_keys?","Hash#only_keys?","Hash#each_with_key","Hash#join","Hash#swap!","Hash#data","Hash#diff","Hash#weave","Hash#|","Hash#graph!","Hash#mash!","Hash#alias!","Hash#slice","Hash#slice!","Hash#rekey","Hash#rekey!","Hash#count","Hash#+","Hash#subset","Hash#&","Hash#except","Hash#except!","Hash#to_mod","Hash#*","Hash#insert","Hash#select!","Hash#-","Hash#collate","Hash#collate!","Hash#to_proc","Hash#inverse","Hash#<<","Hash#recurse","Hash#recurse!","Hash.autonew","Hash#blank?","Hash.new_with","Hash#traverse","Hash#traverse!","Hash#delete_at","Hash#to_struct","Hash#url_params","Hash#deep_merge","Hash#deep_merge!","Hash#recursively","Hash#update_each","Hash#update_keys","Hash#argumentize","Hash#replace_each","Hash#delete_values","Hash#delete_values_at","Hash#reverse_merge","Hash#reverse_merge!","Hash#reverse_update","Hash#delete_unless","Hash#update_values","Hash#object_state","Hash#dearray_values","Hash#dearray_singular_values","Hash#symbolize_keys","Hash#symbolize_keys!","Hash#stringify_keys","Hash#stringify_keys!","Hash#extractable_options?"],"accessors":[],"files":["/lib/core/facets/hash/at.rb","/lib/core/facets/boolean.rb","/lib/core/facets/to_hash.rb","/lib/core/facets/hash/zip.rb","/lib/core/facets/hash/keys.rb","/lib/core/facets/hash/join.rb","/lib/core/facets/hash/swap.rb","/lib/core/facets/hash/data.rb","/lib/core/facets/hash/diff.rb","/lib/core/facets/hash/weave.rb","/lib/core/facets/hash/op_or.rb","/lib/core/facets/hash/graph.rb","/lib/core/facets/hash/alias.rb","/lib/core/facets/hash/slice.rb","/lib/core/facets/hash/rekey.rb","/lib/core/facets/hash/count.rb","/lib/core/facets/hash/op_add.rb","/lib/core/facets/hash/subset.rb","/lib/core/facets/hash/op_and.rb","/lib/core/facets/hash/except.rb","/lib/core/facets/hash/to_mod.rb","/lib/core/facets/hash/op_mul.rb","/lib/core/facets/hash/insert.rb","/lib/core/facets/hash/select.rb","/lib/core/facets/hash/op_sub.rb","/lib/core/facets/hash/collate.rb","/lib/core/facets/hash/to_proc.rb","/lib/core/facets/hash/inverse.rb","/lib/core/facets/hash/op_push.rb","/lib/core/facets/hash/recurse.rb","/lib/core/facets/hash/autonew.rb","/lib/core/facets/kernel/blank.rb","/lib/core/facets/hash/new_with.rb","/lib/core/facets/hash/traverse.rb","/lib/core/facets/hash/delete_at.rb","/lib/core/facets/hash/to_struct.rb","/lib/core/facets/hash/url_params.rb","/lib/core/facets/hash/deep_merge.rb","/lib/core/facets/hash/recursively.rb","/lib/core/facets/hash/update_each.rb","/lib/core/facets/hash/update_keys.rb","/lib/core/facets/hash/argumentize.rb","/lib/core/facets/hash/replace_each.rb","/lib/core/facets/hash/delete_values.rb","/lib/core/facets/hash/reverse_merge.rb","/lib/core/facets/hash/delete_unless.rb","/lib/core/facets/hash/update_values.rb","/lib/core/facets/object/object_state.rb","/lib/core/facets/hash/dearray_values.rb","/lib/core/facets/hash/symbolize_keys.rb","/lib/core/facets/array/extract_options.rb"],"tags":{}},"Hash#at":{"!":"method","declarations":["instance","public"],"path":"Hash#at","name":"at","namespace":"Hash","comment":"Alias for fetch for greater polymorphism with Array.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/at.rb","line":null,"source":"alias_method :at, :[]","language":"ruby","dynamic":null,"tags":{}},"Kernel":{"!":"module","path":"Kernel","name":"Kernel","namespace":"","comment":"","format":"rdoc","constants":["Kernel::INSTANCES","Kernel::ARCH_SIZE","Kernel::HEXID_TEMPLATE"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Kernel#to_b","Kernel#to_bool","Kernel#bool?","Kernel#p","Kernel#Y","Kernel#d","Kernel#instance","Kernel#in?","Kernel#as","Kernel#send_as","Kernel#try","Kernel#tap","Kernel#not?","Kernel#not","Kernel#not_send","Kernel#ask","Kernel#val?","Kernel#yes?","Kernel#no?","Kernel#memo","Kernel#here","Kernel#ergo","Kernel#with","Kernel#true?","Kernel#false?","Kernel#demo","Kernel#case?","Kernel#blank?","Kernel#present?","Kernel#presence","Kernel#maybe","Kernel#eigen","Kernel#equate?","Kernel#assign","Kernel#assign_from","Kernel#_extend","Kernel#extend","Kernel#method!","Kernel#__DIR__","Kernel#__get__","Kernel#__set__","Kernel#not_nil?","Kernel#writers","Kernel#silence","Kernel#silently","Kernel#silence_stream","Kernel#silence_stderr","Kernel#silence_stdout","Kernel#respond","Kernel#constant","Kernel#meta_def","Kernel#Bit","Kernel#complete","Kernel#returning","Kernel#qua_class","Kernel#quaclass","Kernel#extension","Kernel#__class__","Kernel#deep_copy","Kernel#deep_clone","Kernel#meta_eval","Kernel#identical?","Kernel#meta_alias","Kernel#__method__","Kernel#__callee__","Kernel#trap_chain","Kernel#meta_class","Kernel#metaclass","Kernel#eigenclass","Kernel#pp_callstack","Kernel#pp_call_stack","Kernel#call_stack","Kernel#callstack","Kernel#require_all","Kernel#load_all","Kernel#temporarily","Kernel#object_send","Kernel#super_method","Kernel#object_class","Kernel#object_hexid","Kernel#instance_send","Kernel#hierarchically","Kernel#instance_class","Kernel#attr_singleton_reader","Kernel#attr_singleton_writer","Kernel#attr_singleton_accessor","Kernel#instance_assign","Kernel#singleton_class","Kernel#source_location","Kernel#require_relative","Kernel#load_relative","Kernel#disable_warnings","Kernel#silence_warnings","Kernel#enable_warnings","Kernel#hierarchical_send","Kernel#promise","Kernel#demand","Kernel#future"],"accessors":[],"files":["/lib/core/facets/boolean.rb","/lib/core/facets/kernel/p.rb","/lib/core/facets/kernel/y.rb","/lib/core/facets/kernel/d.rb","/lib/core/facets/instance.rb","/lib/core/facets/kernel/in.rb","/lib/core/facets/kernel/as.rb","/lib/core/facets/kernel/try.rb","/lib/core/facets/kernel/tap.rb","/lib/core/facets/kernel/not.rb","/lib/core/facets/kernel/ask.rb","/lib/core/facets/kernel/val.rb","/lib/core/facets/kernel/yes.rb","/lib/core/facets/kernel/memo.rb","/lib/core/facets/kernel/here.rb","/lib/core/facets/kernel/ergo.rb","/lib/core/facets/kernel/with.rb","/lib/core/facets/kernel/true.rb","/lib/core/facets/kernel/demo.rb","/lib/core/facets/kernel/case.rb","/lib/core/facets/kernel/blank.rb","/lib/core/facets/kernel/maybe.rb","/lib/core/facets/kernel/eigen.rb","/lib/core/facets/kernel/equate.rb","/lib/core/facets/kernel/assign.rb","/lib/core/facets/kernel/extend.rb","/lib/core/facets/kernel/method.rb","/lib/core/facets/kernel/__dir__.rb","/lib/core/facets/kernel/__get__.rb","/lib/core/facets/kernel/not_nil.rb","/lib/core/facets/kernel/writers.rb","/lib/core/facets/kernel/silence.rb","/lib/core/facets/kernel/respond.rb","/lib/core/facets/kernel/constant.rb","/lib/core/facets/kernel/meta_def.rb","/lib/core/facets/integer/bitmask.rb","/lib/core/facets/kernel/complete.rb","/lib/core/facets/kernel/returning.rb","/lib/core/facets/kernel/qua_class.rb","/lib/core/facets/kernel/extension.rb","/lib/core/facets/kernel/__class__.rb","/lib/core/facets/kernel/deep_copy.rb","/lib/core/facets/kernel/meta_eval.rb","/lib/core/facets/kernel/identical.rb","/lib/core/facets/kernel/meta_alias.rb","/lib/core/facets/kernel/__method__.rb","/lib/core/facets/kernel/trap_chain.rb","/lib/core/facets/kernel/meta_class.rb","/lib/core/facets/kernel/eigenclass.rb","/lib/core/facets/kernel/call_stack.rb","/lib/core/facets/kernel/require_all.rb","/lib/core/facets/kernel/temporarily.rb","/lib/core/facets/kernel/object_send.rb","/lib/core/facets/kernel/super_method.rb","/lib/core/facets/kernel/object_class.rb","/lib/core/facets/kernel/object_hexid.rb","/lib/core/facets/kernel/instance_send.rb","/lib/core/facets/class/hierarchically.rb","/lib/core/facets/kernel/instance_class.rb","/lib/core/facets/kernel/attr_singleton.rb","/lib/core/facets/kernel/instance_assign.rb","/lib/core/facets/kernel/singleton_class.rb","/lib/core/facets/kernel/source_location.rb","/lib/core/facets/kernel/require_relative.rb","/lib/core/facets/kernel/disable_warnings.rb","/lib/core/facets/kernel/hierarchical_send.rb","/lib/core/facets/lazy.rb"],"tags":{}},"Kernel::INSTANCES":{"!":"constant","path":"Kernel::INSTANCES","name":"INSTANCES","namespace":"Kernel","comment":"","format":"rdoc","value":"{}","tags":{},"files":["/lib/core/facets/instance.rb"]},"Kernel::ARCH_SIZE":{"!":"constant","path":"Kernel::ARCH_SIZE","name":"ARCH_SIZE","namespace":"Kernel","comment":"","format":"rdoc","value":"(['a'].pack('P').length > 4 ? 64 : 32)","tags":{},"files":["/lib/core/facets/kernel/object_hexid.rb"]},"Kernel::HEXID_TEMPLATE":{"!":"constant","path":"Kernel::HEXID_TEMPLATE","name":"HEXID_TEMPLATE","namespace":"Kernel","comment":"","format":"rdoc","value":"\"0x%x\"","tags":{},"files":["/lib/core/facets/kernel/object_hexid.rb","/lib/core/facets/kernel/object_hexid.rb","/lib/core/facets/kernel/object_hexid.rb","/lib/core/facets/kernel/object_hexid.rb"]},"Kernel#to_b":{"!":"method","declarations":["instance","public"],"path":"Kernel#to_b","name":"to_b","namespace":"Kernel","comment":"Boolean conversion for not being nil or false.\nOther classes may redefine this to suite the\nparticular need.\n\n  \"yes\".to_b   #=> true\n  \"abc\".to_b   #=> false\n\n  true.to_b    #=> true\n  false.to_b   #=> false\n  nil.to_b     #=> false\n\nCREDIT: Ara T. Howard, Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_b()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_b\n  self ? true : false\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#to_bool":{"!":"method","declarations":["instance","public"],"path":"Kernel#to_bool","name":"to_bool","namespace":"Kernel","comment":"All objects except false and nil are \"true\".","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_bool()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_bool\n  true\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#bool?":{"!":"method","declarations":["instance","public"],"path":"Kernel#bool?","name":"bool?","namespace":"Kernel","comment":"Returns true is an object is class TrueClass\nor FalseClass, otherwise false.\n\n  true.bool?   #=> true\n  false.bool?  #=> true\n  nil.bool?    #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bool?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def bool?\n  (true == self or false == self)\nend","language":"ruby","dynamic":null,"tags":{}},"TrueClass":{"!":"class","superclass":"Object","path":"TrueClass","name":"TrueClass","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["TrueClass#to_bool","TrueClass#dup!","TrueClass#dup?","TrueClass#clone?","TrueClass#blank?"],"accessors":[],"files":["/lib/core/facets/boolean.rb","/lib/core/facets/object/dup.rb","/lib/core/facets/kernel/blank.rb"],"tags":{}},"TrueClass#to_bool":{"!":"method","declarations":["instance","public"],"path":"TrueClass#to_bool","name":"to_bool","namespace":"TrueClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_bool()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_bool\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"FalseClass":{"!":"class","superclass":"Object","path":"FalseClass","name":"FalseClass","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["FalseClass#to_bool","FalseClass#dup!","FalseClass#dup?","FalseClass#clone?","FalseClass#blank?"],"accessors":[],"files":["/lib/core/facets/boolean.rb","/lib/core/facets/object/dup.rb","/lib/core/facets/kernel/blank.rb"],"tags":{}},"FalseClass#to_bool":{"!":"method","declarations":["instance","public"],"path":"FalseClass#to_bool","name":"to_bool","namespace":"FalseClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_bool()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_bool\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass":{"!":"class","superclass":"Object","path":"NilClass","name":"NilClass","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["NilClass#to_bool","NilClass#to_h","NilClass#try","NilClass#dup!","NilClass#dup?","NilClass#clone?","NilClass#ergo","NilClass#blank?","NilClass#to_f"],"accessors":[],"files":["/lib/core/facets/boolean.rb","/lib/core/facets/to_hash.rb","/lib/core/facets/kernel/try.rb","/lib/core/facets/object/dup.rb","/lib/core/facets/kernel/ergo.rb","/lib/core/facets/kernel/blank.rb","/lib/core/facets/nilclass/to_f.rb"],"tags":{}},"NilClass#to_bool":{"!":"method","declarations":["instance","public"],"path":"NilClass#to_bool","name":"to_bool","namespace":"NilClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_bool()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_bool\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric":{"!":"class","superclass":"Object","path":"Numeric","name":"Numeric","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Numeric#to_b","Numeric#dup!","Numeric#dup?","Numeric#clone?","Numeric#blank?","Numeric#round_at","Numeric#round_to","Numeric#approx?","Numeric#close?","Numeric#length","Numeric#spacing","Numeric#positive?","Numeric#negative?","Numeric#distance"],"accessors":[],"files":["/lib/core/facets/boolean.rb","/lib/core/facets/object/dup.rb","/lib/core/facets/kernel/blank.rb","/lib/core/facets/numeric/round.rb","/lib/core/facets/numeric/approx.rb","/lib/core/facets/numeric/length.rb","/lib/core/facets/numeric/spacing.rb","/lib/core/facets/numeric/positive.rb","/lib/core/facets/numeric/distance.rb"],"tags":{}},"Numeric#to_b":{"!":"method","declarations":["instance","public"],"path":"Numeric#to_b","name":"to_b","namespace":"Numeric","comment":"Provides a boolean interpretation of self.\nIf self == 0 then false else true.\n\n  0.to_b    #=> false\n  1.to_b    #=> true\n  2.3.to_b  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_b()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_b\n  self == 0 ? false : true\nend","language":"ruby","dynamic":null,"tags":{}},"String#to_b":{"!":"method","declarations":["instance","public"],"path":"String#to_b","name":"to_b","namespace":"String","comment":"Interpret common affirmative string meanings as true,\notherwise nil or false. Blank space and case are ignored.\nThe following strings that will return true ...\n\n  true\n  yes\n  on\n  t\n  1\n  y\n  ==\n\nThe following strings will return nil ...\n\n  nil\n  null\n\nAll other strings return false.\n\nHere are some exmamples.\n\n  \"true\".to_b   #=> true\n  \"yes\".to_b    #=> true\n  \"no\".to_b     #=> false\n  \"123\".to_b    #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_b()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_b\n  case self.downcase.strip\n  when 'true', 'yes', 'on', 't', '1', 'y', '=='\n    return true\n  when 'nil', 'null'\n    return nil\n  else\n    return false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array":{"!":"class","superclass":"Object","path":"Array","name":"Array","namespace":"","comment":"","format":"rdoc","constants":[],"includes":["Indexable"],"extensions":[],"modules":[],"classes":[],"methods":["Array#to_b","Array#to_h","Array#to_h_auto","Array#to_h_splat","Array#to_h_flat","Array#to_h_assoc","Array#to_h_multi","Array#pad","Array#pad!","Array#from","Array#thru","Array#mode","Array#only","Array#pull","Array#peek","Array#poke","Array#split","Array#_facets_index","Array#index","Array#store","Array#merge!","Array#merge","Array#blank?","Array#divide","Array#**","Array#splice","Array#median","Array#select!","Array#before","Array#after","Array#rotate","Array#rotate!","Array#entropy","Array#ideal_entropy","Array#uniq_by!","Array#nonuniq","Array#nonuniq!","Array#duplicates","Array#occurent","Array#recurse","Array#recurse!","Array#conjoin","Array#product","Array#contains?","Array#collapse","Array#traverse","Array#traverse!","Array#not_empty?","Array#each_pair","Array#first!","Array#last!","Array#each_value","Array#permutation","Array#combination","Array#commonality","Array#collisions","Array#recursively","Array#probability","Array#object_state","Array#delete_values","Array#delete_values_at","Array#delete_unless","Array#extract_options!"],"accessors":[],"files":["/lib/core/facets/boolean.rb","/lib/core/facets/to_hash.rb","/lib/core/facets/array/pad.rb","/lib/core/facets/array/from.rb","/lib/core/facets/array/mode.rb","/lib/core/facets/array/only.rb","/lib/core/facets/array/pull.rb","/lib/core/facets/array/split.rb","/lib/core/facets/array/index.rb","/lib/core/facets/array/store.rb","/lib/core/facets/array/merge.rb","/lib/core/facets/kernel/blank.rb","/lib/core/facets/array/divide.rb","/lib/core/facets/array/op_pow.rb","/lib/core/facets/array/splice.rb","/lib/core/facets/array/median.rb","/lib/core/facets/array/select.rb","/lib/core/facets/array/before.rb","/lib/core/facets/array/rotate.rb","/lib/core/facets/array/entropy.rb","/lib/core/facets/array/uniq_by.rb","/lib/core/facets/array/nonuniq.rb","/lib/core/facets/array/recurse.rb","/lib/core/facets/array/conjoin.rb","/lib/core/facets/array/product.rb","/lib/core/facets/array/contains.rb","/lib/core/facets/array/collapse.rb","/lib/core/facets/array/traverse.rb","/lib/core/facets/array/not_empty.rb","/lib/core/facets/array/each_pair.rb","/lib/core/facets/array/indexable.rb","/lib/core/facets/array/each_value.rb","/lib/core/facets/enumerable/count.rb","/lib/core/facets/array/permutation.rb","/lib/core/facets/array/combination.rb","/lib/core/facets/array/commonality.rb","/lib/core/facets/array/recursively.rb","/lib/core/facets/array/probability.rb","/lib/core/facets/object/object_state.rb","/lib/core/facets/array/delete_values.rb","/lib/core/facets/array/delete_unless.rb","/lib/core/facets/array/extract_options.rb"],"tags":{}},"Array#to_b":{"!":"method","declarations":["instance","public"],"path":"Array#to_b","name":"to_b","namespace":"Array","comment":"Boolean conversion for not empty?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_b()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_b\n  ! self.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#to_b":{"!":"method","declarations":["instance","public"],"path":"Hash#to_b","name":"to_b","namespace":"Hash","comment":"Boolean conversion for not empty?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_b()","arguments":[]}],"returns":[],"file":"/lib/core/facets/boolean.rb","line":null,"source":"def to_b\n  ! self.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Facets":{"!":"module","path":"Facets","name":"Facets","namespace":"","comment":"","format":"rdoc","constants":["Facets::VERSION"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Facets.profile","Facets.const_missing"],"accessors":[],"files":["/lib/core/facets/version.rb"],"tags":{}},"Facets::VERSION":{"!":"constant","path":"Facets::VERSION","name":"VERSION","namespace":"Facets","comment":"profile['version']","format":"rdoc","value":"'2.9.3'","tags":{},"files":["/lib/core/facets/version.rb"]},"Facets.profile":{"!":"method","declarations":["class","public"],"path":"Facets.profile","name":"profile","namespace":"Facets","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"profile(.)","arguments":[]}],"returns":[],"file":"/lib/core/facets/version.rb","line":null,"source":"def self.profile\n  @profile ||= (\n    require 'yaml'\n    YAML.load(File.new(File.dirname(__FILE__) + '/facets.yml'))\n  )\nend","language":"ruby","dynamic":null,"tags":{}},"Facets.const_missing":{"!":"method","declarations":["class","public"],"path":"Facets.const_missing","name":"const_missing","namespace":"Facets","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"const_missing(.)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/version.rb","line":null,"source":"def self.const_missing(name)\n  key = name.to_s.downcase\n  profile[key] || super(name)\nend","language":"ruby","dynamic":null,"tags":{}},"Functor":{"!":"class","superclass":"Object","path":"Functor","name":"Functor","namespace":"","comment":"By definition a Functor is simply a first class method, but these are common\nin the form of Method and Proc. So for Ruby a Functor is a more specialized\nas a Higher-order function or Metafunction. Essentally, a Functor can vary\nits behavior accorrding to the operation applied to it.\n\n  f = Functor.new { |op, x| x.send(op, x) }\n  (f + 1)  #=> 2\n  (f + 2)  #=> 4\n  (f + 3)  #=> 6\n  (f * 1)  #=> 1\n  (f * 2)  #=> 4\n  (f * 3)  #=> 9","format":"rdoc","constants":["Functor::EXCEPTIONS"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Functor.cache","Functor#__class__","Functor#initialize","Functor#to_proc","Functor#method_missing"],"accessors":[],"files":["/lib/core/facets/functor.rb"],"tags":{}},"Functor::EXCEPTIONS":{"!":"constant","path":"Functor::EXCEPTIONS","name":"EXCEPTIONS","namespace":"Functor","comment":"","format":"rdoc","value":"[:binding, :inspect, :object_id]","tags":{},"files":["/lib/core/facets/functor.rb"]},"Functor.cache":{"!":"method","declarations":["class","public"],"path":"Functor.cache","name":"cache","namespace":"Functor","comment":"Functors can be somewhat inefficient if a new Functor\nis frequently recreated for the same use. So this cache\ncan be used to speed things up.\n\nThe +key+ will always be an array, wich makes it easier\nto cache functor for multiple factors.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cache(.)","arguments":[{"name":"*key"}],"block":{"name":"&function"}}],"returns":[],"file":"/lib/core/facets/functor.rb","line":null,"source":"def self.cache(*key, &function)\n  @cache ||= {}\n  if function\n    @cache[key] = new(&function)\n  else\n    @cache[key]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Functor#__class__":{"!":"method","declarations":["instance","public"],"path":"Functor#__class__","name":"__class__","namespace":"Functor","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__class__","arguments":[]}],"returns":[],"file":"/lib/core/facets/functor.rb","line":null,"source":"alias :__class__ :class","language":"ruby","dynamic":null,"tags":{}},"Functor#initialize":{"!":"method","declarations":["instance","public"],"path":"Functor#initialize","name":"initialize","namespace":"Functor","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(&function)","arguments":[],"block":{"name":"&function"}}],"returns":[{"type":"Functor","comment":"a new instance of Functor"}],"file":"/lib/core/facets/functor.rb","line":null,"source":"def initialize(&function)\n  @function = function\nend","language":"ruby","dynamic":null,"tags":{}},"Functor#to_proc":{"!":"method","declarations":["instance","public"],"path":"Functor#to_proc","name":"to_proc","namespace":"Functor","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_proc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/functor.rb","line":null,"source":"def to_proc\n  @function\nend","language":"ruby","dynamic":null,"tags":{}},"Functor#method_missing":{"!":"method","declarations":["instance","private"],"path":"Functor#method_missing","name":"method_missing","namespace":"Functor","comment":"Any action against the functor is processesd by the function.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(op, *args, &blk)","arguments":[{"name":"op"},{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/functor.rb","line":null,"source":"def method_missing(op, *args, &blk)\n  @function.call(op, *args, &blk)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_h":{"!":"method","declarations":["instance","public"],"path":"Array#to_h","name":"to_h","namespace":"Array","comment":"Converts an array into a hash. Converting an array\ninto a hash is not a one-to-one conversion, for this\nreason #to_h examines at the array being converted\nand then dispatches the conversion to the most sutiable\nspecialized function. There are three possiblities for this.\n\nIf the array is a collection of perfect pairs, like that\nwhich Hash#to_a generates, then conversion is handled by \n#to_h_flat.\n\n  a = [ [:a,1], [:b,2] ]\n  a.to_h  #=> { :a=>1, :b=>2 }\n\nIf the array contains only arrays, but are not perfect pairs,\nthen #to_h_multi is called.\n\n  a = [ [:a,1,2], [:b,2], [:c], [:d] ]\n  a.to_h  #=> { :a=>[1,2], :b=>[2], :c=>[], :d=>[] }\n\nIf the array contians objects other then arrays then\nthe #to_h_splat method is called.\n\n  a = [ [:a,1,2], 2, :b, [:c,3], 9 ]\n  a.to_h  #=> { [:a,1,2]=>2, :b=>[:c,3], 9=>nil } \n\nFinally, a particular dispatch can be forced by \nspecifying the +mode+ of conversion, eg. +:multi+,\n+:splat+, +:flat+, +:assoc+, etc.\n\nSetting +mode+ to +true+ is the same as setting it +:multi+.\nThis has been left in for backward compatability.\n\nNOTE: The use of a +values+ parameter has been deprecated\nbecause that functionality is as simple as ...\n\n  array1.zip(array2).to_h\n\nCREDIT: Robert Klemme, Trans\n\n--\nThe +True+ option in the case statement provides some\nbackward compatability with the previous versions of this\nmethod.\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h(mode=nil)","arguments":[{"name":"mode","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h(mode=nil)\n  case mode\n  when :splat\n    return to_h_splat\n  when :flat\n    return to_h_flat\n  when :multi, true\n    return to_h_multi\n  when :assoc\n    return to_h_assoc\n  else\n    return to_h_auto\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_h_auto":{"!":"method","declarations":["instance","public"],"path":"Array#to_h_auto","name":"to_h_auto","namespace":"Array","comment":"Converts an array into a hash. Converting an array\ninto a hash is not a one-to-one conversion, for this\nreason #to_h examines at the array being converted\nand then dispatches the conversion to the most sutiable\nspecialized function. There are three possiblities for this.\n\nIf the array is a collection of perfect pairs, like that\nwhich Hash#to_a generates, then conversion is handled by \n#to_h_flat.\n\n  a = [ [:a,1], [:b,2] ]\n  a.to_h_auto  #=> { :a=>1, :b=>2 }\n\nIf the array contains only arrays, but are not perfect pairs,\nthen #to_h_multi is called.\n\n  a = [ [:a,1,2], [:b,2], [:c], [:d] ]\n  a.to_h_auto  #=> { :a=>[1,2], :b=>[2], :c=>[], :d=>[] }\n\nIf the array contians objects other then arrays then\nthe #to_h_splat method is called.\n\n  a = [ [:a,1,2], 2, :b, [:c,3], 9 ]\n  a.to_h_auto  #=> { [:a,1,2]=>2, :b=>[:c,3], 9=>nil }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_auto()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_auto\n  pairs = true\n  mixed = false\n\n  each do |e|\n    case e\n    when Array\n      pairs = false if e.size > 2\n    else\n      mixed = true\n    end\n  end\n\n  if mixed\n    to_h_splat\n  elsif pairs\n    to_h_flat\n  else\n    to_h_multi\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_h_splat":{"!":"method","declarations":["instance","public"],"path":"Array#to_h_splat","name":"to_h_splat","namespace":"Array","comment":"This is equivalent to Hash[*array], but it will pad\nthe array with a +nil+ object if there are not an even number\nof elements.\n\n  a = [:a,1,:b,2,:c]\n  a.to_h_splat  #=> { :a=>1, :b=>2, :c=>nil }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_splat()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_splat\n  a = dup\n  a << nil if a.size % 2 == 1\n  Hash[*a]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_h_flat":{"!":"method","declarations":["instance","public"],"path":"Array#to_h_flat","name":"to_h_flat","namespace":"Array","comment":"This is equivalent to Hash[*array.flatten], but it will pad\nthe array with a +nil+ object if there are not an even number\nof elements.\n\n  a = [:a,1,[:b,2,:c]]\n  a.to_h_flat  #=> { :a=>1, :b=>2, :c=>nil }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_flat()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_flat\n  a = flatten\n  a << nil if a.size % 2 == 1\n  Hash[*a]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_h_assoc":{"!":"method","declarations":["instance","public"],"path":"Array#to_h_assoc","name":"to_h_assoc","namespace":"Array","comment":"When a mixed or multi-element accociative array\nis used, the result is as follows:\n\n  a = [ [:a,1,2], [:b,2], [:c], :d ]\n  a.to_h  #=> { :a=>[1,2], :b=>[2], :c=>[], :d=>[] }\n\nIf the first entry of any subelements are the same, then\nthe value will be set to the last occuring value.\n\n  a = [ :x, [:x], [:x,1,2], [:x,3], [:x,4] ]\n  a.to_h_assoc  #=> { :x=>[4] }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_assoc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_assoc\n  h = {}\n  each do |k,*v| \n    h[k] = v\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Array#to_h_multi":{"!":"method","declarations":["instance","public"],"path":"Array#to_h_multi","name":"to_h_multi","namespace":"Array","comment":"When a mixed or multi-element accociative array\nis used, the result is as follows:\n\n  a = [ [:a,1,2], [:b,2], [:c], :d ]\n  a.to_h  #=> { :a=>[1,2], :b=>[2], :c=>[], :d=>[] }\n\nIf the first entry of the subelements is the same, then\nthe values will be merged using #concat.\n\n  a = [ [:a,1,2], [:a,3], [:a,4], [:a], :a ]\n  a.to_h_multi  #=> { :a=>[1,2,3,4] }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_multi()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_multi\n  h = {}\n  each do |k,*v| \n    h[k] ||= []\n    h[k].concat(v)\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#to_h":{"!":"method","declarations":["instance","public"],"path":"Hash#to_h","name":"to_h","namespace":"Hash","comment":"Return a rehashing of _self_.\n\n  {\"a\"=>1,\"b\"=>2}.to_h  #=> {\"b\"=>2,\"a\"=>1}\n\nCREDIT: Forian Gross","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h; rehash; end","language":"ruby","dynamic":null,"tags":{}},"Hash#to_hash":{"!":"method","declarations":["instance","public"],"path":"Hash#to_hash","name":"to_hash","namespace":"Hash","comment":"Returns _self_.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_hash()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_hash; self; end","language":"ruby","dynamic":null,"tags":{}},"Enumerable":{"!":"module","path":"Enumerable","name":"Enumerable","namespace":"","comment":"--\nTODO: Consider Enumerator methods.\n++","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["Enumerable::Permeator","Enumerable::Recursor"],"methods":["Enumerable#to_h","Enumerable#to_h_auto","Enumerable#to_h_splat","Enumerable#to_h_flat","Enumerable#to_h_assoc","Enumerable#to_h_multi","Enumerable#one?","Enumerable#sum","Enumerable#per","Enumerable#none?","Enumerable#take","Enumerable#purge","Enumerable#every","Enumerable#every!","Enumerable#count","Enumerable#defer","Enumerable#occur","Enumerable#ewise","Enumerable#elementwise","Enumerable#graph","Enumerable#mash","Enumerable#visit","Enumerable#incase?","Enumerable#filter","Enumerable#map_by","Enumerable#expand","Enumerable#each_by","Enumerable#uniq_by","Enumerable#exclude?","Enumerable#hashify","Enumerable#group_by","Enumerable#map_send","Enumerable#modulate","Enumerable#map_with","Enumerable#zip_map","Enumerable#frequency","Enumerable#find_yield","Enumerable#map_detect","Enumerable#cluster_by","Enumerable#accumulate","Enumerable#accumulate_all","Enumerable#compact_map","Enumerable#compact_collect","Enumerable#recursively","Enumerable#map_with_index","Enumerable#collect_with_index","Enumerable#each_with_object"],"accessors":[],"files":["/lib/core/facets/enumerable/per.rb","/lib/core/facets/to_hash.rb","/lib/core/facets/enumerable/one.rb","/lib/core/facets/enumerable/sum.rb","/lib/core/facets/enumerable/none.rb","/lib/core/facets/enumerable/take.rb","/lib/core/facets/enumerable/purge.rb","/lib/core/facets/enumerable/every.rb","/lib/core/facets/enumerable/count.rb","/lib/core/facets/enumerable/defer.rb","/lib/core/facets/enumerable/occur.rb","/lib/core/facets/enumerable/ewise.rb","/lib/core/facets/enumerable/graph.rb","/lib/core/facets/enumerable/visit.rb","/lib/core/facets/enumerable/incase.rb","/lib/core/facets/enumerable/filter.rb","/lib/core/facets/enumerable/map_by.rb","/lib/core/facets/enumerable/expand.rb","/lib/core/facets/enumerable/each_by.rb","/lib/core/facets/enumerable/uniq_by.rb","/lib/core/facets/enumerable/exclude.rb","/lib/core/facets/enumerable/hashify.rb","/lib/core/facets/enumerable/group_by.rb","/lib/core/facets/enumerable/map_send.rb","/lib/core/facets/enumerable/modulate.rb","/lib/core/facets/enumerable/map_with.rb","/lib/core/facets/enumerable/frequency.rb","/lib/core/facets/enumerable/find_yield.rb","/lib/core/facets/enumerable/cluster_by.rb","/lib/core/facets/enumerable/accumulate.rb","/lib/core/facets/enumerable/compact_map.rb","/lib/core/facets/enumerable/recursively.rb","/lib/core/facets/enumerable/map_with_index.rb","/lib/core/facets/enumerable/each_with_object.rb"],"tags":{}},"Enumerable#to_h":{"!":"method","declarations":["instance","public"],"path":"Enumerable#to_h","name":"to_h","namespace":"Enumerable","comment":"Convert an Enumerable object into a hash by first\nturning it into an array.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h(mode=nil)","arguments":[{"name":"mode","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h(mode=nil)\n  to_a.to_h(mode)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#to_h_auto":{"!":"method","declarations":["instance","public"],"path":"Enumerable#to_h_auto","name":"to_h_auto","namespace":"Enumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_auto()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_auto\n  to_a.to_h_auto\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#to_h_splat":{"!":"method","declarations":["instance","public"],"path":"Enumerable#to_h_splat","name":"to_h_splat","namespace":"Enumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_splat()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_splat\n  to_a.to_h_splat\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#to_h_flat":{"!":"method","declarations":["instance","public"],"path":"Enumerable#to_h_flat","name":"to_h_flat","namespace":"Enumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_flat()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_flat\n  to_a.to_h_flat\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#to_h_assoc":{"!":"method","declarations":["instance","public"],"path":"Enumerable#to_h_assoc","name":"to_h_assoc","namespace":"Enumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_assoc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_assoc\n  to_a.to_h_assoc\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#to_h_multi":{"!":"method","declarations":["instance","public"],"path":"Enumerable#to_h_multi","name":"to_h_multi","namespace":"Enumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_multi()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_multi\n  to_a.to_h_multi\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass#to_h":{"!":"method","declarations":["instance","public"],"path":"NilClass#to_h","name":"to_h","namespace":"NilClass","comment":"Allows <tt>nil</tt> to create an empty hash,\nsimilar to #to_a and #to_s.\n\n  nil.to_h    #=> {}\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h; {}; end","language":"ruby","dynamic":null,"tags":{}},"Enumerator":{"!":"class","superclass":"Object","path":"Enumerator","name":"Enumerator","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["Enumerator::Yielder"],"methods":["Enumerator#old_initialize","Enumerator#initialize","Enumerator#_start","Enumerator#fx","Enumerator#fx_send"],"accessors":[],"files":["/lib/core/facets/enumerator.rb","/lib/core/facets/enumerator/fx.rb"],"tags":{}},"Enumerator#to_h":{"!":"method","declarations":["instance","public"],"path":"Enumerator#to_h","name":"to_h","namespace":"Enumerator","comment":"Convert an Enumerator object into a hash.\nThis is equivalent to Array#to_h.\n\n  e1 = [[1,:a],[2,:b],[3,:c]].to_enum\n  e1.to_h #=> { 1=>:a, 2=>:b, 3=>:c }\n\n  e2 = [1,2,3,4,5].to_enum\n  e2.to_h  #=> {5=>nil, 1=>2, 3=>4}\n\n  e3 = [1,2,1,3,1,5].to_enum\n  e3.to_h #=> {1=>5}\n\nCREDIT: Sandor Szcs","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h(mode=nil)","arguments":[{"name":"mode","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h(mode=nil)\n  to_a.to_h(mode)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#to_h_auto":{"!":"method","declarations":["instance","public"],"path":"Enumerator#to_h_auto","name":"to_h_auto","namespace":"Enumerator","comment":"This is equivalent to Array#to_h_auto.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_auto()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_auto\n  to_a.to_h_auto\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#to_h_splat":{"!":"method","declarations":["instance","public"],"path":"Enumerator#to_h_splat","name":"to_h_splat","namespace":"Enumerator","comment":"This is equivalent to Array#to_h_splat.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_splat()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_splat\n  to_a.to_h_splat\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#to_h_flat":{"!":"method","declarations":["instance","public"],"path":"Enumerator#to_h_flat","name":"to_h_flat","namespace":"Enumerator","comment":"This is equivalent to Array#to_h_flat.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_flat()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_flat\n  to_a.to_h_flat\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#to_h_assoc":{"!":"method","declarations":["instance","public"],"path":"Enumerator#to_h_assoc","name":"to_h_assoc","namespace":"Enumerator","comment":"This is equivalent to Array#to_h_assoc.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_assoc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_assoc\n  to_a.to_h_assoc\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#to_h_multi":{"!":"method","declarations":["instance","public"],"path":"Enumerator#to_h_multi","name":"to_h_multi","namespace":"Enumerator","comment":"This is equivalent to Array#to_h_multi.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h_multi()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h_multi\n  to_a.to_h_multi\nend","language":"ruby","dynamic":null,"tags":{}},"Struct":{"!":"class","superclass":"Object","path":"Struct","name":"Struct","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Struct#to_h","Struct#replace","Struct#attributes","Struct#object_state"],"accessors":[],"files":["/lib/core/facets/to_hash.rb","/lib/core/facets/object/replace.rb","/lib/core/facets/struct/attributes.rb","/lib/core/facets/object/object_state.rb"],"tags":{}},"Struct#to_h":{"!":"method","declarations":["instance","public"],"path":"Struct#to_h","name":"to_h","namespace":"Struct","comment":"Returns a hash containing the names and values\nfor all instance settings in the Struct.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h()","arguments":[]}],"returns":[],"file":"/lib/core/facets/to_hash.rb","line":null,"source":"def to_h\n  h = {}\n  each_pair{ |k,v| h[k] = v }\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Hash.zip":{"!":"method","declarations":["class","public"],"path":"Hash.zip","name":"zip","namespace":"Hash","comment":"Creates a new hash from two separate arrays, a +keys+ array and\na +values+ array.\n\n  Hash.zip([\"a\",\"b\",\"c\"], [1,2,3])\n  # => { \"a\"=>1, \"b\"=>2, \"c\"=>3 }\n\nCREDIT: Trans, Ara T. Howard","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"zip(.)","arguments":[{"name":"keys"},{"name":"values"}]}],"returns":[],"file":"/lib/core/facets/hash/zip.rb","line":null,"source":"def self.zip(keys,values) # or some better name\n  h = {}\n  keys.size.times{ |i| h[ keys[i] ] = values[i] }\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#p":{"!":"method","declarations":["instance","public"],"path":"Kernel#p","name":"p","namespace":"Kernel","comment":"Alternate to standard #p method that outputs\nKernel#inspect to stdout, but also passes through\nthe orginal argument(s) ...\n\n  x = 1\n  r = 4 + p(1)\n  p r\n\nproduces ...\n\n  1\n  5\n\nTODO: DEPRECATE as of 1.9, _if_ it will do this.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"p(*x)","arguments":[{"name":"*x"}]}],"returns":[],"file":"/lib/core/facets/kernel/p.rb","line":null,"source":"def p(*x)\n  x.each{ |e| puts e.inspect } #p(*x)\n  x.size > 1 ? x : x.last #x.last\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#Y":{"!":"method","declarations":["instance","public"],"path":"Kernel#Y","name":"Y","namespace":"Kernel","comment":"Y-combinator.\n\n f = Y do |n, acc, &b|\n   n < 2 ? acc : b.(n-1, n * acc) \n end\n\n f.call(5, 1) #=> 120\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Michael Fellinger","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"Y(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/y.rb","line":null,"source":"def Y(*args, &block)\n  y = lambda{|*args| block.call(*args, &y) }\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/kernel/y'"}},"Kernel#d":{"!":"method","declarations":["instance","public"],"path":"Kernel#d","name":"d","namespace":"Kernel","comment":"Like #p but gives file and line number...\n\n  d(\"hi\")\n\nproduces ...\n\n  \"hi\" (/home/dave/projects/foo.rb, 38)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"d(*x)","arguments":[{"name":"*x"}]}],"returns":[],"file":"/lib/core/facets/kernel/d.rb","line":null,"source":"def d(*x)\n  puts \"#{x.inspect} #{caller[0]}\"\n  return *x\nend","language":"ruby","dynamic":null,"tags":{}},"Time":{"!":"class","superclass":"Object","path":"Time","name":"Time","namespace":"","comment":"","format":"rdoc","constants":["Time::FORMAT"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Time#set","Time.stamp","Time#stamp","Time#shift","Time#in","Time#hence","Time#less","Time#ago","Time#trunc","Time#past?","Time#future?","Time.elapse","Time#change","Time#to_time","Time#round_to","Time#dst_adjustment"],"accessors":[],"files":["/lib/core/facets/time/set.rb","/lib/core/facets/time/stamp.rb","/lib/core/facets/time/shift.rb","/lib/core/facets/time/trunc.rb","/lib/core/facets/time/future.rb","/lib/core/facets/time/elapse.rb","/lib/core/facets/time/change.rb","/lib/core/facets/time/to_time.rb","/lib/core/facets/time/round_to.rb","/lib/core/facets/time/dst_adjustment.rb"],"tags":{}},"Time::FORMAT":{"!":"constant","path":"Time::FORMAT","name":"FORMAT","namespace":"Time","comment":"","format":"rdoc","value":"{\n  :utc      => \"%Y-%m-%d %H:%M:%S\",\n  :utcT     => \"%Y-%m-%dT%H:%M:%S\",\n  :db       => \"%Y-%m-%d %H:%M:%S\",\n  :database => \"%Y-%m-%d %H:%M:%S\",\n  :number   => \"%Y%m%d%H%M%S\",\n  :short    => \"%d %b %H:%M\",\n  :time     => \"%H:%M\",\n  :long     => \"%B %d, %Y %H:%M\",\n  :day1st   => \"%d-%m-%Y %H:%M\",\n  :dmYHM    => \"%d-%m-%Y %H:%M\",\n  :rfc822   => \"%a, %d %b %Y %H:%M:%S %z\",\n  :ruby18   => \"%a %b %d %H:%M:%S %z %Y\",\n  nil       => \"%Y-%m-%d %H:%M:%S %z\"\n}","tags":{},"files":["/lib/core/facets/time/stamp.rb"]},"Time#set":{"!":"method","declarations":["instance","public"],"path":"Time#set","name":"set","namespace":"Time","comment":"Like change but does not reset earlier times.\n\nNOTE: It would be better, probably if this were called \"change\".\nand that #change were called \"reset\".","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"set(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/core/facets/time/set.rb","line":null,"source":"def set(options)\n  opts={}\n  options.each_pair do |k,v| \n    k = :min if k.to_s =~ /^min/\n    k = :sec if k.to_s =~ /^sec/\n    opts[k] = v.to_i \n  end\n  self.class.send(\n    self.utc? ? :utc : :local,\n    opts[:year]  || self.year,\n    opts[:month] || self.month,\n    opts[:day]   || self.day,\n    opts[:hour]  || self.hour,\n    opts[:min]   || self.min,\n    opts[:sec]   || self.sec,\n    opts[:usec]  || self.usec\n  )\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#instance":{"!":"method","declarations":["instance","public"],"path":"Kernel#instance","name":"instance","namespace":"Kernel","comment":"Returns an instance of Instance for +self+,\nwhich allows convenient access to an object's\ninternals.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def instance\n  INSTANCES[self] ||= Instance.new(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Instance":{"!":"class","superclass":"Object","path":"Instance","name":"Instance","namespace":"","comment":"= Instance Class\n\n  class Friend\n    attr_accessor :name, :age, :phone\n    def initialize(name, age, phone)\n      @name, @age, @phone = name, age, phone\n    end\n  end\n\n  f1 = Friend.new(\"John\", 30, \"555-1212\")\n  f1.instance\n\n  f1.instance.update({:name=>'Jerry'})\n  f1.instance","format":"rdoc","constants":[],"includes":["Enumerable"],"extensions":[],"modules":[],"classes":[],"methods":["Instance#initialize","Instance#instance_delegate","Instance#each","Instance#to_h","Instance#to_hash","Instance#[]","Instance#[]=","Instance#<<","Instance#update","Instance#assign","Instance#variables","Instance#keys","Instance#names","Instance#values","Instance#eval","Instance#atize"],"accessors":[],"files":["/lib/core/facets/instance.rb"],"tags":{}},"Instance#initialize":{"!":"method","declarations":["instance","public"],"path":"Instance#initialize","name":"initialize","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(delegate)","arguments":[{"name":"delegate"}]}],"returns":[{"type":"Instance","comment":"a new instance of Instance"}],"file":"/lib/core/facets/instance.rb","line":null,"source":"def initialize(delegate)\n  @delegate = delegate\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#instance_delegate":{"!":"method","declarations":["instance","public"],"path":"Instance#instance_delegate","name":"instance_delegate","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_delegate()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def instance_delegate\n  @delegate\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#each":{"!":"method","declarations":["instance","public"],"path":"Instance#each","name":"each","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def each\n  @delegate.instance_variables.each do |name|\n    yield(name[1..-1].to_sym, @delegate.instance_variable_get(name))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#to_h":{"!":"method","declarations":["instance","public"],"path":"Instance#to_h","name":"to_h","namespace":"Instance","comment":"Return instance variables with values as a hash.\n\n  class X\n    def initialize(a,b)\n      @a, @b = a, b\n    end\n  end\n\n  x = X.new(1,2)\n\n  x.instance.to_h  #=> { :a=>1, :b=>2 }","format":"rdoc","aliases":["Instance#to_hash"],"singleton":null,"interfaces":[{"signature":"to_h(at=false)","arguments":[{"name":"at","default":"false"}]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def to_h(at=false)\n  h = {}\n  if at\n    @delegate.instance_variables.each do |name|\n      h[name] = @delegate.instance_variable_get(name)\n    end\n  else\n    each do |key, value|\n      h[key] = value\n    end\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#to_hash":{"!":"method","declarations":["instance","public"],"path":"Instance#to_hash","name":"to_hash","namespace":"Instance","comment":"Return instance variables with values as a hash.\n\n  class X\n    def initialize(a,b)\n      @a, @b = a, b\n    end\n  end\n\n  x = X.new(1,2)\n\n  x.instance.to_h  #=> { :a=>1, :b=>2 }\n\nTODO: Not sure if this should be used.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_h(at=false)","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def to_h(at=false)\n  h = {}\n  if at\n    @delegate.instance_variables.each do |name|\n      h[name] = @delegate.instance_variable_get(name)\n    end\n  else\n    each do |key, value|\n      h[key] = value\n    end\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#[]":{"!":"method","declarations":["instance","public"],"path":"Instance#[]","name":"[]","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def [](name)\n  name = atize(name)\n  @delegate.instance_variable_get(name)\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#[]=":{"!":"method","declarations":["instance","public"],"path":"Instance#[]=","name":"[]=","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[]=(name, value)","arguments":[{"name":"name"},{"name":"value"}]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def []=(name, value)\n  name = atize(name)\n  @delegate.instance_variable_set(name,value)\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#<<":{"!":"method","declarations":["instance","public"],"path":"Instance#<<","name":"<<","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"<<(pair)","arguments":[{"name":"pair"}]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def <<(pair)\n  name, value = *pair\n  name = atize(name)\n  @delegate.instance_variable_set(name, value)\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#update":{"!":"method","declarations":["instance","public"],"path":"Instance#update","name":"update","namespace":"Instance","comment":"Set instance variables given a +hash+.\n\n  instance.update('@a'=>1, '@b'=>2)\n  @a   #=> 1\n  @b   #=> 2\n\nAlso, +@+ sign is not neccessary.\n\n  instance.update(:a=>1, :b=>2)\n  @a   #=> 1\n  @b   #=> 2","format":"rdoc","aliases":["Instance#assign"],"singleton":null,"interfaces":[{"signature":"update(hash)","arguments":[{"name":"hash"}]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def update(hash)\n  hash.each do |pair|\n    self << pair\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#assign":{"!":"method","declarations":["instance","public"],"path":"Instance#assign","name":"assign","namespace":"Instance","comment":"Set instance variables given a +hash+.\n\n  instance.update('@a'=>1, '@b'=>2)\n  @a   #=> 1\n  @b   #=> 2\n\nAlso, +@+ sign is not neccessary.\n\n  instance.update(:a=>1, :b=>2)\n  @a   #=> 1\n  @b   #=> 2\n\nA hold-over from the the old #instance_assign method.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update(hash)","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def update(hash)\n  hash.each do |pair|\n    self << pair\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#variables":{"!":"method","declarations":["instance","public"],"path":"Instance#variables","name":"variables","namespace":"Instance","comment":"Same as #instance_variables.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"variables()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def variables\n  @delegate.instance_variables\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#keys":{"!":"method","declarations":["instance","public"],"path":"Instance#keys","name":"keys","namespace":"Instance","comment":"Instance vairable names as symbols.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"keys()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def keys\n  @delegate.instance_variables.collect do |name|\n    name[1..-1].to_sym\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#names":{"!":"method","declarations":["instance","public"],"path":"Instance#names","name":"names","namespace":"Instance","comment":"Instance variable names as strings.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"names()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def names\n  @delegate.instance_variables.collect do |name|\n    name[1..-1]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#values":{"!":"method","declarations":["instance","public"],"path":"Instance#values","name":"values","namespace":"Instance","comment":"Instance variable values.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"values()","arguments":[]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def values\n  @delegate.instance_variables.collect do |name|\n    @delegate.instance_variable_get(name)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#eval":{"!":"method","declarations":["instance","public"],"path":"Instance#eval","name":"eval","namespace":"Instance","comment":"Instance evaluation.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eval(*a,&b)","arguments":[{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def eval(*a,&b)\n  @delegate.instance_eval(*a,&b)\nend","language":"ruby","dynamic":null,"tags":{}},"Instance#atize":{"!":"method","declarations":["instance","private"],"path":"Instance#atize","name":"atize","namespace":"Instance","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"atize(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/instance.rb","line":null,"source":"def atize(name)\n  name.to_s !~ /^@/ ? \"@#{name}\" : name\nend","language":"ruby","dynamic":null,"tags":{}},"File":{"!":"class","superclass":"Object","path":"File","name":"File","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["File.ext","File.null","File.write","File.create","File.append","File.rewrite","File.rewrite!","File.rootname","File.sanitize","File.atomic_id","File.read_list","File.split_all","File.split_root","File.writelines","File.atomic_open","File.read_binary","File.atomic_write"],"accessors":[],"files":["/lib/core/facets/file/ext.rb","/lib/core/facets/file/null.rb","/lib/core/facets/file/write.rb","/lib/core/facets/file/create.rb","/lib/core/facets/file/append.rb","/lib/core/facets/file/rewrite.rb","/lib/core/facets/file/rootname.rb","/lib/core/facets/file/sanitize.rb","/lib/core/facets/file/atomic_id.rb","/lib/core/facets/file/read_list.rb","/lib/core/facets/file/split_all.rb","/lib/core/facets/file/split_root.rb","/lib/core/facets/file/writelines.rb","/lib/core/facets/file/atomic_open.rb","/lib/core/facets/file/read_binary.rb","/lib/core/facets/file/atomic_write.rb"],"tags":{}},"File.ext":{"!":"method","declarations":["class","public"],"path":"File.ext","name":"ext","namespace":"File","comment":"Takes a file name string and returns or changes its extension.\n\nWithout a new extension argument, returns the extension of the\nfile name. In this respect #ext is like #extname, but unlike\n#extname it does not include the dot prefix.\n\nWith a new extension argument, changes the exension of the file\nname to the new extension and returns it.\n\nExamples\n\n  File.ext('file.rb')          # => 'rb'\n  File.ext('file.rb', 'txt')   # => 'file.txt'\n  File.ext('file.rb', '.txt')  # => 'file.txt'\n  File.ext('file.rb', '')      # => 'file'\n\nThis method can be used with String#file for more object-oriented notation:\n\n  'file.rb'.file.ext('txt')    # => 'file.txt'\n\nCREDIT: Lavir the Whiolet","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ext(.)","arguments":[{"name":"filename"},{"name":"new_ext","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/file/ext.rb","line":null,"source":"def self.ext(filename, new_ext=nil)\n  old_ext = extname(filename)\n  if new_ext == nil\n    old_ext.sub(/^\\./, '')\n  else\n    new_ext = '.' + new_ext unless (new_ext.empty? || new_ext[0,1] == '.')\n    filename.chomp(old_ext) + new_ext\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#has_keys?":{"!":"method","declarations":["instance","public"],"path":"Hash#has_keys?","name":"has_keys?","namespace":"Hash","comment":"Returns true or false whether the hash\ncontains the given keys.\n\n  h = { :a => 1, :b => 2 }\n  h.has_keys?( :a )   #=> true\n  h.has_keys?( :c )   #=> false\n\nCREDIT: Trans","format":"rdoc","aliases":["Hash#keys?"],"singleton":null,"interfaces":[{"signature":"has_keys?(*check_keys)","arguments":[{"name":"*check_keys"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/hash/keys.rb","line":null,"source":"def has_keys?(*check_keys)\n  unknown_keys = check_keys - self.keys\n  return unknown_keys.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#keys?":{"!":"method","declarations":["instance","public"],"path":"Hash#keys?","name":"keys?","namespace":"Hash","comment":"Returns true or false whether the hash\ncontains the given keys.\n\n  h = { :a => 1, :b => 2 }\n  h.has_keys?( :a )   #=> true\n  h.has_keys?( :c )   #=> false\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"has_keys?(*check_keys)","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/keys.rb","line":null,"source":"def has_keys?(*check_keys)\n  unknown_keys = check_keys - self.keys\n  return unknown_keys.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#has_only_keys?":{"!":"method","declarations":["instance","public"],"path":"Hash#has_only_keys?","name":"has_only_keys?","namespace":"Hash","comment":"Returns true if the hash contains\n_only_ the given keys, otherwise false.\n\n  h = { :a => 1, :b => 2 }\n  h.has_only_keys?( :a, :b )   #=> true\n  h.has_only_keys?( :a )       #=> false\n\nCREDIT: Trans","format":"rdoc","aliases":["Hash#only_keys?"],"singleton":null,"interfaces":[{"signature":"has_only_keys?(*check_keys)","arguments":[{"name":"*check_keys"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/hash/keys.rb","line":null,"source":"def has_only_keys?(*check_keys)\n  unknown_keys = self.keys - check_keys\n  return unknown_keys.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#only_keys?":{"!":"method","declarations":["instance","public"],"path":"Hash#only_keys?","name":"only_keys?","namespace":"Hash","comment":"Returns true if the hash contains\n_only_ the given keys, otherwise false.\n\n  h = { :a => 1, :b => 2 }\n  h.has_only_keys?( :a, :b )   #=> true\n  h.has_only_keys?( :a )       #=> false\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"has_only_keys?(*check_keys)","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/keys.rb","line":null,"source":"def has_only_keys?(*check_keys)\n  unknown_keys = self.keys - check_keys\n  return unknown_keys.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#each_with_key":{"!":"method","declarations":["instance","public"],"path":"Hash#each_with_key","name":"each_with_key","namespace":"Hash","comment":"Each with key is like each_pair but reverses the order\nthe parameters to [value,key] instead of [key,value].\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_with_key(&yld)","arguments":[],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/hash/keys.rb","line":null,"source":"def each_with_key( &yld )\n  each_pair{ |k,v| yld.call(v,k) }\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#join":{"!":"method","declarations":["instance","public"],"path":"Hash#join","name":"join","namespace":"Hash","comment":"Like Array#join but specialized to Hash.\n\nNOTE: Without Ruby 1.9 this would be difficult to rely on becuase\nhashes did not have a strict order.\n\nCREDIT: Mauricio Fernandez","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"join(pair_divider='', elem_divider=nil)","arguments":[{"name":"pair_divider","default":"''"},{"name":"elem_divider","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/hash/join.rb","line":null,"source":"def join(pair_divider='', elem_divider=nil)\n  elem_divider ||= pair_divider\n  s = []\n  each{ |k,v| s << \"#{k}#{pair_divider}#{v}\" }\n  s.join(elem_divider)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#swap!":{"!":"method","declarations":["instance","public"],"path":"Hash#swap!","name":"swap!","namespace":"Hash","comment":"Swap the values of a pair of keys in place.\n\n  {:a=>1,:b=>2}.swap!(:a,:b)  #=> {:a=>2,:b=>1}\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"swap!(key1, key2)","arguments":[{"name":"key1"},{"name":"key2"}]}],"returns":[],"file":"/lib/core/facets/hash/swap.rb","line":null,"source":"def swap!(key1, key2)\n  tmp = self[key1]\n  self[key1] = self[key2]\n  self[key2] = tmp\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#data":{"!":"method","declarations":["instance","public"],"path":"Hash#data","name":"data","namespace":"Hash","comment":"Access to a hash as if it were an OpenStruct.\n\n  h = {:a=>1, :b=>2}\n\n  h.data.a  #=> 1\n  h.data.b  #=> 2\n  h.data.c  #=> nil\n\n  h.data.c = 3\n  h.data.c  #=> 3\n\n  h.data.a?  #=> true\n  h.data.d?  #=> false\n\nTODO: Change name of Hash#data to something better?\n\nTODO: Is this really a method worth having?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"data()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/data.rb","line":null,"source":"def data\n  this = self\n  Functor.new do |op, *a|\n    case op.to_s\n    when /\\=$/\n      op = op.to_s.chomp('=')\n      this[op] = a.first\n    when /\\?$/\n      op = op.to_s.chomp('?')\n      this.key?(op.to_s) || this.key?(op.to_sym)\n    when /\\!$/\n      op = op.to_s.chomp('!')\n      this[op] # ???\n    else\n      this[op.to_s] || this[op.to_sym]\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#diff":{"!":"method","declarations":["instance","public"],"path":"Hash#diff","name":"diff","namespace":"Hash","comment":"Difference comparison of two hashes.\n\n  h1 = {:a=>1,:b=>2}\n  h2 = {:a=>1,:b=>3}\n\n  h1.diff(h2)  #=> {:b=>2}\n  h2.diff(h1)  #=> {:b=>3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"diff(hash)","arguments":[{"name":"hash"}]}],"returns":[],"file":"/lib/core/facets/hash/diff.rb","line":null,"source":"def diff(hash)\n  h1 = self.dup.delete_if{ |k,v| hash[k] == v }\n  h2 = hash.dup.delete_if{ |k,v| has_key?(k) }\n  h1.merge(h2)\nend","language":"ruby","dynamic":null,"tags":{}},"File.null":{"!":"method","declarations":["class","public"],"path":"File.null","name":"null","namespace":"File","comment":"Platform dependent null device.\n\nCREDIT: Daniel Burger","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"null(.)","arguments":[]}],"returns":[],"file":"/lib/core/facets/file/null.rb","line":null,"source":"def self.null\n  case RUBY_PLATFORM\n  when /mswin/i\n    'NUL'\n  when /amiga/i\n    'NIL:'\n  when /openvms/i\n    'NL:'\n  else\n    '/dev/null'\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#pad":{"!":"method","declarations":["instance","public"],"path":"Array#pad","name":"pad","namespace":"Array","comment":"Pad an array with a given <tt>value</tt> up to a given <tt>length</tt>.\n\n  [0,1,2].pad(6,\"a\")  #=> [0,1,2,\"a\",\"a\",\"a\"]\n\nIf <tt>length</tt> is a negative number padding will be added\nto the beginning of the array.\n\n  [0,1,2].pad(-6,\"a\")  #=> [\"a\",\"a\",\"a\",0,1,2]\n\nCREDIT: Richard Laugesen","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pad(len, val=nil)","arguments":[{"name":"len"},{"name":"val","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/array/pad.rb","line":null,"source":"def pad(len, val=nil)\n  return dup if self.size >= len.abs\n  if len < 0\n    Array.new((len+size).abs,val) + self\n  else\n    self + Array.new(len-size,val)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#pad!":{"!":"method","declarations":["instance","public"],"path":"Array#pad!","name":"pad!","namespace":"Array","comment":"Like #pad but changes the array in place.\n\n   a = [0,1,2]\n   a.pad!(6,\"x\")\n   a  #=> [0,1,2,\"x\",\"x\",\"x\"]\n\nCREDIT: Richard Laugesen","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pad!(len, val=nil)","arguments":[{"name":"len"},{"name":"val","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/array/pad.rb","line":null,"source":"def pad!(len, val=nil)\n  return self if self.size >= len.abs\n  if len < 0\n    replace Array.new((len+size).abs,val) + self\n  else\n    concat Array.new(len-size,val)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module":{"!":"class","superclass":"Object","path":"Module","name":"Module","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":["Module::InstanceFunction"],"classes":[],"methods":["Module#+","Module#-","Module#*","Module#is?","Module#is","Module#set","Module#let","Module#can","Module#home","Module#homename","Module#modname","Module#housing","Module#nodef","Module#remove","Module#class?","Module#cattr","Module#cattr_reader","Module#cattr_writer","Module#cattr_accessor","Module#mattr","Module#mattr_reader","Module#mattr_writer","Module#mattr_accessor","Module#to_obj","Module#revise","Module#revisal","Module#pathize","Module#memoize","Module#basename","Module#ancestor?","Module#abstract","Module#enclosure","Module#enclosures","Module#encname","Module#spacename","Module#integrate","Module#methodize","Module#preextend","Module#anonymous?","Module#class_def","Module#module_def","Module#attr","Module#attr_reader","Module#attr_writer","Module#attr_accessor","Module#remove_method","Module#undef_method","Module#attr_tester","Module#alias_tester","Module#module_load","Module#module_require","Module#class_require","Module#class_load","Module#attr_setter","Module#alias_setter","Module#wrap_method","Module#wrap","Module#method_clash","Module#method_clash?","Module#class_extend","Module#class_extensions","Module#method_space","Module#include_as","Module#rename_method","Module#rename","Module#copy_inheritor","Module#class_accessor","Module#class_reader","Module#class_writer","Module#alias_accessor","Module#alias_reader","Module#alias_writer","Module#attr_validator","Module#alias_validator","Module#redefine_method","Module#redef","Module#class_inheritor","Module#redirect_method","Module#redirect","Module#instance_method!","Module#instance_function","Module#alias_method_chain","Module#attr_class_accessor","Module#attr_class_reader","Module#attr_class_writer","Module#all_instance_methods","Module#alias_module_function","Module#include_function_module","Module#instance_method_defined?","Module#singleton_method_defined?","Module#module_method_defined?","Module#class_method_defined?"],"accessors":[],"files":["/lib/core/facets/module/op.rb","/lib/core/facets/module/is.rb","/lib/core/facets/module/set.rb","/lib/core/facets/module/let.rb","/lib/core/facets/module/can.rb","/lib/core/facets/module/home.rb","/lib/core/facets/module/nodef.rb","/lib/core/facets/module/class.rb","/lib/core/facets/module/mattr.rb","/lib/core/facets/module/to_obj.rb","/lib/core/facets/module/revise.rb","/lib/core/facets/module/pathize.rb","/lib/core/facets/module/memoize.rb","/lib/core/facets/module/basename.rb","/lib/core/facets/module/ancestor.rb","/lib/core/facets/module/abstract.rb","/lib/core/facets/module/enclosure.rb","/lib/core/facets/module/spacename.rb","/lib/core/facets/module/integrate.rb","/lib/core/facets/module/methodize.rb","/lib/core/facets/module/preextend.rb","/lib/core/facets/module/anonymous.rb","/lib/core/facets/module/module_def.rb","/lib/core/facets/module/attr_tester.rb","/lib/core/facets/module/module_load.rb","/lib/core/facets/module/attr_setter.rb","/lib/core/facets/module/wrap_method.rb","/lib/core/facets/module/method_clash.rb","/lib/core/facets/module/class_extend.rb","/lib/core/facets/module/method_space.rb","/lib/core/facets/module/rename_method.rb","/lib/core/facets/module/copy_inheritor.rb","/lib/core/facets/module/class_accessor.rb","/lib/core/facets/module/alias_accessor.rb","/lib/core/facets/module/attr_validator.rb","/lib/core/facets/module/redefine_method.rb","/lib/core/facets/module/class_inheritor.rb","/lib/core/facets/module/redirect_method.rb","/lib/core/facets/module/instance_method.rb","/lib/core/facets/module/instance_function.rb","/lib/core/facets/module/alias_method_chain.rb","/lib/core/facets/module/attr_class_accessor.rb","/lib/core/facets/module/all_instance_methods.rb","/lib/core/facets/module/alias_module_function.rb","/lib/core/facets/module/include_function_module.rb","/lib/core/facets/module/instance_method_defined.rb"],"tags":{}},"Module#+":{"!":"method","declarations":["instance","public"],"path":"Module#+","name":"+","namespace":"Module","comment":"Combine modules.\n\n  module APlus\n    def a; \"a\"; end\n  end\n\n  module BPlus\n    def b; \"b\"; end\n  end\n\n  CPlus = APlus + BPlus\n\n  class XPlus; include CPlus; end\n\n  XPlus.new.a    #=> \"a\"\n  XPlus.new.b    #=> \"b\"\n\nNote that in the old version of traits.rb we cloned\nmodules and altered their copies...\n\n  def +(other)\n    mod1 = other.clone\n    mod2 = clone\n    mod1.module_eval{ include mod2 }\n  end\n\nLater it was realized that this thwarted the main\nbenefit that Ruby's concept of modules has over\ntraditional traits, inheritance.\n\nCREDIT: Thomas Sawyer, Robert Dober","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"+(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/module/op.rb","line":null,"source":"def +(other)\n  base = self\n  Module.new do\n    include base\n    include other\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#-":{"!":"method","declarations":["instance","public"],"path":"Module#-","name":"-","namespace":"Module","comment":"Subtract modules.\n\n  module AMinus\n    def a; \"a\"; end\n    def b; \"b\"; end\n  end\n\n  CMinus = AMinus - [:a]\n\n  class XMinus; include CMinus; end\n\n  expect NameError do\n    XMinus.new.a  #=> \"a\"\n  end\n\n  XMinus.new.b    #=> \"b\"\n\nTODO: Should this use all instance methods, not just public?\n\nCREDIT: Thomas Sawyer, Robert Dober","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"-(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/module/op.rb","line":null,"source":"def -(other)\n  instance_methods = instance_methods(true).map{|m| m.to_sym}\n  case other\n  when Array\n    subtract = instance_methods & other.map{|m| m.to_sym}\n  when Module\n    subtract = instance_methods & other.instance_methods(true).map{|m| m.to_sym}  # false?\n  when String, Symbol\n    subtract = instance_methods & [other.to_sym]\n  end\n  base = self\n  Module.new do\n    include base\n    subtract.each{ |x| undef_method x }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#*":{"!":"method","declarations":["instance","public"],"path":"Module#*","name":"*","namespace":"Module","comment":"Rename methods.\n\n  module AStar\n    def a; \"a\"; end\n  end\n\n  BStar = AStar * { :a => :b }\n\n  class XStar; include BStar; end\n\n  XStar.new.b    #=> \"a\"\n\nCREDIT: Thomas Sawyer, Robert Dober","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"*(rename_map)","arguments":[{"name":"rename_map"}]}],"returns":[],"file":"/lib/core/facets/module/op.rb","line":null,"source":"def *(rename_map)\n  base = self\n  Module.new do\n    include base\n    rename_map.each do |from, to|\n      alias_method to, from\n      undef_method from\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#in?":{"!":"method","declarations":["instance","public"],"path":"Kernel#in?","name":"in?","namespace":"Kernel","comment":"Is self included in other?\n\n  5.in?(0..10)       #=> true\n  5.in?([0,1,2,3])   #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"in?(other)","arguments":[{"name":"other"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/in.rb","line":null,"source":"def in?(other)\n  other.include?(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#as":{"!":"method","declarations":["instance","public"],"path":"Kernel#as","name":"as","namespace":"Kernel","comment":"Returns a As-functor that allows one to call any\nancestor's method directly of the given object.\n\n  class AsExample1\n    def x ; 1 ; end\n  end\n\n  class AsExample2 < AsExample1\n    def x ; 2 ; end\n  end\n\n  class AsExample3 < AsExample2\n    def x ; as(AsExample1).x ; end\n  end\n\n  AsExample1.new.x  #=> 1","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"as(ancestor, &blk)","arguments":[{"name":"ancestor"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"def as(ancestor, &blk)\n  ##this = self\n  r = As.new(self, ancestor)\n  ##unless r\n  ##  r = As.cache[self][ancestor] = Functor.new do |op, *a, &b|\n  ##    ancestor.instance_method(op).bind(this).call(*a,&b)\n  ##  end\n  ##end\n  r.instance_eval(&blk) if block_given? #yield(r) if block_given?\n  r\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#send_as":{"!":"method","declarations":["instance","public"],"path":"Kernel#send_as","name":"send_as","namespace":"Kernel","comment":"Call parent class/module methods once bound to self.\n\nTODO: Does this have the proper scope for #send?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"send_as(ancestor, sym, *args, &blk)","arguments":[{"name":"ancestor"},{"name":"sym"},{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"def send_as(ancestor, sym, *args, &blk)\n  ancestor.instance_method(sym).bind(self).call(*args,&blk)\nend","language":"ruby","dynamic":null,"tags":{}},"As":{"!":"class","superclass":"Object","path":"As","name":"As","namespace":"","comment":"Support class for Kernel#as.\n\nTODO: Deprecate this and use Functor (HigherOrderMessage) instead ?","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["As._new","As.new","As.cache","As#initialize","As#method_missing"],"accessors":[],"files":["/lib/core/facets/kernel/as.rb"],"tags":{}},"As._new":{"!":"method","declarations":["class","private"],"path":"As._new","name":"_new","namespace":"As","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_new","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"alias_method :_new, :new","language":"ruby","dynamic":null,"tags":{}},"As.new":{"!":"method","declarations":["class","public"],"path":"As.new","name":"new","namespace":"As","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"new(subject, ancestor)","arguments":[{"name":"subject"},{"name":"ancestor"}]}],"returns":[],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"def new(subject, ancestor)\n  cache[subject][ancestor] ||= _new(subject, ancestor)\nend","language":"ruby","dynamic":null,"tags":{}},"As.cache":{"!":"method","declarations":["class","private"],"path":"As.cache","name":"cache","namespace":"As","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cache()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"def cache\n  @cache ||= Hash.new{|h,k| h[k]={} }\nend","language":"ruby","dynamic":null,"tags":{}},"As#initialize":{"!":"method","declarations":["instance","public"],"path":"As#initialize","name":"initialize","namespace":"As","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(subject, ancestor)","arguments":[{"name":"subject"},{"name":"ancestor"}]}],"returns":[{"type":"As","comment":"a new instance of As"}],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"def initialize(subject, ancestor)\n  @subject = subject\n  @ancestor = ancestor\nend","language":"ruby","dynamic":null,"tags":{}},"As#method_missing":{"!":"method","declarations":["instance","private"],"path":"As#method_missing","name":"method_missing","namespace":"As","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(sym, *args, &blk)","arguments":[{"name":"sym"},{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/as.rb","line":null,"source":"def method_missing(sym, *args, &blk)\n  @ancestor.instance_method(sym).bind(@subject).call(*args,&blk)\nend","language":"ruby","dynamic":null,"tags":{}},"Proc":{"!":"class","superclass":"Object","path":"Proc","name":"Proc","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Proc#bind","Proc#curry","Proc#update","Proc#compose","Proc#*","Proc#bind_to","Proc#partial","Proc#to_method"],"accessors":[],"files":["/lib/core/facets/proc/bind.rb","/lib/core/facets/proc/curry.rb","/lib/core/facets/proc/update.rb","/lib/core/facets/proc/compose.rb","/lib/core/facets/proc/bind_to.rb","/lib/core/facets/proc/partial.rb","/lib/core/facets/proc/to_method.rb"],"tags":{}},"Proc#bind":{"!":"method","declarations":["instance","public"],"path":"Proc#bind","name":"bind","namespace":"Proc","comment":"Bind a Proc to an object returning a Method.\n\nNOTE: This version comes from Rails. The old Facets\nversion used thread.rb, but I no longer think\nthe implementaiton is thread critical. Please\nmake a bug report if this proves wrong.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bind(object)","arguments":[{"name":"object"}]}],"returns":[],"file":"/lib/core/facets/proc/bind.rb","line":null,"source":"def bind(object)\n  block, time = self, Time.now\n  method_name = \"__bind_#{time.to_i}_#{time.usec}\"\n  object.singleton_class.class_eval do\n    define_method(method_name, &block)\n    method = instance_method(method_name)\n    remove_method(method_name)\n    method\n  end.bind(object)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable":{"!":"module","path":"Indexable","name":"Indexable","namespace":"","comment":"Indexable is a mixin that provides index based methods,\nworking soley with four methods: #index, #slice, #splice\nand #size.\n\nThese methods work in harmony. Where #index returns a\nposition of a given element, #slice returns elements\nfor given positions. #splice is like #slice but replaces\nthe given position with new values. This mehtod is not\npart of ruby core, but it generally just an alias for #[]=,\njust as #slice is an alias of #[]. #size of course simply\nreturns the total length of the indexable object.\n\nNOTE: To test the folowing methods Indexable needs to be\nincluded into Array and array must have #splice defined.\n\n  require 'facets/array/splice'\n\n  class ::Array\n    include Indexable\n  end\n\nCREDIT: Thomas Sawyer","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Indexable#head","Indexable#tail","Indexable#foot","Indexable#body","Indexable#mid","Indexable#middle","Indexable#thru","Indexable#from","Indexable#first","Indexable#last","Indexable#first=","Indexable#last=","Indexable#first!","Indexable#last!","Indexable#ends","Indexable#pos","Indexable#index","Indexable#index_of","Indexable#range"],"accessors":[],"files":["/lib/core/facets/indexable.rb"],"tags":{}},"Indexable#head":{"!":"method","declarations":["instance","public"],"path":"Indexable#head","name":"head","namespace":"Indexable","comment":"Like #first but returns the first element\nin a new array.\n\n  [1,2,3].head  #=> [1]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"head()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def head\n  slice(0,1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#tail":{"!":"method","declarations":["instance","public"],"path":"Indexable#tail","name":"tail","namespace":"Indexable","comment":"Returns an array from second element to last element.\n\n  [1,2,3].tail  #=> [2,3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tail()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def tail\n  slice(1,length-1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#foot":{"!":"method","declarations":["instance","public"],"path":"Indexable#foot","name":"foot","namespace":"Indexable","comment":"Like #last, returning the last element\nin an array.\n\n  [1,2,3].foot  #=> [3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"foot()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def foot\n  slice(-1,1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#body":{"!":"method","declarations":["instance","public"],"path":"Indexable#body","name":"body","namespace":"Indexable","comment":"Returns an array of the first element upto,\nbut not including, the last element.\n\n  [1,2,3].body  #=> [1,2]\n\n--\nBetter name for this? (bulk, perhaps?)\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"body()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def body\n  slice(0,size-1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#mid":{"!":"method","declarations":["instance","public"],"path":"Indexable#mid","name":"mid","namespace":"Indexable","comment":"Returns the middle element of an array, or the element offset\nfrom middle if the parameter is given. Even-sized arrays,\nnot having an exact middle, return the middle-right element.\n\n  [1,2,3,4,5].mid        #=> 3\n  [1,2,3,4,5,6].mid      #=> 4\n  [1,2,3,4,5,6].mid(-1)  #=> 3\n  [1,2,3,4,5,6].mid(-2)  #=> 2\n  [1,2,3,4,5,6].mid(1)   #=> 5\n\nIn other words, If there are an even number of elements the\nhigher-indexed of the two center elements is indexed as\norgin (0).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mid(offset=0)","arguments":[{"name":"offset","default":"0"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def mid(offset=0)\n  slice((size / 2) + offset)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#middle":{"!":"method","declarations":["instance","public"],"path":"Indexable#middle","name":"middle","namespace":"Indexable","comment":"Returns an Array of the middle element(s) of an array.\nEven-sized arrays, not having an exact middle, return\na two-element array of the two middle elements.\n\n  [1,2,3,4,5].middle        #=> [3]\n  [1,2,3,4,5,6].middle      #=> [3,4]\n\nA +birth+ can be give to widen the middle on either side.\n\n  [1,2,3,4,5].middle(1)   #=> [2,3,4]\n  [1,2,3,4,5,6].middle(1)   #=> [2,3,4,5]\n\nIn contrast to #mid which utilizes an offset.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"middle(birth=0)","arguments":[{"name":"birth","default":"0"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def middle(birth=0)\n  i = size / 2 - birth\n  if size % 2 == 0\n    slice(i - 1, 2 + (2 * birth))\n  else\n    slice(i, 1 + (2 * birth))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#thru":{"!":"method","declarations":["instance","public"],"path":"Indexable#thru","name":"thru","namespace":"Indexable","comment":"Fetch values from a start index thru an end index.\n\n  [1,2,3,4,5].thru(0,2)  #=> [1,2,3]\n  [1,2,3,4,5].thru(2,4)  #=> [3,4,5]\n\n  [1,2,3,4,5].thru(2)  #=> [1,2,3]\n  [1,2,3,4,5].thru(4)  #=> [1,2,3,4,5]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"thru(from, to=nil)","arguments":[{"name":"from"},{"name":"to","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def thru(from, to=nil)\n  from, to = 0, from unless to\n  to = size - 1 if to >= size\n  a = []\n  i = from\n  while i <= to\n    a << slice(i)\n    i += 1\n  end\n  a\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#from":{"!":"method","declarations":["instance","public"],"path":"Indexable#from","name":"from","namespace":"Indexable","comment":"Returns last _n_ elements.\n\n  %w{W o r l d}.from(3)  #=> %w{l d}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"from(i)","arguments":[{"name":"i"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def from(i)\n  return self if i >= size\n  slice(i, size - i) #slice(-n..-1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#first":{"!":"method","declarations":["instance","public"],"path":"Indexable#first","name":"first","namespace":"Indexable","comment":"Returns first _n_ elements.\n\n  %w{H e l l o}.first(3)  #=> %w{H e l}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first(n=1)","arguments":[{"name":"n","default":"1"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def first(n=1)\n  slice(0, n.to_i)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#last":{"!":"method","declarations":["instance","public"],"path":"Indexable#last","name":"last","namespace":"Indexable","comment":"Returns last _n_ elements.\n\n  %w{H e l l o}.last(3)  #=> %w{l l o}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last(n=1)","arguments":[{"name":"n","default":"1"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def last(n=1)\n  n = n.to_i\n  return self if n > size\n  slice(-n, n) #slice(-n..-1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#first=":{"!":"method","declarations":["instance","public"],"path":"Indexable#first=","name":"first=","namespace":"Indexable","comment":"Change the first element.\n\n  a = [\"a\",\"y\",\"z\"]\n  a.first = \"x\"\n  a           #=> [\"x\",\"y\",\"z\"]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first=(x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def first=(x)\n  splice(0,x)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#last=":{"!":"method","declarations":["instance","public"],"path":"Indexable#last=","name":"last=","namespace":"Indexable","comment":"Change the last element.\n\n  a = [1,2,5]\n  a.last = 3\n  a           #=> [1,2,3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last=(x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def last=(x)\n  splice(-1,x)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#first!":{"!":"method","declarations":["instance","public"],"path":"Indexable#first!","name":"first!","namespace":"Indexable","comment":"Remove and return the first element.\n\n  a = [1,2,3]\n  a.first!      #=> 1\n  a             #=> [2,3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def first!\n  splice(0)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#last!":{"!":"method","declarations":["instance","public"],"path":"Indexable#last!","name":"last!","namespace":"Indexable","comment":"Remove and return the last element.\n\n  a = [1,2,3]\n  a.last!       #=> 3\n  a             #=> [1,2]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def last!\n  splice(-1)\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#ends":{"!":"method","declarations":["instance","public"],"path":"Indexable#ends","name":"ends","namespace":"Indexable","comment":"A shorting of \"ends at\", returns the\nlast index of the indexable object.\nReturns nil if there are no elements.\n\n  [1,2,3,4,5].ends  #=> 4\n\nThis nearly equivalent to +size - 1+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ends()","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def ends\n  return nil if size == 0\n  size - 1\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#pos":{"!":"method","declarations":["instance","public"],"path":"Indexable#pos","name":"pos","namespace":"Indexable","comment":"Returns the positive ordinal index given\na cardinal position, 1 to n or -n to -1.\n\n  [1,2,3,4,5].pos(1)   #=> 0\n  [1,2,3,4,5].pos(-1)  #=> 4","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pos(i)","arguments":[{"name":"i"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def pos(i)\n  if i > 0\n    return i - 1\n  else\n    size + i\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#index":{"!":"method","declarations":["instance","public"],"path":"Indexable#index","name":"index","namespace":"Indexable","comment":"Returns the index of the first element equal to the\ngiven object or satisfying the block condition.\n\n  [1,2,3,4].index{ |e| e == 3 }  #=> 2\n  [1,2,3,4].index{ |e| e > 3 }   #=> 3","format":"rdoc","aliases":["Indexable#index_of"],"singleton":null,"interfaces":[{"signature":"index(obj=nil, &block)","arguments":[{"name":"obj","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def index(obj=nil, &block)\n  if block_given?\n    size.times do |i|\n      return i if yield(slice(i))\n    end\n  else\n    size.times do |i|\n      return i if obj == slice(i)\n    end\n  end\n  nil\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#index_of":{"!":"method","declarations":["instance","public"],"path":"Indexable#index_of","name":"index_of","namespace":"Indexable","comment":"Returns the index of the first element equal to the\ngiven object or satisfying the block condition.\n\n  [1,2,3,4].index{ |e| e == 3 }  #=> 2\n  [1,2,3,4].index{ |e| e > 3 }   #=> 3\n\nto be deprecated","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"index(obj=nil, &block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def index(obj=nil, &block)\n  if block_given?\n    size.times do |i|\n      return i if yield(slice(i))\n    end\n  else\n    size.times do |i|\n      return i if obj == slice(i)\n    end\n  end\n  nil\nend","language":"ruby","dynamic":null,"tags":{}},"Indexable#range":{"!":"method","declarations":["instance","public"],"path":"Indexable#range","name":"range","namespace":"Indexable","comment":"Returns the index range between two elements. If no elements are\ngiven, returns the range from first to last.\n\n  ['a','b','c','d'].range            #=> (0..3)\n  ['a','b','c','d'].range('b','d')   #=> (1..3)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"range(a=nil,z=-1))","arguments":[{"name":"a","default":"nil"},{"name":"z","default":"-1)"}]}],"returns":[],"file":"/lib/core/facets/indexable.rb","line":null,"source":"def range(a=nil,z=-1)\n  if a\n    index(a)..index(z)\n  else\n    (0..(size-1))\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#is?":{"!":"method","declarations":["instance","public"],"path":"Module#is?","name":"is?","namespace":"Module","comment":"Is a given class or module an ancestor of this\nclass or module?\n\n  class IsX ; end\n  class IsY < IsX ; end\n\n  IsY.is?(IsX)  #=> true\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"is?(base)","arguments":[{"name":"base"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/module/is.rb","line":null,"source":"def is?(base)\n  Module===base && ancestors.slice(1..-1).include?(base)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#is":{"!":"method","declarations":["instance","public"],"path":"Module#is","name":"is","namespace":"Module","comment":"An alias for #include.\n\n  class IsExample\n    is Enumerable\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"is(*mods)","arguments":[{"name":"*mods"}]}],"returns":[],"file":"/lib/core/facets/module/is.rb","line":null,"source":"def is(*mods)\n  mods.each do |mod|\n    if mod.const_defined?(:Self)\n      extend mod::Self\n      # pass it along if module\n      if instance_of?(Module)\n        const_set(:Self, Module.new) unless const_defined?(:Self)\n        const_get(:Self).send(:include, mod::Self)\n      end\n    end\n  end\n  include(*mods)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#try":{"!":"method","declarations":["instance","public"],"path":"Kernel#try","name":"try","namespace":"Kernel","comment":"Invokes the method identified by the symbol +method+, passing it any\narguments  and/or the block specified, just like the regular Ruby\n<tt>Object#send</tt> does.\n\n*Unlike* that method however, a +NoMethodError+ exception will *not*\nbe raised and +nil+ will be returned instead, if the receiving object\nis a +nil+ object or NilClass.\n\nFor example, without try\n\n  @example = Struct.new(:name).new(\"bob\")\n\n  @example && @example.name\n\nor:\n\n  @example ? @example.name : nil\n\nBut with try\n\n  @example.try(:name)  #=> \"bob\"\n\nor\n\n  @example.try.name    #=> \"bob\"\n\nIt also accepts arguments and a block, for the method it is trying:\n\n  @people.try(:collect){ |p| p.name }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"try(method=nil, *args, &block)","arguments":[{"name":"method","default":"nil"},{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/try.rb","line":null,"source":"def try(method=nil, *args, &block)\n  if method\n    __send__(method, *args, &block)\n  else\n    self\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass#try":{"!":"method","declarations":["instance","public"],"path":"NilClass#try","name":"try","namespace":"NilClass","comment":"See Kernel#try.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"try(method=nil, *args)","arguments":[{"name":"method","default":"nil"},{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/kernel/try.rb","line":null,"source":"def try(method=nil, *args)\n  if method\n    nil\n  else\n    Functor.new{ nil }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#tap":{"!":"method","declarations":["instance","public"],"path":"Kernel#tap","name":"tap","namespace":"Kernel","comment":"The tap K-Combinator. This yields self -and- returns self.\n\nNote, Ruby 1.9+ does not support the zero arity #instance_eval\nvariation so it has been deprecated.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tap()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/tap.rb","line":null,"source":"def tap #:yield:\n  yield(self)\n  self\nend","language":"ruby","dynamic":null,"tags":{"yieldparam":"the object that the method was called on","yield":""}},"Module#set":{"!":"method","declarations":["instance","public"],"path":"Module#set","name":"set","namespace":"Module","comment":"Sets an option to the given value. If the value is a proc,\nthe proc will be called every time the option is accessed.\n\nCREDIT: Blake Mizerany (Sinatra)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"set(option, value=self, &block)","arguments":[{"name":"option"},{"name":"value","default":"self"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/module/set.rb","line":null,"source":"def set(option, value=self, &block)\n  raise ArgumentError if block && value != self\n  value = block if block\n  if value.kind_of?(Proc)\n    if value.arity == 1\n      yield self\n    else\n      (class << self; self; end).module_eval do\n        define_method(option, &value)\n        define_method(\"#{option}?\"){ !!__send__(option) }\n        define_method(\"#{option}=\"){ |val| set(option, Proc.new{val}) }\n      end\n    end\n  elsif value == self\n    option.each{ |k,v| set(k, v) }\n  elsif respond_to?(\"#{option}=\")\n    __send__(\"#{option}=\", value)\n  else\n    set(option, Proc.new{value})\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Time.stamp":{"!":"method","declarations":["class","public"],"path":"Time.stamp","name":"stamp","namespace":"Time","comment":"Produce time stamp for Time.now. See #stamp.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stamp(.)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/time/stamp.rb","line":null,"source":"def self.stamp(*args)\n  now.stamp(*args)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#stamp":{"!":"method","declarations":["instance","public"],"path":"Time#stamp","name":"stamp","namespace":"Time","comment":"Create a time stamp.\n\n  t = Time.at(10000)\n  t.stamp(:short)    #=> \"31 Dec 21:46\"\n\nSupported formats come from the Time::FORMAT constant.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stamp(fmt = nil)","arguments":[{"name":"fmt","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/time/stamp.rb","line":null,"source":"def stamp(fmt = nil)\n  unless String === fmt\n    fmt = FORMAT[fmt]\n  end\n  strftime(fmt).strip\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#weave":{"!":"method","declarations":["instance","public"],"path":"Hash#weave","name":"weave","namespace":"Hash","comment":"Weave is a very uniqe hash operator. I is designed\nto merge to complex hashes in according to sensible,\nregular pattern. The effect is akin to inheritance.\n\nTwo hashes are weaved together to produce a new hash.\nThe two hashes need to be compatible according to the\nfollowing rules for each node: ...\n\n  hash,   hash    => hash (recursive +)\n  hash,   array   => error\n  hash,   value   => error\n  array,  hash    => error\n  array,  array   => array + array\n  array,  value   => array << value\n  value,  hash    => error\n  value,  array   => array.unshift(valueB)\n  value1, value2  => value2\n\nHere is a basic example:\n\n  h1 = { :a => 1, :b => [ 1 ], :c => { :x => 1 } }\n  h2 = { :a => 2, :b => [ 2 ], :c => { :x => 2 } }\n\n  h1.weave(h2)\n  #=> {:b=>[1, 2], :c=>{:x=>2}, :a=>2}\n\nWeave follows the most expected pattern of unifying two complex\nhashes. It is especially useful for implementing overridable\nconfiguration schemes.\n\nCREDIT: Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"weave(h)","arguments":[{"name":"h"}]}],"returns":[],"file":"/lib/core/facets/hash/weave.rb","line":null,"source":"def weave(h)\n  raise ArgumentError, \"Hash expected\" unless h.kind_of?(Hash)\n  s = self.clone\n  h.each { |k,node|\n    node_is_hash = node.kind_of?(Hash)\n    node_is_array = node.kind_of?(Array)\n    if s.has_key?(k)\n      self_node_is_hash = s[k].kind_of?(Hash)\n      self_node_is_array = s[k].kind_of?(Array)\n      if self_node_is_hash\n        if node_is_hash\n          s[k] = s[k].weave(node)\n        elsif node_is_array\n          raise ArgumentError, 'Incompatible hash addition' #self[k] = node\n        else\n          raise ArgumentError, 'Incompatible hash addition' #self[k] = node\n        end\n      elsif self_node_is_array\n        if node_is_hash\n          raise ArgumentError, 'Incompatible hash addition' #self[k] = node\n        elsif node_is_array\n          s[k] += node\n        else\n          s[k] << node\n        end\n      else\n        if node_is_hash\n          raise ArgumentError, 'Incompatible hash addition' #self[k] = node\n        elsif node_is_array\n          s[k].unshift( node )\n        else\n          s[k] = node\n        end\n      end\n    else\n      s[k] = node\n    end\n  }\n  s\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Kernel#not?":{"!":"method","declarations":["instance","public"],"path":"Kernel#not?","name":"not?","namespace":"Kernel","comment":"Same as using NOT operator '!'.\n\n true.nil?.not? == !true.nil?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"not?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/not.rb","line":null,"source":"def not?\n  !self\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#not":{"!":"method","declarations":["instance","public"],"path":"Kernel#not","name":"not","namespace":"Kernel","comment":"Inversion functor.\n\n  true.not.nil?  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"not()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/not.rb","line":null,"source":"def not\n  Functor.new(&method(:not_send).to_proc)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#not_send":{"!":"method","declarations":["instance","private"],"path":"Kernel#not_send","name":"not_send","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"not_send(op, *a, &b)","arguments":[{"name":"op"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/core/facets/kernel/not.rb","line":null,"source":"def not_send(op, *a, &b)\n  !__send__(op, *a)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#ask":{"!":"method","declarations":["instance","public"],"path":"Kernel#ask","name":"ask","namespace":"Kernel","comment":"Very simple convenience method to get user input\nvia the console. A prompt will be sent to $stdout,\nif given, and the input taken from $stdin...\n\n  ask \"Are you happy? [Yn]\"\n\nOn the command line one would see...\n\n  Are you happy? [Yn]\n\nResponding...\n\n  Are you happy? [Yn] Y <ENTER>\n\nThe ask method would return \"Y\".","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ask(prompt=nil)","arguments":[{"name":"prompt","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/kernel/ask.rb","line":null,"source":"def ask(prompt=nil)\n  $stdout << \"#{prompt}\"\n  $stdout.flush\n  $stdin.gets.chomp!\nend","language":"ruby","dynamic":null,"tags":{}},"String#tab":{"!":"method","declarations":["instance","public"],"path":"String#tab","name":"tab","namespace":"String","comment":"Aligns each line n spaces.\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tab(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/string/tab.rb","line":null,"source":"def tab(n)\n  gsub(/^ */, ' ' * n)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#|":{"!":"method","declarations":["instance","public"],"path":"Hash#|","name":"|","namespace":"Hash","comment":"Operator for #reverse_merge.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"|(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/op_or.rb","line":null,"source":"def |(other)\n  other.merge(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#val?":{"!":"method","declarations":["instance","public"],"path":"Kernel#val?","name":"val?","namespace":"Kernel","comment":"Tests to see if something has value. An object\nis considered to have value if it is not nil?\nand if it responds to #empty?, is not empty.\n\n  nil.val?     #=> false\n  [].val?      #=> false\n  10.val?      #=> true\n  [nil].val?   #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"val?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/val.rb","line":null,"source":"def val?\n  return false if nil?\n  return false if empty? if respond_to?(:empty?)\n  true\nend","language":"ruby","dynamic":null,"tags":{}},"Proc#curry":{"!":"method","declarations":["instance","public"],"path":"Proc#curry","name":"curry","namespace":"Proc","comment":"Curry Proc object into new Proc object.\n\nTODO: Utilize Ruby 1.9's #curry method.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"curry(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/proc/curry.rb","line":null,"source":"def curry(*args)\n  if args.empty?\n    idx = (0...arity).to_a\n  else\n    raise ArgumentError, \"argument count is greater than prok.arity (#{args.size} > #{arity})\" if args.size > arity\n    raise ArgumentError, \"arguments must be unique indexes\" if args.uniq != args\n    raise ArgumentError, \"arguments must be indexes\" if args.any?{ |a| !Fixnum===a }\n    idx = (0...arity).to_a\n    idx = args + (idx - args)\n  end\n\n  pro = self\n  rec = ''\n  idx.each do |i|\n    rec << \"proc { |a#{i}| \"\n  end\n  rec << \"pro[\"\n  rec << (0...arity).to_a.collect{|i| \"a#{i}\"}.join(',')\n  rec << \"]\"\n  rec << \"}\" * arity\n\n  instance_eval rec\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#of":{"!":"method","declarations":["instance","public"],"path":"Integer#of","name":"of","namespace":"Integer","comment":"Like #times but returns a collection of the yield results.\n\n  a = 3.of { |i| \"#{i+1}\" }\n  a #=> [ \"1\", \"2\", \"3\" ]","format":"rdoc","aliases":["Integer#times_collect","Integer#times_map"],"singleton":null,"interfaces":[{"signature":"of(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/integer/of.rb","line":null,"source":"def of(&block)\n  Array.new(self, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#times_collect":{"!":"method","declarations":["instance","public"],"path":"Integer#times_collect","name":"times_collect","namespace":"Integer","comment":"Like #times but returns a collection of the yield results.\n\n  a = 3.of { |i| \"#{i+1}\" }\n  a #=> [ \"1\", \"2\", \"3\" ]\n\nTime warn aliases for #of.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"of(&block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/integer/of.rb","line":null,"source":"def of(&block)\n  Array.new(self, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#times_map":{"!":"method","declarations":["instance","public"],"path":"Integer#times_map","name":"times_map","namespace":"Integer","comment":"Like #times but returns a collection of the yield results.\n\n  a = 3.of { |i| \"#{i+1}\" }\n  a #=> [ \"1\", \"2\", \"3\" ]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"of(&block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/integer/of.rb","line":null,"source":"def of(&block)\n  Array.new(self, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#from":{"!":"method","declarations":["instance","public"],"path":"Array#from","name":"from","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"from(i)","arguments":[{"name":"i"}]}],"returns":[],"file":"/lib/core/facets/array/from.rb","line":null,"source":"def from(i)\n  return self if i >= size\n  self[i, size - i]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#thru":{"!":"method","declarations":["instance","public"],"path":"Array#thru","name":"thru","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"thru(from, to=nil)","arguments":[{"name":"from"},{"name":"to","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/array/from.rb","line":null,"source":"def thru(from, to=nil)\n  from, to = 0, from unless to\n  to = size - 1 if to >= size\n  a = []\n  i = from\n  while i <= to\n    a << self[i]\n    i += 1\n  end\n  a\nend","language":"ruby","dynamic":null,"tags":{}},"Time#shift":{"!":"method","declarations":["instance","public"],"path":"Time#shift","name":"shift","namespace":"Time","comment":"Returns a new Time representing the time shifted by the time-units given.\nPositive number shift the time forward, negative number shift the time \nbackward.\n\n  t = Time.utc(2010,10,10,0,0,0)\n  t.shift( 4, :days)            #=>  Time.utc(2010,10,14,0,0,0)\n  t.shift(-4, :days)            #=>  Time.utc(2010,10,6,0,0,0)\n\nMore than one unit of time can be given.\n\n  t.shift(4, :days, 3, :hours)  #=>  Time.utc(2010,10,14,3,0,0)\n\nThe #shift method can also take a hash.\n\n  t.shift(:days=>4, :hours=>3)  #=>  Time.utc(2010,10,14,3,0,0)","format":"rdoc","aliases":["Time#in","Time#hence"],"singleton":null,"interfaces":[{"signature":"shift(*time_units)","arguments":[{"name":"*time_units"}]}],"returns":[],"file":"/lib/core/facets/time/shift.rb","line":null,"source":"def shift(*time_units)\n  time_hash = Hash===time_units.last ? time_units.pop : {}\n  time_units = time_units.flatten\n  time_units << :seconds if time_units.size % 2 == 1\n  time_hash.each{ |units, number| time_units << number; time_units << units }\n\n  time = self\n  time_units.each_slice(2) do |number, units|\n    #next time = time.ago(-number, units) if number < 0\n    time = (\n      case units.to_s.downcase.to_sym\n      when :years, :year\n        time.set( :year=>(year + number) )\n      when :months, :month\n        if number > 0\n          new_month = ((month + number - 1) % 12) + 1\n          y = (number / 12) + (new_month < month ? 1 : 0)\n          time.set(:year => (year + y), :month => new_month)\n        else\n          number = -number\n          new_month = ((month - number - 1) % 12) + 1\n          y = (number / 12) + (new_month > month ? 1 : 0)\n          time.set(:year => (year - y), :month => new_month)\n        end\n      when :weeks, :week\n        time + (number * 604800)\n      when :days, :day\n        time + (number * 86400)\n      when :hours, :hour\n        time + (number * 3600)\n      when :minutes, :minute, :mins, :min\n        time + (number * 60)\n      when :seconds, :second, :secs, :sec, nil\n        time + number\n      else\n        raise ArgumentError, \"unrecognized time units -- #{units}\"\n      end\n    )\n  end\n  dst_adjustment(time)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#in":{"!":"method","declarations":["instance","public"],"path":"Time#in","name":"in","namespace":"Time","comment":"Returns a new Time representing the time shifted by the time-units given.\nPositive number shift the time forward, negative number shift the time \nbackward.\n\n  t = Time.utc(2010,10,10,0,0,0)\n  t.shift( 4, :days)            #=>  Time.utc(2010,10,14,0,0,0)\n  t.shift(-4, :days)            #=>  Time.utc(2010,10,6,0,0,0)\n\nMore than one unit of time can be given.\n\n  t.shift(4, :days, 3, :hours)  #=>  Time.utc(2010,10,14,3,0,0)\n\nThe #shift method can also take a hash.\n\n  t.shift(:days=>4, :hours=>3)  #=>  Time.utc(2010,10,14,3,0,0)\n\nAlias for #shift.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shift(*time_units)","arguments":[]}],"returns":[],"file":"/lib/core/facets/time/shift.rb","line":null,"source":"def shift(*time_units)\n  time_hash = Hash===time_units.last ? time_units.pop : {}\n  time_units = time_units.flatten\n  time_units << :seconds if time_units.size % 2 == 1\n  time_hash.each{ |units, number| time_units << number; time_units << units }\n\n  time = self\n  time_units.each_slice(2) do |number, units|\n    #next time = time.ago(-number, units) if number < 0\n    time = (\n      case units.to_s.downcase.to_sym\n      when :years, :year\n        time.set( :year=>(year + number) )\n      when :months, :month\n        if number > 0\n          new_month = ((month + number - 1) % 12) + 1\n          y = (number / 12) + (new_month < month ? 1 : 0)\n          time.set(:year => (year + y), :month => new_month)\n        else\n          number = -number\n          new_month = ((month - number - 1) % 12) + 1\n          y = (number / 12) + (new_month > month ? 1 : 0)\n          time.set(:year => (year - y), :month => new_month)\n        end\n      when :weeks, :week\n        time + (number * 604800)\n      when :days, :day\n        time + (number * 86400)\n      when :hours, :hour\n        time + (number * 3600)\n      when :minutes, :minute, :mins, :min\n        time + (number * 60)\n      when :seconds, :second, :secs, :sec, nil\n        time + number\n      else\n        raise ArgumentError, \"unrecognized time units -- #{units}\"\n      end\n    )\n  end\n  dst_adjustment(time)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#hence":{"!":"method","declarations":["instance","public"],"path":"Time#hence","name":"hence","namespace":"Time","comment":"Returns a new Time representing the time shifted by the time-units given.\nPositive number shift the time forward, negative number shift the time \nbackward.\n\n  t = Time.utc(2010,10,10,0,0,0)\n  t.shift( 4, :days)            #=>  Time.utc(2010,10,14,0,0,0)\n  t.shift(-4, :days)            #=>  Time.utc(2010,10,6,0,0,0)\n\nMore than one unit of time can be given.\n\n  t.shift(4, :days, 3, :hours)  #=>  Time.utc(2010,10,14,3,0,0)\n\nThe #shift method can also take a hash.\n\n  t.shift(:days=>4, :hours=>3)  #=>  Time.utc(2010,10,14,3,0,0)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shift(*time_units)","arguments":[]}],"returns":[],"file":"/lib/core/facets/time/shift.rb","line":null,"source":"def shift(*time_units)\n  time_hash = Hash===time_units.last ? time_units.pop : {}\n  time_units = time_units.flatten\n  time_units << :seconds if time_units.size % 2 == 1\n  time_hash.each{ |units, number| time_units << number; time_units << units }\n\n  time = self\n  time_units.each_slice(2) do |number, units|\n    #next time = time.ago(-number, units) if number < 0\n    time = (\n      case units.to_s.downcase.to_sym\n      when :years, :year\n        time.set( :year=>(year + number) )\n      when :months, :month\n        if number > 0\n          new_month = ((month + number - 1) % 12) + 1\n          y = (number / 12) + (new_month < month ? 1 : 0)\n          time.set(:year => (year + y), :month => new_month)\n        else\n          number = -number\n          new_month = ((month - number - 1) % 12) + 1\n          y = (number / 12) + (new_month > month ? 1 : 0)\n          time.set(:year => (year - y), :month => new_month)\n        end\n      when :weeks, :week\n        time + (number * 604800)\n      when :days, :day\n        time + (number * 86400)\n      when :hours, :hour\n        time + (number * 3600)\n      when :minutes, :minute, :mins, :min\n        time + (number * 60)\n      when :seconds, :second, :secs, :sec, nil\n        time + number\n      else\n        raise ArgumentError, \"unrecognized time units -- #{units}\"\n      end\n    )\n  end\n  dst_adjustment(time)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#less":{"!":"method","declarations":["instance","public"],"path":"Time#less","name":"less","namespace":"Time","comment":"Returns a new Time representing the time a number of time-units ago.\nThis is just like #shift, but reverses the direction.\n\n  t = Time.utc(2010,10,10,0,0,0)\n\n  t.less(4, :days)             #=>  Time.utc(2010,10,6,0,0,0)","format":"rdoc","aliases":["Time#ago"],"singleton":null,"interfaces":[{"signature":"less(*time_units)","arguments":[{"name":"*time_units"}]}],"returns":[],"file":"/lib/core/facets/time/shift.rb","line":null,"source":"def less(*time_units)\n  time_hash  = Hash===time_units.last ? time_units.pop : {}\n  time_units = time_units.flatten\n\n  time_units << :seconds if time_units.size % 2 == 1\n\n  time_hash.each{ |units, number| time_units << number; time_units << units }\n\n  neg_times = []\n  time_units.each_slice(2){ |number, units| neg_times << -number; neg_times << units }\n\n  shift(*neg_times)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#ago":{"!":"method","declarations":["instance","public"],"path":"Time#ago","name":"ago","namespace":"Time","comment":"Returns a new Time representing the time a number of time-units ago.\nThis is just like #shift, but reverses the direction.\n\n  t = Time.utc(2010,10,10,0,0,0)\n\n  t.less(4, :days)             #=>  Time.utc(2010,10,6,0,0,0)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"less(*time_units)","arguments":[]}],"returns":[],"file":"/lib/core/facets/time/shift.rb","line":null,"source":"def less(*time_units)\n  time_hash  = Hash===time_units.last ? time_units.pop : {}\n  time_units = time_units.flatten\n\n  time_units << :seconds if time_units.size % 2 == 1\n\n  time_hash.each{ |units, number| time_units << number; time_units << units }\n\n  neg_times = []\n  time_units.each_slice(2){ |number, units| neg_times << -number; neg_times << units }\n\n  shift(*neg_times)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#mode":{"!":"method","declarations":["instance","public"],"path":"Array#mode","name":"mode","namespace":"Array","comment":"In Statistics mode is the value that occurs most frequently\nin a given set of data. This method returns an array in case\ntheir is a tie.\n\n  [:a, :b, :c, :b, :d].mode  #=> [:b]\n  [:a, :b, :c, :b, :a].mode  #=> [:a, :b]\n\nReturns an Array of most common elements.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mode()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/mode.rb","line":null,"source":"def mode\n  max = 0\n  c = Hash.new 0\n  each {|x| cc = c[x] += 1; max = cc if cc > max}\n  c.select {|k,v| v == max}.map {|k,v| k}\nend","language":"ruby","dynamic":null,"tags":{"author":"Robert Klemme"}},"Module#let":{"!":"method","declarations":["instance","public"],"path":"Module#let","name":"let","namespace":"Module","comment":"Create a memoized method. This method has been popularized by RSpec.\n\n  class LetExample\n    let(:seed) { rand }\n  end\n\n  eg = LetExample.new\n  eg.seed == eg.seed\n\nCREDIT: Howard Yeh","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"let(var,&block)","arguments":[{"name":"var"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/module/let.rb","line":null,"source":"def let(var,&block)\n  name = \"@#{var}\"\n  self.class_eval do\n    define_method(var) do\n      if instance_variable_defined?(name)\n        instance_variable_get(name)\n      else\n        val = self.instance_eval(&block)\n        instance_variable_set(name,val)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/let'"}},"File.write":{"!":"method","declarations":["class","public"],"path":"File.write","name":"write","namespace":"File","comment":"Writes the given data to the given path and closes the file.  This is\ndone in binary mode, complementing <tt>IO.read</tt> in standard Ruby.\n\n  str = 'The content for the file'\n  File.write('write.txt', str)\n\nReturns the number of bytes written.\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"write(.)","arguments":[{"name":"path"},{"name":"data"}]}],"returns":[],"file":"/lib/core/facets/file/write.rb","line":null,"source":"def self.write(path, data)\n  File.open(path, \"wb\") do |file|\n    return file.write(data)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#graph!":{"!":"method","declarations":["instance","public"],"path":"Hash#graph!","name":"graph!","namespace":"Hash","comment":"In place version of #graph.\n\nNOTE: Hash#graph! is only useful for Hash.\nIt is not generally applicable to Enumerable.","format":"rdoc","aliases":["Hash#mash!"],"singleton":null,"interfaces":[{"signature":"graph!(&yld)","arguments":[],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/hash/graph.rb","line":null,"source":"def graph!(&yld)\n  replace(graph(&yld))\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#mash!":{"!":"method","declarations":["instance","public"],"path":"Hash#mash!","name":"mash!","namespace":"Hash","comment":"In place version of #graph.\n\nNOTE: Hash#graph! is only useful for Hash.\nIt is not generally applicable to Enumerable.\nAlias for #graph! as an alliteration for \"map hash\".","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"graph!(&yld)","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/graph.rb","line":null,"source":"def graph!(&yld)\n  replace(graph(&yld))\nend","language":"ruby","dynamic":null,"tags":{}},"Dir":{"!":"class","superclass":"Object","path":"Dir","name":"Dir","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Dir.ascend","Dir.descend","Dir.parent?","Dir.recurse","Dir.ls_r","Dir.multiglob","Dir.multiglob_r","Dir#each_child"],"accessors":[],"files":["/lib/core/facets/dir/ascend.rb","/lib/core/facets/dir/parent.rb","/lib/core/facets/dir/recurse.rb","/lib/core/facets/dir/multiglob.rb","/lib/core/facets/dir/each_child.rb"],"tags":{}},"Dir.ascend":{"!":"method","declarations":["class","public"],"path":"Dir.ascend","name":"ascend","namespace":"Dir","comment":"Ascend a directory path.\n\n  a = []\n\n  Dir.ascend(\"/var/log\") do |path|\n    a << path\n  end\n\n  a  #=> ['/var/log', '/var', '/']\n\nCREDIT: Daniel Berger, Jeffrey Schwab\n\nTODO: make it work with windows too\nuse FileTest.root?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ascend(.)","arguments":[{"name":"dir"},{"name":"inclusive","default":"true"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/dir/ascend.rb","line":null,"source":"def self.ascend(dir, inclusive=true, &blk)\n  dir = dir.dup\n  blk.call(dir) if inclusive\n  ri = dir.rindex('/')\n  while ri\n    dir = dir.slice(0...ri)\n    if dir == \"\"\n      blk.call('/') ; break\n    end\n    blk.call( dir )\n    ri = dir.rindex('/')\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Dir.descend":{"!":"method","declarations":["class","public"],"path":"Dir.descend","name":"descend","namespace":"Dir","comment":"Descend a directory path.\n\n  d = []\n\n  Dir.descend(\"/var/log\") do |path|\n    d << path\n  end\n\n  d  #=> ['/', '/var', '/var/log']\n\nCREDIT: Daniel Berger, Jeffrey Schwab","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"descend(.)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/dir/ascend.rb","line":null,"source":"def self.descend(path) #:yield:\n  paths = path.split('/')\n  paths.size.times do |n|\n    pth = File.join(*paths[0..n])\n    pth = \"/\" if pth == \"\"\n    yield(pth)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#^":{"!":"method","declarations":["instance","public"],"path":"String#^","name":"^","namespace":"String","comment":"Binary XOR of two strings. \n\n  a = \"\\000\\000\\001\\001\" ^ \"\\000\\001\\000\\001\"\n  b = \"\\003\\003\\003\" ^ \"\\000\\001\\002\"\n\n  a  #=> \"\\000\\001\\001\\000\"\n  b  #=> \"\\003\\002\\001\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"^(aString)","arguments":[{"name":"aString"}]}],"returns":[],"file":"/lib/core/facets/string/xor.rb","line":null,"source":"def ^(aString)\n  a = self.unpack('C'*(self.length))\n  b = aString.unpack('C'*(aString.length))\n  if (b.length < a.length)\n    (a.length - b.length).times { b << 0 }\n  end\n  xor = \"\"\n  0.upto(a.length-1) { |pos|\n    x = a[pos] ^ b[pos]\n    xor << x.chr()\n  }\n  return(xor)\nend","language":"ruby","dynamic":null,"tags":{}},"Range":{"!":"class","superclass":"Object","path":"Range","name":"Range","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Range#to_r","Range#to_range","Range#within?","Range#umbrella","Range#overlap?","Range#combine","Range.combine","Range#quantile"],"accessors":[],"files":["/lib/core/facets/range/to_r.rb","/lib/core/facets/range/within.rb","/lib/core/facets/range/overlap.rb","/lib/core/facets/range/combine.rb","/lib/core/facets/range/quantile.rb"],"tags":{}},"Range#to_r":{"!":"method","declarations":["instance","public"],"path":"Range#to_r","name":"to_r","namespace":"Range","comment":"A thing really should know itself.\nThis simply returns _self_.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_r()","arguments":[]}],"returns":[],"file":"/lib/core/facets/range/to_r.rb","line":null,"source":"def to_r\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Range#to_range":{"!":"method","declarations":["instance","public"],"path":"Range#to_range","name":"to_range","namespace":"Range","comment":"A thing really should know itself.\nThis simply returns _self_.\n\nNote: This does not internally effect the Ruby\ninterpretor such that it can coerce Range-like\nobjects into a Range.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_range()","arguments":[]}],"returns":[],"file":"/lib/core/facets/range/to_r.rb","line":null,"source":"def to_range\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#alias!":{"!":"method","declarations":["instance","public"],"path":"Hash#alias!","name":"alias!","namespace":"Hash","comment":"Modifies the receiving Hash so that the value previously referred to by\n_oldkey_ is also referenced by _newkey_; _oldkey_ is retained in the Hash.\nIf _oldkey_ does not exist as a key in the Hash, no change is effected.\n\nReturns a reference to the Hash.\n\n  foo = { :name=>'Gavin', 'wife'=>:Lisa }\n  foo.alias!('name',:name)     #=> { :name=>'Gavin', 'name'=>'Gavin', 'wife'=>:Lisa }\n\n  foo = { :name=>'Gavin', 'wife'=>:Lisa }\n  foo.alias!('spouse','wife')  #=> { :name=>'Gavin', 'wife'=>:Lisa, 'spouse'=>:Lisa }\n\n  foo = { :name=>'Gavin', 'wife'=>:Lisa }\n  foo.alias!('bar','foo')      #=> { :name=>'Gavin', 'wife'=>:Lisa }\n\nNote that if the _oldkey_ is reassigned, the reference will no longer exist,\nand the _newkey_ will remain as it was.\n\nCREDIT: Gavin Sinclair\n\nTODO: Rename to #aliaskey or something else.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias!(newkey, oldkey)","arguments":[{"name":"newkey"},{"name":"oldkey"}]}],"returns":[],"file":"/lib/core/facets/hash/alias.rb","line":null,"source":"def alias!(newkey, oldkey)\n  self[newkey] = self[oldkey] if self.has_key?(oldkey)\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol":{"!":"class","superclass":"Object","path":"Symbol","name":"Symbol","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Symbol#not?","Symbol#~@","Symbol#dup!","Symbol#dup?","Symbol#clone?","Symbol#succ","Symbol#as_s","Symbol#plain?","Symbol#reader?","Symbol#setter?","Symbol#writer?","Symbol#query?","Symbol#bang?","Symbol#chomp","Symbol#lchomp","Symbol#/","Symbol#thrown?","Symbol#to_proc","Symbol.generate","Symbol#variablize"],"accessors":[],"files":["/lib/core/facets/symbol/not.rb","/lib/core/facets/object/dup.rb","/lib/core/facets/symbol/succ.rb","/lib/core/facets/symbol/as_s.rb","/lib/core/facets/symbol/plain.rb","/lib/core/facets/symbol/chomp.rb","/lib/core/facets/symbol/op_div.rb","/lib/core/facets/symbol/thrown.rb","/lib/core/facets/symbol/to_proc.rb","/lib/core/facets/symbol/generate.rb","/lib/core/facets/symbol/variablize.rb"],"tags":{}},"Symbol#not?":{"!":"method","declarations":["instance","public"],"path":"Symbol#not?","name":"not?","namespace":"Symbol","comment":"Does a symbol have a \"not\" sign?\n\n  \"friend\".to_sym.not?   #=> false\n  \"~friend\".to_sym.not?  #=> true\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"not?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/symbol/not.rb","line":null,"source":"def not?\n  self.to_s.slice(0,1) == '~'\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#~@":{"!":"method","declarations":["instance","public"],"path":"Symbol#~@","name":"~@","namespace":"Symbol","comment":"Add a \"not\" sign to the front of a symbol.\n\n  (~:friend)  #=> :\"~friend\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"~@()","arguments":[]}],"returns":[],"file":"/lib/core/facets/symbol/not.rb","line":null,"source":"def ~@\n  if self.to_s.slice(0,1) == '~'\n    \"#{self.to_s[1..-1]}\".to_sym\n  else\n    \"~#{self}\".to_sym\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Dir.parent?":{"!":"method","declarations":["class","public"],"path":"Dir.parent?","name":"parent?","namespace":"Dir","comment":"Is a path parental to another?\n\n  Dir.parent?('parent', 'parent/child')  #=> true\n\nTODO: Needs improvement.\n\nTODO: Instance version?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"parent?(.)","arguments":[{"name":"parent_path"},{"name":"child_path"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/dir/parent.rb","line":null,"source":"def self.parent?(parent_path, child_path)\n  %r|^#{Regexp.escape(parent_path)}| =~ child_path ? true : false\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#old_initialize":{"!":"method","declarations":["instance","private"],"path":"Enumerator#old_initialize","name":"old_initialize","namespace":"Enumerator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"old_initialize","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerator.rb","line":null,"source":"alias :old_initialize :initialize","language":"ruby","dynamic":null,"tags":{}},"Enumerator#initialize":{"!":"method","declarations":["instance","private"],"path":"Enumerator#initialize","name":"initialize","namespace":"Enumerator","comment":"Provides the ruby-1.9 block form of Enumerator, where you can write:\n\n   obj = Enumerator.new do |yielder|\n     # ...\n     yielder.yield(data)  # or: yielder << data\n     # ...\n   end\n\nWhen obj.each is called, the block is run once. It should call\nyielder.yield with each item it wishes to generate.\n\nExample:\n\n  fib = Enumerator.new { |y|\n    a = b = 1\n    loop {   \n      y << a\n      a, b = b, a + b\n    }\n  }  \n\n  fib.take(10)  #=> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[{"type":"Enumerator","comment":"a new instance of Enumerator"}],"file":"/lib/core/facets/enumerator.rb","line":null,"source":"def initialize(*args, &block)\n  if block\n    @body = block\n    old_initialize(self, :_start)\n  else\n    old_initialize(*args)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#_start":{"!":"method","declarations":["instance","private"],"path":"Enumerator#_start","name":"_start","namespace":"Enumerator","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_start(*args,&receiver)","arguments":[{"name":"*args"}],"block":{"name":"&receiver"}}],"returns":[],"file":"/lib/core/facets/enumerator.rb","line":null,"source":"def _start(*args,&receiver) #:nodoc:\n  @body.call(Yielder.new(&receiver), *args)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator::Yielder":{"!":"class","superclass":"Object","path":"Enumerator::Yielder","name":"Yielder","namespace":"Enumerator","comment":"Wrapper to allow yielder.yield(output) or yielder << output\nin the same way as ruby-1.9\n\nTODO: Why can't Yielder take a block instead of a proc argument?","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Enumerator::Yielder#initialize","Enumerator::Yielder#yield","Enumerator::Yielder#<<"],"accessors":[],"files":["/lib/core/facets/enumerator.rb"],"tags":{}},"Enumerator::Yielder#initialize":{"!":"method","declarations":["instance","public"],"path":"Enumerator::Yielder#initialize","name":"initialize","namespace":"Enumerator::Yielder","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(&proc)","arguments":[],"block":{"name":"&proc"}}],"returns":[{"type":"Yielder","comment":"a new instance of Yielder"}],"file":"/lib/core/facets/enumerator.rb","line":null,"source":"def initialize(&proc)\n  @proc = proc\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator::Yielder#yield":{"!":"method","declarations":["instance","public"],"path":"Enumerator::Yielder#yield","name":"yield","namespace":"Enumerator::Yielder","comment":"","format":"rdoc","aliases":["Enumerator::Yielder#<<"],"singleton":null,"interfaces":[{"signature":"yield(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/enumerator.rb","line":null,"source":"def yield(*args)\n  @proc[*args]\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator::Yielder#<<":{"!":"method","declarations":["instance","public"],"path":"Enumerator::Yielder#<<","name":"<<","namespace":"Enumerator::Yielder","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"yield(*args)","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerator.rb","line":null,"source":"def yield(*args)\n  @proc[*args]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#only":{"!":"method","declarations":["instance","public"],"path":"Array#only","name":"only","namespace":"Array","comment":"Returns the _only_ element in the array.  Raises an IndexError if\nthe array's size is not 1.\n\n  [5].only      # => 5\n\n  expect IndexError do\n    [1,2,3].only\n  end\n\n  expect IndexError do\n    [].only\n  end\n\nCREDIT: Gavin Sinclair, Noah Gibbs","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"only()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/only.rb","line":null,"source":"def only\n  unless size == 1\n    raise IndexError, \"Array#only called on non-single-element array\"\n  end\n  first\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#slice":{"!":"method","declarations":["instance","public"],"path":"Hash#slice","name":"slice","namespace":"Hash","comment":"Returns a new hash with only the given keys.\n\n  h = {:a=>1, :b=>2}\n  h.slice(:a)  #=> {:a=>1}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"slice(*keep_keys)","arguments":[{"name":"*keep_keys"}]}],"returns":[],"file":"/lib/core/facets/hash/slice.rb","line":null,"source":"def slice(*keep_keys)\n  hash = {}\n  keep_keys.each do |key|\n    hash[key] = fetch(key)\n  end\n  hash\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#slice!":{"!":"method","declarations":["instance","public"],"path":"Hash#slice!","name":"slice!","namespace":"Hash","comment":"Replaces hash with a new hash having only the given keys.\nThis return the hash of keys removed.\n\n  h = {:a=>1, :b=>2}\n  h.slice!(:a)  #=> {:b=>2}\n  h             #=> {:a=>1}\n\nReturns a Hash of the removed pairs.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"slice!(*keep_keys)","arguments":[{"name":"*keep_keys"}]}],"returns":[],"file":"/lib/core/facets/hash/slice.rb","line":null,"source":"def slice!(*keep_keys)\n  rejected = keys - keep_keys\n  removed = {}\n  rejected.each{ |k| removed[k] = delete(k) }\n  removed\nend","language":"ruby","dynamic":null,"tags":{}},"Module#can":{"!":"method","declarations":["instance","public"],"path":"Module#can","name":"can","namespace":"Module","comment":"An alias for #extend.\n\n  module EgCan\n    def foo; \"foo\"; end\n  end\n\n  class EgCanClass\n    can EgCan\n  end\n\n  EgCanClass.foo  #=> 'foo'\n\nBTW, why is Forwardable an -able? It's not a mixin!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"can","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/can.rb","line":null,"source":"alias_method :can, :extend","language":"ruby","dynamic":null,"tags":{}},"Time#trunc":{"!":"method","declarations":["instance","public"],"path":"Time#trunc","name":"trunc","namespace":"Time","comment":"Truncate time at give range (in seconds).\n\n  t = Time.now\n  t = t.trunc(60*60)\n  t.min #=> 0\n  t.sec #=> 0","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"trunc(amount)","arguments":[{"name":"amount"}]}],"returns":[],"file":"/lib/core/facets/time/trunc.rb","line":null,"source":"def trunc(amount)\n  self - (self.to_i % amount)\nend","language":"ruby","dynamic":null,"tags":{}},"Object":{"!":"class","superclass":"BasicObject","path":"Object","name":"Object","namespace":"","comment":"module Kernel","format":"rdoc","constants":[],"includes":["Object::InstanceExecMethods"],"extensions":[],"modules":["Object::InstanceExecMethods"],"classes":[],"methods":["Object#dup!","Object#try_dup","Object#dup?","Object#clone?","Object#replace","Object#object_state","Object#instance_exec"],"accessors":[],"files":["/lib/core/facets/kernel/instance_exec.rb","/lib/core/facets/object/dup.rb","/lib/core/facets/object/replace.rb","/lib/core/facets/object/object_state.rb"],"tags":{}},"Object#dup!":{"!":"method","declarations":["instance","public"],"path":"Object#dup!","name":"dup!","namespace":"Object","comment":"Override this in a child class if it cannot be dup'ed.\n\n  obj1 = Object.new\n  obj2 = obj1.dup!\n  obj2.equal?(obj1)    #=> false\n\nCREDIT: Dan Kubb (extlib)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup!\n  dup\nend","language":"ruby","dynamic":null,"tags":{}},"Object#try_dup":{"!":"method","declarations":["instance","public"],"path":"Object#try_dup","name":"try_dup","namespace":"Object","comment":"Alternative name for #dup!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"try_dup()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def try_dup\n  dup!\nend","language":"ruby","dynamic":null,"tags":{}},"Object#dup?":{"!":"method","declarations":["instance","public"],"path":"Object#dup?","name":"dup?","namespace":"Object","comment":"Can you safely call #dup on this object?\n\nReturns +false+ for +nil+, +false+, +true+, symbols, and numbers;\n+true+ otherwise.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup?   ; true ; end","language":"ruby","dynamic":null,"tags":{}},"Object#clone?":{"!":"method","declarations":["instance","public"],"path":"Object#clone?","name":"clone?","namespace":"Object","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def clone? ; true ; end","language":"ruby","dynamic":null,"tags":{}},"NilClass#dup!":{"!":"method","declarations":["instance","public"],"path":"NilClass#dup!","name":"dup!","namespace":"NilClass","comment":"Since NilClass is immutable it cannot be duplicated.\nFor this reason #try_dup returns +self+.\n\n  nil.dup!  #=> nil","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup!   ; self  ; end","language":"ruby","dynamic":null,"tags":{}},"NilClass#dup?":{"!":"method","declarations":["instance","public"],"path":"NilClass#dup?","name":"dup?","namespace":"NilClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup?   ; false ; end","language":"ruby","dynamic":null,"tags":{}},"NilClass#clone?":{"!":"method","declarations":["instance","public"],"path":"NilClass#clone?","name":"clone?","namespace":"NilClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def clone? ; false ; end","language":"ruby","dynamic":null,"tags":{}},"FalseClass#dup!":{"!":"method","declarations":["instance","public"],"path":"FalseClass#dup!","name":"dup!","namespace":"FalseClass","comment":"Since FalseClass is immutable it cannot be duplicated.\nFor this reason #try_dup returns +self+.\n\n  false.dup!  #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup!   ; self  ; end","language":"ruby","dynamic":null,"tags":{}},"FalseClass#dup?":{"!":"method","declarations":["instance","public"],"path":"FalseClass#dup?","name":"dup?","namespace":"FalseClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup?   ; false ; end","language":"ruby","dynamic":null,"tags":{}},"FalseClass#clone?":{"!":"method","declarations":["instance","public"],"path":"FalseClass#clone?","name":"clone?","namespace":"FalseClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def clone? ; false ; end","language":"ruby","dynamic":null,"tags":{}},"TrueClass#dup!":{"!":"method","declarations":["instance","public"],"path":"TrueClass#dup!","name":"dup!","namespace":"TrueClass","comment":"Since TrueClass is immutable it cannot be duplicated.\nFor this reason #try_dup returns +self+.\n\n  true.dup!  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup!   ; self  ; end","language":"ruby","dynamic":null,"tags":{}},"TrueClass#dup?":{"!":"method","declarations":["instance","public"],"path":"TrueClass#dup?","name":"dup?","namespace":"TrueClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup?   ; false ; end","language":"ruby","dynamic":null,"tags":{}},"TrueClass#clone?":{"!":"method","declarations":["instance","public"],"path":"TrueClass#clone?","name":"clone?","namespace":"TrueClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def clone? ; false ; end","language":"ruby","dynamic":null,"tags":{}},"Symbol#dup!":{"!":"method","declarations":["instance","public"],"path":"Symbol#dup!","name":"dup!","namespace":"Symbol","comment":"Since Symbol is immutable it cannot be duplicated.\nFor this reason #try_dup returns +self+.\n\n  :a.dup!  #=> :a","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup!   ; self  ; end","language":"ruby","dynamic":null,"tags":{}},"Symbol#dup?":{"!":"method","declarations":["instance","public"],"path":"Symbol#dup?","name":"dup?","namespace":"Symbol","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup?   ; false ; end","language":"ruby","dynamic":null,"tags":{}},"Symbol#clone?":{"!":"method","declarations":["instance","public"],"path":"Symbol#clone?","name":"clone?","namespace":"Symbol","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def clone? ; false ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric#dup!":{"!":"method","declarations":["instance","public"],"path":"Numeric#dup!","name":"dup!","namespace":"Numeric","comment":"Since Numeric is immutable it cannot be duplicated.\nFor this reason #try_dup returns +self+.\n\n  1.dup!  #=> 1","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup!   ; self  ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric#dup?":{"!":"method","declarations":["instance","public"],"path":"Numeric#dup?","name":"dup?","namespace":"Numeric","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dup?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def dup?   ; false ; end","language":"ruby","dynamic":null,"tags":{}},"Numeric#clone?":{"!":"method","declarations":["instance","public"],"path":"Numeric#clone?","name":"clone?","namespace":"Numeric","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clone?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/object/dup.rb","line":null,"source":"def clone? ; false ; end","language":"ruby","dynamic":null,"tags":{}},"Hash#rekey":{"!":"method","declarations":["instance","public"],"path":"Hash#rekey","name":"rekey","namespace":"Hash","comment":"Rekey a hash:\n\n  rekey()\n  rekey(from_key => to_key, ...)\n  rekey{|from_key| to_key}\n\nIf a key map is given, then the first key is changed to the second key.\n\n  foo = { :a=>1, :b=>2 }\n  foo.rekey(:a=>'a')       #=> { 'a'=>1, :b=>2 }\n  foo.rekey(:b=>:x)        #=> { :a =>1, :x=>2 }\n  foo.rekey('foo'=>'bar')  #=> { :a =>1, :b=>2 }\n\nIf a block is given, converts all keys in the Hash accroding to the\ngiven block procedure. If the block returns +NA+ for a given key,\nthen that key will be left intact.\n\n  foo = { :name=>'Gavin', :wife=>:Lisa }\n  foo.rekey{ |k| k.to_s }  #=>  { \"name\"=>\"Gavin\", \"wife\"=>:Lisa }\n  foo                      #=>  { :name =>\"Gavin\", :wife=>:Lisa }\n\nIf no key map or block is given, then all keys are converted\nto Symbols.\n\nNote that if both a +key_map+ and a block are given, the +key_map+ is \napplied first then the block.\n\nCREDIT: Trans, Gavin Kistner","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rekey(key_map=nil, &block)","arguments":[{"name":"key_map","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/rekey.rb","line":null,"source":"def rekey(key_map=nil, &block)\n  if !(key_map or block)\n    block = lambda{|k| k.to_sym}\n  end\n\n  key_map ||= {} \n\n  hash = dup.replace({})  # to keep default_proc\n\n  (keys - key_map.keys).each do |key|\n    hash[key] = self[key]\n  end\n\n  key_map.each do |from, to|\n    hash[to] = self[from] if key?(from)\n  end\n\n  if block\n    hash2 = dup.replace({})\n    case block.arity\n    when 2  # TODO: is this condition needed?\n      hash.each do |k, v|\n        nk = block.call(k,v)\n        nk = (NA == nk ? k : nk)\n        hash2[nk] = v\n      end\n    else\n      hash.each do |k, v|\n        nk = block.call(k)\n        nk = (NA == nk ? k : nk)\n        hash2[nk] = v\n      end\n    end\n  else\n    hash2 = hash\n  end\n\n  hash2\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#rekey!":{"!":"method","declarations":["instance","public"],"path":"Hash#rekey!","name":"rekey!","namespace":"Hash","comment":"Synonym for Hash#rekey, but modifies the receiver in place (and returns it).\n\n  foo = { :name=>'Gavin', :wife=>:Lisa }\n  foo.rekey!{ |k| k.to_s }  #=>  { \"name\"=>\"Gavin\", \"wife\"=>:Lisa }\n  foo                       #=>  { \"name\"=>\"Gavin\", \"wife\"=>:Lisa }\n\nCREDIT: Trans, Gavin Kistner","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rekey!(key_map=nil, &block)","arguments":[{"name":"key_map","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/rekey.rb","line":null,"source":"def rekey!(key_map=nil, &block)\n  replace(rekey(key_map, &block))\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#yes?":{"!":"method","declarations":["instance","public"],"path":"Kernel#yes?","name":"yes?","namespace":"Kernel","comment":"Ask a question expecting a yes answer.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"yes?(question)","arguments":[{"name":"question"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/yes.rb","line":null,"source":"def yes?(question)\n  case ask(question).downcase\n  when 'y', 'yes'\n    true\n  else\n    false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#no?":{"!":"method","declarations":["instance","public"],"path":"Kernel#no?","name":"no?","namespace":"Kernel","comment":"Ask a question expecting a no answer.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"no?(question)","arguments":[{"name":"question"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/yes.rb","line":null,"source":"def no?(question)\n  case ask(question).downcase\n  when 'n', 'no'\n    true\n  else\n    false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#count":{"!":"method","declarations":["instance","public"],"path":"Hash#count","name":"count","namespace":"Hash","comment":"Like Enumerable#count, but counts hash values.\n\n  {:A=>1, :B=>1}.count(1) #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"count(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/core/facets/hash/count.rb","line":null,"source":"def count(value)\n  values.count(value)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#pull":{"!":"method","declarations":["instance","public"],"path":"Array#pull","name":"pull","namespace":"Array","comment":"Alias for shift which removes an object off first slot of an array.\nThis is the opposite of pop.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pull","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/pull.rb","line":null,"source":"alias_method :pull, :shift","language":"ruby","dynamic":null,"tags":{}},"Array#peek":{"!":"method","declarations":["instance","public"],"path":"Array#peek","name":"peek","namespace":"Array","comment":"Peek at the top of the stack (the end of the array).\n\n  a = [1, 2, 3]\n  a.peek          #=> 3\n  a               #=> [1, 2, 3]\n\nOr provide an index to inspect the array from back to front.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"peek(i=0)","arguments":[{"name":"i","default":"0"}]}],"returns":[],"file":"/lib/core/facets/array/pull.rb","line":null,"source":"def peek(i=0)\n  i = -(i + 1)\n  fetch(i)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#poke":{"!":"method","declarations":["instance","public"],"path":"Array#poke","name":"poke","namespace":"Array","comment":"Put an object on the bottom of the stack (front of the array).\n\n  a = [2, 3]\n  a.poke(1)\n  a               #=> [1, 2, 3]\n\nOr supply an index and #poke works like #insert.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"poke(x, i=0)","arguments":[{"name":"x"},{"name":"i","default":"0"}]}],"returns":[],"file":"/lib/core/facets/array/pull.rb","line":null,"source":"def poke(x, i=0)\n  insert(i,x)\nend","language":"ruby","dynamic":null,"tags":{}},"File.create":{"!":"method","declarations":["class","public"],"path":"File.create","name":"create","namespace":"File","comment":"Creates a new file, or overwrites an existing file,\nand writes a string into it. Can also take a block\njust like File#open, which is yielded _after_ the\nstring is writ.\n\n  str = 'The content for the file'\n  File.create('myfile.txt', str)\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"create(.)","arguments":[{"name":"path"},{"name":"str","default":"''"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/file/create.rb","line":null,"source":"def self.create(path, str='', &blk)\n  open(path, 'wb') do |f|\n    f << str\n    blk.call(f) if blk\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"File.append":{"!":"method","declarations":["class","public"],"path":"File.append","name":"append","namespace":"File","comment":"Append to a file.\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"append(.)","arguments":[{"name":"file"},{"name":"str"}]}],"returns":[],"file":"/lib/core/facets/file/append.rb","line":null,"source":"def self.append(file, str)\n  File.open(file, 'ab') { |f|\n    f << str\n  }\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable":{"!":"module","path":"Denumerable","name":"Denumerable","namespace":"","comment":"Classes which include Denumerable will get versions of map,\nselect, and so on, which return a Denumerator, so that they\nwork horizontally without creating intermediate arrays.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Denumerable#map","Denumerable#collect","Denumerable#select","Denumerable#find_all","Denumerable#reject","Denumerable#take","Denumerable#skip"],"accessors":[],"files":["/lib/core/facets/denumerable.rb"],"tags":{"author":"Trans"}},"Denumerable#map":{"!":"method","declarations":["instance","public"],"path":"Denumerable#map","name":"map","namespace":"Denumerable","comment":"","format":"rdoc","aliases":["Denumerable#collect"],"singleton":null,"interfaces":[{"signature":"map()","arguments":[]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def map\n  Denumerator.new do |output|\n    each do |*input|\n      output.yield yield(*input)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable#collect":{"!":"method","declarations":["instance","public"],"path":"Denumerable#collect","name":"collect","namespace":"Denumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"map()","arguments":[]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def map\n  Denumerator.new do |output|\n    each do |*input|\n      output.yield yield(*input)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable#select":{"!":"method","declarations":["instance","public"],"path":"Denumerable#select","name":"select","namespace":"Denumerable","comment":"","format":"rdoc","aliases":["Denumerable#find_all"],"singleton":null,"interfaces":[{"signature":"select()","arguments":[]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def select\n  Denumerator.new do |output|\n    each do |*input|\n      output.yield(*input) if yield(*input)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable#find_all":{"!":"method","declarations":["instance","public"],"path":"Denumerable#find_all","name":"find_all","namespace":"Denumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"select()","arguments":[]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def select\n  Denumerator.new do |output|\n    each do |*input|\n      output.yield(*input) if yield(*input)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable#reject":{"!":"method","declarations":["instance","public"],"path":"Denumerable#reject","name":"reject","namespace":"Denumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reject()","arguments":[]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def reject\n  Denumerator.new do |output|\n    each do |*input|\n      output.yield(*input) unless yield(*input)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable#take":{"!":"method","declarations":["instance","public"],"path":"Denumerable#take","name":"take","namespace":"Denumerable","comment":"Limit to the first n items in the list","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"take(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def take(n)\n  Denumerator.new do |output|\n    count = 0\n    each do |*input|\n      break if count >= n\n      output.yield(*input)\n      count += 1\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerable#skip":{"!":"method","declarations":["instance","public"],"path":"Denumerable#skip","name":"skip","namespace":"Denumerable","comment":"Skip the first n items in the list","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"skip(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/denumerable.rb","line":null,"source":"def skip(n)\n  Denumerator.new do |output|\n    count = 0\n    each do |*input|\n      output.yield(*input) if count >= n\n      count += 1\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Denumerator":{"!":"class","superclass":"Enumerator","path":"Denumerator","name":"Denumerator","namespace":"","comment":"= Denumerator\n\nA class like Enumerator, but which has 'lazy' versions of map, select etc.","format":"rdoc","constants":[],"includes":["Denumerable"],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/core/facets/denumerable.rb"],"tags":{}},"Kernel#memo":{"!":"method","declarations":["instance","public"],"path":"Kernel#memo","name":"memo","namespace":"Kernel","comment":"Memoize a method.\n\n  class MemoExample\n    attr_accessor :a\n    def m\n      memo{ @a }\n    end\n  end\n\n  ex = MemoExample.new\n\n  ex.a = 10\n  ex.m  #=> 10\n\n  ex.a = 20\n  ex.m  #=> 10\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"memo(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/memo.rb","line":null,"source":"def memo(*args, &block)\n  if args.empty?\n    args = block.binding.eval('[self, __method__]')\n  end\n  if $MEMO.key?(args)\n    $MEMO[args]\n  else\n    $MEMO[args] = block.call\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/kernel/memo'"}},"Array#split":{"!":"method","declarations":["instance","public"],"path":"Array#split","name":"split","namespace":"Array","comment":"Split on matching pattern. Unlike #divide this does not include matching elements.\n\n  ['a1','a2','b1','a3','b2','a4'].split(/^b/)\n  #=> [['a1','a2'],['a3'],['a4']]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"split(pattern)","arguments":[{"name":"pattern"}]}],"returns":[],"file":"/lib/core/facets/array/split.rb","line":null,"source":"def split(pattern)\n  memo = []\n  sect = []\n  each do |obj|\n    if pattern === obj\n      memo << sect\n      sect = []\n    else\n      sect << obj\n    end\n  end\n  memo << sect\n  memo.pop while memo.last == []\n  memo\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#succ":{"!":"method","declarations":["instance","public"],"path":"Symbol#succ","name":"succ","namespace":"Symbol","comment":"Successor method for symobol. This simply converts\nthe symbol to a string uses String#succ and then\nconverts it back to a symbol.\n\n  :a.succ  #=> :b\n\nTODO: Make this work more like a simple character dial?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"succ(n=1)","arguments":[{"name":"n","default":"1"}]}],"returns":[],"file":"/lib/core/facets/symbol/succ.rb","line":null,"source":"def succ(n=1)\n  s = self.to_s\n  n.times do\n    s = s.succ\n  end\n  s.to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#+":{"!":"method","declarations":["instance","public"],"path":"Hash#+","name":"+","namespace":"Hash","comment":"Operator for #merge.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"+(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/op_add.rb","line":null,"source":"def +(other)\n  merge(other)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#past?":{"!":"method","declarations":["instance","public"],"path":"Time#past?","name":"past?","namespace":"Time","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"past?(other=nil)","arguments":[{"name":"other","default":"nil"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/time/future.rb","line":null,"source":"def past?(other=nil)\n  self < (other || ::Time.now)\nend","language":"ruby","dynamic":null,"tags":{}},"Time#future?":{"!":"method","declarations":["instance","public"],"path":"Time#future?","name":"future?","namespace":"Time","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"future?(other=nil)","arguments":[{"name":"other","default":"nil"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/time/future.rb","line":null,"source":"def future?(other=nil)\n  self > (other || ::Time.now)\nend","language":"ruby","dynamic":null,"tags":{}},"String#file":{"!":"method","declarations":["instance","public"],"path":"String#file","name":"file","namespace":"String","comment":"Use fluent notation for making file directives.\n\nFor instance, if we had a file 'foo.txt',\n\n   'foo.txt'.file.mtime","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"file()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/file.rb","line":null,"source":"def file\n  Functor.new(&method(:file_send).to_proc)\nend","language":"ruby","dynamic":null,"tags":{}},"String#file_send":{"!":"method","declarations":["instance","private"],"path":"String#file_send","name":"file_send","namespace":"String","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"file_send(op, *a, &b)","arguments":[{"name":"op"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/core/facets/string/file.rb","line":null,"source":"def file_send(op, *a, &b)\n  File.send(op, self, *a, &b)\nend","language":"ruby","dynamic":null,"tags":{}},"Dir.recurse":{"!":"method","declarations":["class","public"],"path":"Dir.recurse","name":"recurse","namespace":"Dir","comment":"Recursively scan a directory and pass each file to the given block.\n\n  Dir.recurse('.') do |path|\n    # ...\n  end\n\nCREDIT: George Moschovitis\n\nTODO: If fully compatible, reimplement as alias of Find.find,\nor just copy and paste Find.find code here if it looks more robust.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recurse(.)","arguments":[{"name":"path","default":"'.'"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/dir/recurse.rb","line":null,"source":"def self.recurse(path='.', &block)\n  list = []\n  stoplist = ['.', '..']\n  Dir.foreach(path) do |f|\n    next if stoplist.include?(f)\n    filename = (path == '.' ? f : path + '/' + f)\n    list << filename\n    block.call(filename) if block\n    if FileTest.directory?(filename) and not FileTest.symlink?(filename)\n      list.concat(Dir.recurse(filename, &block))\n    end\n  end\n  list\nend","language":"ruby","dynamic":null,"tags":{}},"Dir.ls_r":{"!":"method","declarations":["class","public"],"path":"Dir.ls_r","name":"ls_r","namespace":"Dir","comment":"Same as Dir#recurse.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ls_r(.)","arguments":[{"name":"path","default":"'.'"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/dir/recurse.rb","line":null,"source":"def self.ls_r(path='.', &block)\n  recurse(path, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#subset":{"!":"method","declarations":["instance","public"],"path":"Hash#subset","name":"subset","namespace":"Hash","comment":"Take a subset of the hash, based on keys given or a block\nthat evaluates to true for each hash key.\n\n  {'a'=>1, 'b'=>2}.subset('a')            #=> {'a'=>1}\n  {'a'=>1, 'b'=>2}.subset{|k| k == 'a' }  #=> {'a'=>1}\n\nCREDIT: Alexey Petrushin","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"subset(keys=nil, &block)","arguments":[{"name":"keys","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/subset.rb","line":null,"source":"def subset(keys=nil, &block)\n  h = {}\n  if keys\n    self.each do |k, v|\n      h[k] = v if keys.include?(k)\n    end\n  else\n    self.each do |k, v|\n      h[k] = v if block.call(k)\n    end\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Array#_facets_index":{"!":"method","declarations":["instance","public"],"path":"Array#_facets_index","name":"_facets_index","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_facets_index","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/index.rb","line":null,"source":"alias_method :_facets_index, :index","language":"ruby","dynamic":null,"tags":{}},"Array#index":{"!":"method","declarations":["instance","public"],"path":"Array#index","name":"index","namespace":"Array","comment":"Allows #index to accept a block.\n\n  ['a', 'b', 'c'].index{ |x| x.upcase == 'C' } #=> 2\n\nIMPORTANT: This is one of the few core overrides in Facets.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"index(obj=nil, &block)","arguments":[{"name":"obj","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/index.rb","line":null,"source":"def index(obj=nil, &block)\n  if block_given?\n    _facets_index(find(&block))\n  else\n    _facets_index(obj)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#here":{"!":"method","declarations":["instance","public"],"path":"Kernel#here","name":"here","namespace":"Kernel","comment":"A shorthand pronoun for binding().\n\n  a = 3\n  eval(\"a\", here)  #=> 3","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"here","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/here.rb","line":null,"source":"alias_method :here, :binding","language":"ruby","dynamic":null,"tags":{}},"Array#store":{"!":"method","declarations":["instance","public"],"path":"Array#store","name":"store","namespace":"Array","comment":"Store a value at a given index. Store is an alias for #[]=.\n\n  a = []\n  a.store(1, \"A\")\n  a[1] #=> \"A\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"store","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/store.rb","line":null,"source":"alias_method :store, :[]=","language":"ruby","dynamic":null,"tags":{}},"Hash#&":{"!":"method","declarations":["instance","public"],"path":"Hash#&","name":"&","namespace":"Hash","comment":"Hash intersection. Two hashes intersect\nwhen their pairs are equal.\n\n  ({:a=>1,:b=>2} & {:a=>1,:c=>3})  #=> {:a=>1}\n\nA hash can also be intersected with an array\nto intersect keys only.\n\n  ({:a=>1,:b=>2} & [:a,:c])  #=> {:a=>1}\n\nThe later form is similar to #pairs_at. The differ only\nin that #pairs_at will return a nil value for a key\nnot in the hash, but #& will not.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"&(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/op_and.rb","line":null,"source":"def &(other)\n  case other\n  when Array\n    k = (keys & other)\n    Hash[*(k.zip(values_at(*k)).flatten)]\n  else\n    x = (to_a & other.to_a).inject([]) do |a, kv|\n      a.concat kv; a\n    end\n    Hash[*x]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#ergo":{"!":"method","declarations":["instance","public"],"path":"Kernel#ergo","name":"ergo","namespace":"Kernel","comment":"Yield self -or- return self.\n\n  \"a\".ergo.upcase #=> \"A\"\n  nil.ergo.foobar #=> nil\n\n  \"a\".ergo{ |o| o.upcase } #=> \"A\"\n  nil.ergo{ |o| o.foobar } #=> nil\n\nThis is like #tap, but #tap yields self and returns self,\nwhere as #ergo yields self buit return the result.\n\nCREDIT: Daniel DeLorme","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ergo(&b)","arguments":[],"block":{"name":"&b"}}],"returns":[],"file":"/lib/core/facets/kernel/ergo.rb","line":null,"source":"def ergo(&b)\n  if block_given?\n    b.arity == 1 ? yield(self) : instance_eval(&b)\n  else\n    self\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass#ergo":{"!":"method","declarations":["instance","public"],"path":"NilClass#ergo","name":"ergo","namespace":"NilClass","comment":"Compliments Kernel#ergo.\n\n  \"a\".ergo{ |o| o.upcase } #=> \"A\"\n  nil.ergo{ |o| o.bar }    #=> nil\n\nCREDIT: Daniel DeLorme","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ergo()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/ergo.rb","line":null,"source":"def ergo\n  @_ergo ||= Functor.new{ nil }\n  @_ergo unless block_given?\nend","language":"ruby","dynamic":null,"tags":{}},"String#fold":{"!":"method","declarations":["instance","public"],"path":"String#fold","name":"fold","namespace":"String","comment":"Returns a new string with all new lines removed from\nadjacent lines of text.\n\n  s = \"This is\\na test.\\n\\nIt clumps\\nlines of text.\"\n  s.fold\n\n_produces_\n\n  \"This is a test.\\n\\nIt clumps lines of text. \"\n\nOne arguable flaw with this, that might need a fix:\nif the given string ends in a newline, it is replaced with\na single space.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"fold(ignore_indented=false)","arguments":[{"name":"ignore_indented","default":"false"}]}],"returns":[],"file":"/lib/core/facets/string/fold.rb","line":null,"source":"def fold(ignore_indented=false)\n  ns = ''\n  i = 0\n  br = self.scan(/(\\n\\s*\\n|\\Z)/m) do |m|\n    b = $~.begin(1)\n    e = $~.end(1)\n    nl = $&\n    tx = slice(i...b)\n    if ignore_indented and slice(i...b) =~ /^[ ]+/\n      ns << tx\n    else\n      ns << tx.gsub(/[ ]*\\n+/,' ')\n    end\n    ns << nl\n    i = e\n  end\n  ns\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#except":{"!":"method","declarations":["instance","public"],"path":"Hash#except","name":"except","namespace":"Hash","comment":"Returns a new hash less the given keys.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"except(*less_keys)","arguments":[{"name":"*less_keys"}]}],"returns":[],"file":"/lib/core/facets/hash/except.rb","line":null,"source":"def except(*less_keys)\n  hash = dup\n  less_keys.each{ |k| hash.delete(k) }\n  hash\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#except!":{"!":"method","declarations":["instance","public"],"path":"Hash#except!","name":"except!","namespace":"Hash","comment":"Replaces hash with new hash less the given keys.\nThis returns the hash of keys removed.\n\n  h = {:a=>1, :b=>2, :c=>3}\n  h.except!(:a)  #=> {:a=>1}\n  h              #=> {:b=>2,:c=>3}\n\nReturns a Hash of the removed pairs.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"except!(*rejected)","arguments":[{"name":"*rejected"}]}],"returns":[],"file":"/lib/core/facets/hash/except.rb","line":null,"source":"def except!(*rejected)\n  removed = {}\n  rejected.each{ |k| removed[k] = delete(k) }\n  removed\nend","language":"ruby","dynamic":null,"tags":{}},"Time.elapse":{"!":"method","declarations":["class","public"],"path":"Time.elapse","name":"elapse","namespace":"Time","comment":"Tracks the elapse time of a code block.\n\n  e = Time.elapse { sleep 1 }\n\n  e.assert > 1\n\nCREDIT: Hal Fulton","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"elapse(.)","arguments":[]}],"returns":[],"file":"/lib/core/facets/time/elapse.rb","line":null,"source":"def self.elapse\n  raise \"Need block\" unless block_given?\n  t0 = now.to_f\n  yield\n  now.to_f - t0\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#with":{"!":"method","declarations":["instance","public"],"path":"Kernel#with","name":"with","namespace":"Kernel","comment":"Like returning but exectues the block\nvia instance_eval.\n\n  def foo\n    with values = [] do\n      self << 'bar'\n      self << 'baz'\n    end\n  end\n\n  foo # => ['bar', 'baz']","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"with(obj=self, &block)","arguments":[{"name":"obj","default":"self"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/with.rb","line":null,"source":"def with(obj=self, &block)\n  obj.instance_eval(&block)\nend","language":"ruby","dynamic":null,"tags":{}},"Proc#update":{"!":"method","declarations":["instance","public"],"path":"Proc#update","name":"update","namespace":"Proc","comment":"Use a Proc as an observable.\n\nCREDIT: Tim Pease","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update","arguments":[]}],"returns":[],"file":"/lib/core/facets/proc/update.rb","line":null,"source":"alias_method :update, :call","language":"ruby","dynamic":null,"tags":{}},"Hash#to_mod":{"!":"method","declarations":["instance","public"],"path":"Hash#to_mod","name":"to_mod","namespace":"Hash","comment":"Convert a hash into a module.\n\n  {:a=>1, :b=>2}.to_mod\n\nCan take a block accepting key, value pairs which will be\nevaluated in the context of the module.\n\n  h = {:a=>1, :b=>2}\n  m = h.to_mod{ |k,v| module_function k }\n  m.a #=> 1\n  m.b #=> 2\n\nCREDIT: Jay Fields\n--\nTODO: Consider #to_obj?\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_mod(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/to_mod.rb","line":null,"source":"def to_mod(&block)\n  hash = self\n  Module.new do\n    hash.each do |key, value|\n      define_method key do\n        value #.to_object\n      end\n      instance_exec(key, value, &block) if block\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#odd?":{"!":"method","declarations":["instance","public"],"path":"Integer#odd?","name":"odd?","namespace":"Integer","comment":"Returns true if this integer is odd, false otherwise.\n\n  2.odd?            #=> false\n  3.odd?            #=> true\n\n  -99.odd?          # -> true\n  -98.odd?          # -> false\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"odd?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/integer/odd.rb","line":null,"source":"def odd?\n  self & 1 == 1  #self % 2 == 1\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#even?":{"!":"method","declarations":["instance","public"],"path":"Integer#even?","name":"even?","namespace":"Integer","comment":"Returns true if this integer is even, false otherwise.\n\n  2.even?  #=> true\n  3.even?  #=> false\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"even?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/integer/odd.rb","line":null,"source":"def even?\n  self & 1 == 0  #self % 2 == 0\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#*":{"!":"method","declarations":["instance","public"],"path":"Hash#*","name":"*","namespace":"Hash","comment":"Like merge operator '+' but merges in reverse order.\n\n  h1 = {:a=>1}\n  h2 = {:a=>2, :b=>3}\n\n  (h1 + h2) #=> { :a=>2, :b=>3 }\n  (h1 * h2)  #=> { :a=>1, :b=>3 }\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"*(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/op_mul.rb","line":null,"source":"def *(other)\n  other.merge(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#true?":{"!":"method","declarations":["instance","public"],"path":"Kernel#true?","name":"true?","namespace":"Kernel","comment":"Returns true is an object is class TrueClass,\notherwise false.\n\n  true.true?   #=> true\n  false.true?  #=> false\n  nil.true?    #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"true?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/true.rb","line":null,"source":"def true?\n  (true == self)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#false?":{"!":"method","declarations":["instance","public"],"path":"Kernel#false?","name":"false?","namespace":"Kernel","comment":"Returns true is an object is class FalseClass,\notherwise false.\n\n  true.false?   #=> false\n  false.false?  #=> true\n  nil.false?    #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"false?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/true.rb","line":null,"source":"def false?\n  (false == self)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#merge!":{"!":"method","declarations":["instance","public"],"path":"Array#merge!","name":"merge!","namespace":"Array","comment":"In place #merge.\n\n  a = [1,2]\n  a.merge! [2,3]\n  a #=> [1,2,3]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"merge!(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/array/merge.rb","line":null,"source":"def merge!( other )\n  self.replace(self.merge(other))\nend","language":"ruby","dynamic":null,"tags":{}},"Array#merge":{"!":"method","declarations":["instance","public"],"path":"Array#merge","name":"merge","namespace":"Array","comment":"Alias for <tt>|</tt>.\n\n  [1,2].merge([2,3])  #=> [1,2,3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"merge","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/merge.rb","line":null,"source":"alias_method :merge, :|","language":"ruby","dynamic":null,"tags":{}},"Kernel#demo":{"!":"method","declarations":["instance","public"],"path":"Kernel#demo","name":"demo","namespace":"Kernel","comment":"For debugging and showing examples. Currently this\ntakes an argument of a string in a block...\n\n  demo {%{ a = [1,2,3] }}\n  demo {%{ a.slice(1,2) }}\n  demo {%{ a.map { |x| x**3 } }}\n\nproduces ...\n\n  a = [1,2,3]             #=>  [1, 2, 3]\n  a.slice(1,2)            #=>  [2, 3]\n  a.map { |x| x**3 }      #=>  [1, 8, 27]\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"demo(out=$stdout,&block)","arguments":[{"name":"out","default":"$stdout"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/demo.rb","line":null,"source":"def demo(out=$stdout,&block)\n  out << sprintf(\"%-25s#=>  %s\\n\", expr = block.call, eval(expr, block.binding).inspect)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/kernel/demo'"}},"Hash#insert":{"!":"method","declarations":["instance","public"],"path":"Hash#insert","name":"insert","namespace":"Hash","comment":"As with #store but only if the key isn't\nalready in the hash.\n\nTODO: Would #store? be a better name?\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"insert(name, value)","arguments":[{"name":"name"},{"name":"value"}]}],"returns":[],"file":"/lib/core/facets/hash/insert.rb","line":null,"source":"def insert(name, value)\n  if key?(name)\n    false\n  else\n    store(name,value)\n    true\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#select!":{"!":"method","declarations":["instance","public"],"path":"Hash#select!","name":"select!","namespace":"Hash","comment":"In-place version of Hash#select.  The opposite of the built-in\nHash#reject!.\n\nCREDIT: Gavin Sinclair, Noah Gibbs","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"select!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/select.rb","line":null,"source":"def select!\n  reject! { |k,v| not yield(k,v) }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#case?":{"!":"method","declarations":["instance","public"],"path":"Kernel#case?","name":"case?","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"case?(*matchers)","arguments":[{"name":"*matchers"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/case.rb","line":null,"source":"def case?(*matchers)\n  matchers.all?{ |m| m === self }\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#as_s":{"!":"method","declarations":["instance","public"],"path":"Symbol#as_s","name":"as_s","namespace":"Symbol","comment":"Convert symbol to string, apply string method and convert\nback to symbol via a fluent interface.\n\n  :HELLO.as_s.downcase  #=> :hello","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"as_s()","arguments":[]}],"returns":[],"file":"/lib/core/facets/symbol/as_s.rb","line":null,"source":"def as_s\n  Functor.new do |op, *a|\n    to_s.send(op, *a).to_sym\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#home":{"!":"method","declarations":["instance","public"],"path":"Module#home","name":"home","namespace":"Module","comment":"Returns the module or class containing the receiver.\n\n  module ::HomeExample\n    module M\n      module N\n      end\n    end\n  end\n\n  HomeExample::M::N.home  #=> HomeExample::M\n\nThe home of a top-level module/class is Object.\n\n  HomeExample.home   #=> Object\n\nThis method is called *home* because techinally a module or class\nis just a constant reference, and as such can reside with multiple\nnamespaces, like any variable. For example:\n\n  module OtherPlace\n    M = ::HomeExample::M\n  end\n\nIn this example, you might think that +OtherPlace::M+'s home would be\n+OtherPlace+, but +OtherPlace::M+ is the same object as +HomeExample::M+,\nand it can have only one \"home\" --the original location of it's definition.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"home()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/home.rb","line":null,"source":"def home\n  #homename = /::[^:]+\\Z/ =~ name ? $` : nil\n  if homename\n    homename.split(/::/).inject(self) do |mod, cref|\n      if /\\:(0x.*?)\\>$/ =~ cref   # TODO: does this ever happen?\n        #p $1.to_i(16)\n        ObjectSpace._idref($1.to_i(16))\n      else\n        mod.const_get(cref)\n      end\n    end\n  else\n    Object\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#homename":{"!":"method","declarations":["instance","public"],"path":"Module#homename","name":"homename","namespace":"Module","comment":"Returns the name of module or class containing the receiver.\n\n  module ::HomeExample\n    module M\n      module N\n      end\n    end\n  end\n\n  HomeExample::M::N.homename  #=> \"HomeExample::M\"\n\nSee also Module#basename.","format":"rdoc","aliases":["Module#modname"],"singleton":null,"interfaces":[{"signature":"homename()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/home.rb","line":null,"source":"def homename\n  /::[^:]+\\Z/ =~ name ? $` : nil\nend","language":"ruby","dynamic":null,"tags":{}},"Module#modname":{"!":"method","declarations":["instance","public"],"path":"Module#modname","name":"modname","namespace":"Module","comment":"Returns the name of module or class containing the receiver.\n\n  module ::HomeExample\n    module M\n      module N\n      end\n    end\n  end\n\n  HomeExample::M::N.homename  #=> \"HomeExample::M\"\n\nSee also Module#basename.\nOriginal name for #homename.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"homename()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/home.rb","line":null,"source":"def homename\n  /::[^:]+\\Z/ =~ name ? $` : nil\nend","language":"ruby","dynamic":null,"tags":{}},"Module#housing":{"!":"method","declarations":["instance","public"],"path":"Module#housing","name":"housing","namespace":"Module","comment":"Returns all the namespaces of this module according ordered from\nnearest and moving outwards. The receiver is not contained within\nthe result.\n\n  module ::HouseExample\n    module M\n      module N\n      end\n    end\n  end\n\n  HouseExample.housing        #=> [Object]\n  HouseExample::M.housing     #=> [HouseExample, Object]\n  HouseExample::M::N.housing  #=> [HouseExample::M, HouseExample, Object]\n\nCompare this to +Module.nesting+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"housing()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/home.rb","line":null,"source":"def housing\n  n = []\n  name.split(/::/).inject(self) do |mod, cref|\n    c = mod.const_get(cref) ; n.unshift(c) ; c\n  end\n  n << Object # ?\n  n.shift # we really don't need +self+ too.\n  n\nend","language":"ruby","dynamic":null,"tags":{}},"Time#change":{"!":"method","declarations":["instance","public"],"path":"Time#change","name":"change","namespace":"Time","comment":"Returns a new Time where one or more of the elements\nhave been changed according to the +options+ parameter.\nThe time options (hour, minute, sec, usec) reset\ncascadingly, so if only the hour is passed, then\nminute, sec, and usec is set to 0. If the hour and\nminute is passed, then sec and usec is set to 0.\n\n  t1 = Time.at(10000)\n  t1.ctime   #=> \"Wed Dec 31 21:46:40 1969\"\n\n  t2 = t1.change(:hour => 11)\n  t2.ctime   #=> \"Wed Dec 31 11:00:00 1969\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"change(options)","arguments":[{"name":"options"}]}],"returns":[],"file":"/lib/core/facets/time/change.rb","line":null,"source":"def change(options)\n  opts=options; #{}; options.each_pair{ |k,v| opts[k] = v.to_i }\n  self.class.send(\n    self.utc? ? :utc : :local,\n    opts[:year]  || self.year,\n    opts[:month] || self.month,\n    opts[:day]   || self.day,\n    opts[:hour]  || self.hour,\n    opts[:min]   || (opts[:hour] ? 0 : self.min),\n    opts[:sec]   || ((opts[:hour] || opts[:min]) ? 0 : self.sec),\n    opts[:usec]  || ((opts[:hour] || opts[:min] || opts[:sec]) ? 0 : self.usec)\n  )\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#-":{"!":"method","declarations":["instance","public"],"path":"Hash#-","name":"-","namespace":"Hash","comment":"Operator for remove hash paris. If another hash is given\nthe pairs are only removed if both key and value are equal.\nIf an array is given then matching keys are removed.\n\nCREDIT: Trans\nCREDIT: Xavier Shay (bug fix)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"-(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/op_sub.rb","line":null,"source":"def -(other)\n  h = self.dup\n  if other.respond_to?(:to_ary)\n    other.to_ary.each do |k|\n      h.delete(k)\n    end\n  else\n    other.each do |k,v|\n      if h.key?(k)\n        h.delete(k) if v == h[k]\n      end\n    end\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#collate":{"!":"method","declarations":["instance","public"],"path":"Hash#collate","name":"collate","namespace":"Hash","comment":"Merge the values of this hash with those from another, setting all values\nto be arrays representing the values from both hashes.\n\n  { :a=>1, :b=>2 }.collate(:a=>3, :b=>4, :c=>5)\n  #=> { :a=>[1,3], :b=>[2,4], :c=>[5] }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"collate(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/collate.rb","line":null,"source":"def collate(other)\n  h = Hash.new\n  (keys + other.keys).each do |key|\n    h[key] = []\n  end\n  each do |key, value|\n    h[key] << value\n  end\n  other.each do |key, value|\n    h[key] << value\n  end\n  h.each{ |k,v| v.flatten! }\n  h\nend","language":"ruby","dynamic":null,"tags":{"author":"Gavin Kistner (original)"}},"Hash#collate!":{"!":"method","declarations":["instance","public"],"path":"Hash#collate!","name":"collate!","namespace":"Hash","comment":"The same as #collate, but modifies the receiver in place.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"collate!(other_hash)","arguments":[{"name":"other_hash"}]}],"returns":[],"file":"/lib/core/facets/hash/collate.rb","line":null,"source":"def collate!(other_hash)\n  result = collate(other_hash)\n  replace(result)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#to_proc":{"!":"method","declarations":["instance","public"],"path":"Hash#to_proc","name":"to_proc","namespace":"Hash","comment":"Constructs a Proc object from a hash such that the parameter\nof the Proc is assigned the hash keys as attributes.\n\n  c = Class.new do\n    attr_accessor :a\n  end\n\n  h = {:a => 1}\n  o = c.new\n  h.to_proc.call(o)\n  o.a  #=> 1\n\nIf +response+ is set to +true+, then assignment will only occur\nif receiver responds_to? the writer method.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_proc(response=false)","arguments":[{"name":"response","default":"false"}]}],"returns":[],"file":"/lib/core/facets/hash/to_proc.rb","line":null,"source":"def to_proc(response=false)\n  if response\n    lambda do |o|\n      self.each do |k,v|\n        ke = \"#{k}=\"\n        o.__send__(ke, v) if respond_to?(ke)\n      end\n    end\n  else\n    lambda do |o|\n      self.each do |k,v|\n        ke = \"#{k}=\"\n        o.__send__(ke, v)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#inverse":{"!":"method","declarations":["instance","public"],"path":"Hash#inverse","name":"inverse","namespace":"Hash","comment":"Create a \"true\" inverse hash by storing mutliple values in Arrays.\n\n  h = {\"a\"=>3, \"b\"=>3, \"c\"=>3, \"d\"=>2, \"e\"=>9, \"f\"=>3, \"g\"=>9}\n\n  h.invert           #=> {2=>\"d\", 3=>\"f\", 9=>\"g\"}\n  h.inverse          #=> {2=>\"d\", 3=>[\"f\", \"c\", \"b\", \"a\"], 9=>[\"g\", \"e\"]}\n  h.inverse.inverse  #=> {\"a\"=>3, \"b\"=>3, \"c\"=>3, \"d\"=>2, \"e\"=>9, \"f\"=>3, \"g\"=>9}\n\nOf course the inverse of the inverse should be the same.\n\n  (h.inverse.inverse == h)  #=> true\n\nCREDIT: Tilo Sloboda","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inverse()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/inverse.rb","line":null,"source":"def inverse\n  i = Hash.new\n  self.each_pair{ |k,v|\n    if (Array === v)\n      v.each{ |x| i[x] = ( i.has_key?(x) ? [k,i[x]].flatten : k ) }\n    else\n      i[v] = ( i.has_key?(v) ? [k,i[v]].flatten : k )\n    end\n  }\n  return i\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#<<":{"!":"method","declarations":["instance","public"],"path":"Hash#<<","name":"<<","namespace":"Hash","comment":"Can be used like update, or passed\nas two-element [key,value] array.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"<<(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/op_push.rb","line":null,"source":"def <<(other)\n  if other.respond_to?(:to_ary)\n    self.store(*other)\n  else\n    update(other)\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Time#to_time":{"!":"method","declarations":["instance","public"],"path":"Time#to_time","name":"to_time","namespace":"Time","comment":"To be able to keep Dates and Times interchangeable\non conversions.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_time()","arguments":[]}],"returns":[],"file":"/lib/core/facets/time/to_time.rb","line":null,"source":"def to_time\n  getlocal \nend","language":"ruby","dynamic":null,"tags":{}},"Regexp":{"!":"class","superclass":"Object","path":"Regexp","name":"Regexp","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Regexp#|","Regexp#arity","Regexp#to_regexp","Regexp#to_re","Regexp#+","Regexp#multiline?"],"accessors":[],"files":["/lib/core/facets/regexp/op_or.rb","/lib/core/facets/regexp/arity.rb","/lib/core/facets/regexp/to_re.rb","/lib/core/facets/regexp/op_add.rb","/lib/core/facets/regexp/multiline.rb"],"tags":{}},"Regexp#|":{"!":"method","declarations":["instance","public"],"path":"Regexp#|","name":"|","namespace":"Regexp","comment":"Operator form of `Regexp.union`.\n\n  /a/ | /b/  #=> /(?-mix:a)|(?-mix:b)/\n\nIf +other+ is not a Regexp it is passed to Regexp.escape.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"|(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/regexp/op_or.rb","line":null,"source":"def |(other)\n  other = Regexp.escape(other) unless Regexp === other\n  Regexp.union(self, other)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#recurse":{"!":"method","declarations":["instance","public"],"path":"Hash#recurse","name":"recurse","namespace":"Hash","comment":"Apply a block to hash, and recursively apply that block\nto each sub-hash or +types+.\n\n  h = {:a=>1, :b=>{:b1=>1, :b2=>2}}\n  g = h.recurse{|h| h.inject({}){|h,(k,v)| h[k.to_s] = v; h} }\n  g  #=> {\"a\"=>1, \"b\"=>{\"b1\"=>1, \"b2\"=>2}}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recurse(*types, &block)","arguments":[{"name":"*types"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/recurse.rb","line":null,"source":"def recurse(*types, &block)\n  types = [self.class] if types.empty?\n  h = inject({}) do |hash, (key, value)|\n    case value\n    when *types\n      hash[key] = value.recurse(*types, &block)\n    else\n      hash[key] = value\n    end\n    hash\n  end\n  yield h\nend","language":"ruby","dynamic":null,"tags":{"yield":""}},"Hash#recurse!":{"!":"method","declarations":["instance","public"],"path":"Hash#recurse!","name":"recurse!","namespace":"Hash","comment":"In place form of #recurse.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recurse!(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/recurse.rb","line":null,"source":"def recurse!(&block)\n  replace(recurse(&block))\nend","language":"ruby","dynamic":null,"tags":{}},"Hash.autonew":{"!":"method","declarations":["class","public"],"path":"Hash.autonew","name":"autonew","namespace":"Hash","comment":"Hash which auto initializes it's children.\n\n  h = Hash.autonew\n  h['s1']['p1'] = 4\n  h['s1']['p2'] = 5\n  h['s1']['p3'] = 2\n  h['s1']['p4'] = 3\n\n  h #=> {\"s1\"=>{\"p1\"=>4, \"p4\"=>3, \"p3\"=>2, \"p2\"=>5}}\n\n  h['s1'].keys.sort\n  #=> [\"p1\", \"p2\", \"p3\", \"p4\"]\n\nCREDIT: Trans, Jan Molic","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"autonew(.)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/hash/autonew.rb","line":null,"source":"def self.autonew(*args)\n  leet = lambda{ |hsh, key| hsh[key] = new( &leet ) }\n  new(*args,&leet)\nend","language":"ruby","dynamic":null,"tags":{}},"Regexp#arity":{"!":"method","declarations":["instance","public"],"path":"Regexp#arity","name":"arity","namespace":"Regexp","comment":"Returns the number of backreferencing subexpressions.\n\n  /(a)(b)(c)/.arity  #=> 3\n  /(a(b(c)))/.arity  #=> 3\n\nNote that this is not perfect, especially with regards to \\x\nand embedded comments.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"arity()","arguments":[]}],"returns":[],"file":"/lib/core/facets/regexp/arity.rb","line":null,"source":"def arity\n  source.scan( /(?!\\\\)[(](?!\\?[#=:!>-imx])/ ).length\nend","language":"ruby","dynamic":null,"tags":{}},"File.rewrite":{"!":"method","declarations":["class","public"],"path":"File.rewrite","name":"rewrite","namespace":"File","comment":"Opens a file as a string and writes back the string to the file at\nthe end of the block.\n\nReturns the number of written bytes or +nil+ if the file wasn't\nmodified.\n\nNote that the file will even be written back in case the block\nraises an exception.\n\nMode can either be \"b\" or \"+\" and specifies to open the file in\nbinary mode (no mapping of the plattform's newlines to \"\\n\" is\ndone) or to append to it.\n\nAssuming we had a file 'message.txt' and had a binary file 'binary.dat'.\n\n  # Reverse contents of \"message.txt\"\n  File.rewrite(\"message.txt\") { |str| str.reverse }\n\n  # Replace \"foo\" by \"bar\" in \"binary.dat\".\n  File.rewrite(\"binary.dat\", \"b\") { |str| str.gsub(\"foo\", \"bar\") }\n\nIMPORTANT: The old version of this method required in place modification\nof the file string. The new version will write whatever the block\nreturns instead!!!\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rewrite(.)","arguments":[{"name":"name"},{"name":"mode","default":"\"\""}]}],"returns":[],"file":"/lib/core/facets/file/rewrite.rb","line":null,"source":"def self.rewrite(name, mode = \"\") #:yield:\n  unless block_given?\n    raise(ArgumentError, \"Need to supply block to File.rewrite\")\n  end\n\n  if mode.is_a?(Numeric) then\n    flag, mode = mode, \"\"\n    mode += \"b\" if flag & File::Constants::BINARY != 0\n    mode += \"+\" if flag & File::Constants::APPEND != 0\n  else\n    mode.delete!(\"^b+\")\n  end\n\n  old_str = open(name, \"r#{mode}\") { |file| file.read } #rescue \"\"\n  old_str = old_str.clone\n\n  begin\n    new_str = yield(old_str)\n  ensure\n    if old_str != new_str\n      open(name, \"w#{mode}\") { |file| file.write(new_str) }\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"File.rewrite!":{"!":"method","declarations":["class","public"],"path":"File.rewrite!","name":"rewrite!","namespace":"File","comment":"In place version of #rewrite. This version of method requires that the\nstring be modified in place within the block.\n\n  # Reverse contents of \"message\"\n  File.rewrite(\"message.txt\") { |str| str.reverse! }\n\n  # Replace \"foo\" by \"bar\" in \"binary\"\n  File.rewrite(\"binary.dat\", \"b\") { |str| str.gsub!(\"foo\", \"bar\") }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rewrite!(.)","arguments":[{"name":"name"},{"name":"mode","default":"\"\""}]}],"returns":[],"file":"/lib/core/facets/file/rewrite.rb","line":null,"source":"def self.rewrite!(name, mode = \"\") #:yield:\n  unless block_given?\n    raise(ArgumentError, \"Need to supply block to File.rewrite\")\n  end\n\n  if mode.is_a?(Numeric) then\n    flag, mode = mode, \"\"\n    mode += \"b\" if flag & File::Constants::BINARY != 0\n    mode += \"+\" if flag & File::Constants::APPEND != 0\n  else\n    mode.delete!(\"^b+\")\n  end\n\n  old_str = open(name, \"r#{mode}\") { |file| file.read } #rescue \"\"\n  new_str = old_str.clone\n\n  begin\n    yield(new_str)\n  ensure\n    if old_str != new_str\n      open(name, \"w#{mode}\") { |file| file.write(new_str) }\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#to_re":{"!":"method","declarations":["instance","public"],"path":"String#to_re","name":"to_re","namespace":"String","comment":"Turns a string into a regular expression.\n\n  \"a?\".to_re  #=> /a?/\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_re(esc=false)","arguments":[{"name":"esc","default":"false"}]}],"returns":[],"file":"/lib/core/facets/string/to_re.rb","line":null,"source":"def to_re(esc=false)\n  Regexp.new((esc ? Regexp.escape(self) : self))\nend","language":"ruby","dynamic":null,"tags":{}},"String#to_rx":{"!":"method","declarations":["instance","public"],"path":"String#to_rx","name":"to_rx","namespace":"String","comment":"Turns a string into a regular expression.\nBy default it will escape all characters.\nUse <tt>false</tt> argument to turn off escaping.\n\n  \"[\".to_rx  #=> /\\[/\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_rx(esc=true)","arguments":[{"name":"esc","default":"true"}]}],"returns":[],"file":"/lib/core/facets/string/to_re.rb","line":null,"source":"def to_rx(esc=true)\n  Regexp.new((esc ? Regexp.escape(self) : self))\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#blank?":{"!":"method","declarations":["instance","public"],"path":"Kernel#blank?","name":"blank?","namespace":"Kernel","comment":"An object is blank if it's nil, empty, or a whitespace string.\nFor example, \"\", \"   \", nil, [], and {} are blank.\n\nThis simplifies...\n\n  if !address.nil? && !address.empty?\n\nto...\n\n  if !address.blank?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def blank?\n  return empty? if respond_to?(:empty?)\n  !self\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#present?":{"!":"method","declarations":["instance","public"],"path":"Kernel#present?","name":"present?","namespace":"Kernel","comment":"An object is present if it's not blank.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"present?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def present?\n  !blank?\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#presence":{"!":"method","declarations":["instance","public"],"path":"Kernel#presence","name":"presence","namespace":"Kernel","comment":"Returns object if it's #present? otherwise returns nil.\nobject.presence is equivalent to object.present? ? object : nil.\n\nThis is handy for any representation of objects where blank is the same\nas not present at all.  For example, this simplifies a common check for\nHTTP POST/query parameters...\n\n  state   = params[:state]   if params[:state].present?\n  country = params[:country] if params[:country].present?\n  region  = state || country || 'US'\n\nbecomes...\n\n  region = params[:state].presence || params[:country].presence || 'US'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"presence()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def presence\n  self if present?\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass#blank?":{"!":"method","declarations":["instance","public"],"path":"NilClass#blank?","name":"blank?","namespace":"NilClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def blank?\n  true\nend","language":"ruby","dynamic":null,"tags":{}},"FalseClass#blank?":{"!":"method","declarations":["instance","public"],"path":"FalseClass#blank?","name":"blank?","namespace":"FalseClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def blank?\n  true\nend","language":"ruby","dynamic":null,"tags":{}},"TrueClass#blank?":{"!":"method","declarations":["instance","public"],"path":"TrueClass#blank?","name":"blank?","namespace":"TrueClass","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def blank?\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Array#blank?":{"!":"method","declarations":["instance","public"],"path":"Array#blank?","name":"blank?","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"alias_method :blank?, :empty?","language":"ruby","dynamic":null,"tags":{}},"Hash#blank?":{"!":"method","declarations":["instance","public"],"path":"Hash#blank?","name":"blank?","namespace":"Hash","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"alias_method :blank?, :empty?","language":"ruby","dynamic":null,"tags":{}},"String#blank?":{"!":"method","declarations":["instance","public"],"path":"String#blank?","name":"blank?","namespace":"String","comment":"Is this string just whitespace?\n\n  \"abc\".blank?  #=> false\n  \"   \".blank?  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def blank?\n  /\\S/ !~ self\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#blank?":{"!":"method","declarations":["instance","public"],"path":"Numeric#blank?","name":"blank?","namespace":"Numeric","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"blank?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/blank.rb","line":null,"source":"def blank?\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#plain?":{"!":"method","declarations":["instance","public"],"path":"Symbol#plain?","name":"plain?","namespace":"Symbol","comment":"Symbol does not end in `!`, `=`, or `?`.\n\n  :a.plain?   #=> true\n  :a?.plain?  #=> false\n  :a!.plain?  #=> false\n  :a=.plain?  #=> false","format":"rdoc","aliases":["Symbol#reader?"],"singleton":null,"interfaces":[{"signature":"plain?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/symbol/plain.rb","line":null,"source":"def plain?\n  c = to_s[-1,1]\n  !(c == '=' || c == '?' || c == '!')\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#reader?":{"!":"method","declarations":["instance","public"],"path":"Symbol#reader?","name":"reader?","namespace":"Symbol","comment":"Symbol does not end in `!`, `=`, or `?`.\n\n  :a.plain?   #=> true\n  :a?.plain?  #=> false\n  :a!.plain?  #=> false\n  :a=.plain?  #=> false\n\nAlias for `#plain?` method. Likely this should have been the original\nand only name, but such is life.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"plain?()","arguments":[]}],"returns":[],"file":"/lib/core/facets/symbol/plain.rb","line":null,"source":"def plain?\n  c = to_s[-1,1]\n  !(c == '=' || c == '?' || c == '!')\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#setter?":{"!":"method","declarations":["instance","public"],"path":"Symbol#setter?","name":"setter?","namespace":"Symbol","comment":"Symbol ends in `=`.\n\n  :a=.setter? #=> true\n  :a.setter?  #=> false","format":"rdoc","aliases":["Symbol#writer?"],"singleton":null,"interfaces":[{"signature":"setter?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/symbol/plain.rb","line":null,"source":"def setter?\n  to_s[-1,1] == '='\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#writer?":{"!":"method","declarations":["instance","public"],"path":"Symbol#writer?","name":"writer?","namespace":"Symbol","comment":"Symbol ends in `=`.\n\n  :a=.setter? #=> true\n  :a.setter?  #=> false\n\nAlias for `#setter?` method. Likely this should have been the original\nand only name, but such is life.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"setter?()","arguments":[]}],"returns":[],"file":"/lib/core/facets/symbol/plain.rb","line":null,"source":"def setter?\n  to_s[-1,1] == '='\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#query?":{"!":"method","declarations":["instance","public"],"path":"Symbol#query?","name":"query?","namespace":"Symbol","comment":"Symbol ends in `?`.\n\n  :a?.query? #=> true\n  :a.query?  #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"query?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/symbol/plain.rb","line":null,"source":"def query?\n  to_s[-1,1] == '?'\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#bang?":{"!":"method","declarations":["instance","public"],"path":"Symbol#bang?","name":"bang?","namespace":"Symbol","comment":"Symbol ends in `!`.\n\n  :a!.bang? #=> true\n  :a.bang?  #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bang?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/symbol/plain.rb","line":null,"source":"def bang?\n  to_s[-1,1] == '!'\nend","language":"ruby","dynamic":null,"tags":{}},"String#store":{"!":"method","declarations":["instance","public"],"path":"String#store","name":"store","namespace":"String","comment":"Alias for []=.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"store","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/store.rb","line":null,"source":"alias_method :store, :[]=","language":"ruby","dynamic":null,"tags":{}},"String#lines":{"!":"method","declarations":["instance","public"],"path":"String#lines","name":"lines","namespace":"String","comment":"Returns an array of characters.\n\n  \"abc\\n123\".lines.to_a  #=> [\"abc\\n\",\"123\"]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lines(&blk)","arguments":[],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/string/lines.rb","line":null,"source":"def lines(&blk)\n  if block_given?\n    each_line(&blk) #scan(/$.*?\\n/).each(&blk)\n  else\n    Enumerator.new(self, :lines) #.split(/\\n/)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#align":{"!":"method","declarations":["instance","public"],"path":"String#align","name":"align","namespace":"String","comment":"Alignment method dispatches to #align_right, #align_left\nor #align_center, accorging to the first +direction+ parameter.\n\n  s = <<-EOS\n  This is a test\n    and\n    so on\n  EOS\n\n  s.align(:right, 14)\n\n_produces_ ...\n\n  This is a test\n             and\n           so on\n\nReturns a String aligned right, left or center.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"align(direction, n, sep=\"\\n\", c=' ')","arguments":[{"name":"direction"},{"name":"n"},{"name":"sep","default":"\"\\n\""},{"name":"c","default":"' '"}]}],"returns":[],"file":"/lib/core/facets/string/align.rb","line":null,"source":"def align(direction, n, sep=\"\\n\", c=' ')\n  case direction\n  when :right\n    align_right(n, sep=\"\\n\", c=' ')\n  when :left\n    align_left(n, sep=\"\\n\", c=' ')\n  when :center\n    align_center(n, sep=\"\\n\", c=' ')\n  else\n    raise ArgumentError\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#align_right":{"!":"method","declarations":["instance","public"],"path":"String#align_right","name":"align_right","namespace":"String","comment":"Align a string to the right.\n\nThe default alignment separation is a new line (\"\\n\").\nThis can be changed as can be the padding string which\ndefaults to a single space (' ').\n\n  s = <<-EOS\n  This is a test\n    and\n    so on\n  EOS\n\n  s.align_right(14)\n\n_produces_ ...\n\n  This is a test\n             and\n           so on\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"align_right(n, sep=\"\\n\", c=' ')","arguments":[{"name":"n"},{"name":"sep","default":"\"\\n\""},{"name":"c","default":"' '"}]}],"returns":[],"file":"/lib/core/facets/string/align.rb","line":null,"source":"def align_right(n, sep=\"\\n\", c=' ')\n  return rjust(n.to_i,c.to_s) if sep==nil\n  q = split(sep.to_s).map do |line|\n    line.rjust(n.to_i,c.to_s)\n  end\n  q.join(sep.to_s)\nend","language":"ruby","dynamic":null,"tags":{}},"String#align_left":{"!":"method","declarations":["instance","public"],"path":"String#align_left","name":"align_left","namespace":"String","comment":"Align a string to the left.\n\nThe default alignment separation is a new line (\"\\n\").\nThis can be changed as can be the padding string which\ndefaults to a single space (' ').\n\n  s = <<-EOS\n  This is a test\n    and\n    so on\n  EOS\n\n  s.align_left(20, \"\\n\", '.')\n\n_produces_ ...\n\n  This is a test......\n  and.................\n  so on...............\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"align_left(n, sep=\"\\n\", c=' ')","arguments":[{"name":"n"},{"name":"sep","default":"\"\\n\""},{"name":"c","default":"' '"}]}],"returns":[],"file":"/lib/core/facets/string/align.rb","line":null,"source":"def align_left(n, sep=\"\\n\", c=' ')\n  return ljust(n.to_i,c.to_s) if sep==nil\n  q = split(sep.to_s).map do |line|\n    line.strip.ljust(n.to_i,c.to_s)\n  end\n  q.join(sep.to_s)\nend","language":"ruby","dynamic":null,"tags":{}},"String#align_center":{"!":"method","declarations":["instance","public"],"path":"String#align_center","name":"align_center","namespace":"String","comment":"Centers each line of a string.\n\nThe default alignment separation is a new line (\"\\n\").\nThis can be changed as can be the padding string which\ndefaults to a single space (' ').\n\n  s = <<-EOS\n    This is a test\n    and\n    so on\n  EOS\n\n  s.align_center(14)\n\n_produces_ ...\n\n  This is a test\n       and\n      so on\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"align_center(n, sep=\"\\n\", c=' ')","arguments":[{"name":"n"},{"name":"sep","default":"\"\\n\""},{"name":"c","default":"' '"}]}],"returns":[],"file":"/lib/core/facets/string/align.rb","line":null,"source":"def align_center(n, sep=\"\\n\", c=' ')\n  return center(n.to_i,c.to_s) if sep==nil\n  q = split(sep.to_s).collect { |line|\n    line.center(n.to_i,c.to_s)\n  }\n  q.join(sep.to_s)\nend","language":"ruby","dynamic":null,"tags":{}},"Range#within?":{"!":"method","declarations":["instance","public"],"path":"Range#within?","name":"within?","namespace":"Range","comment":"Uses the Range#umbrella method to determine\nif another Range is _anywhere_ within this Range.\n\n  (1..3).within?(0..4)  #=> true\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"within?(rng)","arguments":[{"name":"rng"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/range/within.rb","line":null,"source":"def within?(rng)\n  case rng.umbrella(self)\n  when [0,0], [-1,0], [0,-1], [-1,-1]\n    return true\n  else\n    return false\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Range#umbrella":{"!":"method","declarations":["instance","public"],"path":"Range#umbrella","name":"umbrella","namespace":"Range","comment":"Returns a two element array of the relationship\nbetween two Ranges.\n\nDiagram ...\n\n    Relationship     Returns\n\n  self |-----------|\n  r    |-----------|    [0,0]\n\n  self |-----------|\n  r     |---------|     [-1,-1]\n\n  self  |---------|\n  r    |-----------|    [1,1]\n\n  self |-----------|\n  r     |----------|    [-1,0]\n\n  self |-----------|\n  r     |-----------|   [-1,1]\n\n  etc.\n\nExample:\n\n  (0..3).umbrella(1..2)  #=>  [-1,-1]\n\nCREDIT: Trans, Chris Kappler","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"umbrella(r)","arguments":[{"name":"r"}]}],"returns":[],"file":"/lib/core/facets/range/within.rb","line":null,"source":"def umbrella(r)\n  s = first <=> r.first\n  e = r.last <=> last\n\n  if e == 0\n    if r.exclude_end? and exclude_end?\n      e = r.max <=> max\n    else\n      e = (r.exclude_end? ? 0 : 1) <=> (exclude_end? ? 0 : 1)\n    end\n  end\n\n  return s,e\nend","language":"ruby","dynamic":null,"tags":{}},"String#range":{"!":"method","declarations":["instance","public"],"path":"String#range","name":"range","namespace":"String","comment":"Like #index but returns a Range.\n\n  \"This is a test!\".range('test')  #=> (10..13)\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"range(pattern, offset=0)","arguments":[{"name":"pattern"},{"name":"offset","default":"0"}]}],"returns":[],"file":"/lib/core/facets/string/range.rb","line":null,"source":"def range(pattern, offset=0)\n  unless Regexp === pattern\n    pattern = Regexp.new(Regexp.escape(pattern.to_s))\n  end\n  string = self[offset..-1]\n  if md = pattern.match(string)\n    return (md.begin(0)+offset)..(md.end(0)+offset-1)\n  end\n  nil\nend","language":"ruby","dynamic":null,"tags":{}},"String#range_all":{"!":"method","declarations":["instance","public"],"path":"String#range_all","name":"range_all","namespace":"String","comment":"Like #index_all but returns an array of Ranges.\n\n  \"abc123abc123\".range_all('abc')  #=> [0..2, 6..8]\n\nTODO: Add offset ?\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"range_all(pattern, reuse=false)","arguments":[{"name":"pattern"},{"name":"reuse","default":"false"}]}],"returns":[],"file":"/lib/core/facets/string/range.rb","line":null,"source":"def range_all(pattern, reuse=false)\n  r = []; i = 0\n  while i < self.length\n    rng = range(pattern, i)\n    if rng\n      r << rng\n      i += reuse ? 1 : rng.end + 1\n    else\n      break\n    end\n  end\n  r.uniq\nend","language":"ruby","dynamic":null,"tags":{}},"String#range_of_line":{"!":"method","declarations":["instance","public"],"path":"String#range_of_line","name":"range_of_line","namespace":"String","comment":"Returns an array of ranges mapping\nthe characters per line.\n\n  \"this\\nis\\na\\ntest\".range_of_line\n  #=> [0..4, 5..7, 8..9, 10..13]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"range_of_line()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/range.rb","line":null,"source":"def range_of_line\n  offset=0; charmap = []\n  each_line do |line|\n    charmap << (offset..(offset + line.length - 1))\n    offset += line.length\n  end\n  charmap\nend","language":"ruby","dynamic":null,"tags":{}},"Regexp#to_regexp":{"!":"method","declarations":["instance","public"],"path":"Regexp#to_regexp","name":"to_regexp","namespace":"Regexp","comment":"Like #to_re, but following Ruby's formal definitions,\nonly a Regular expression type object will respond to this.\n\nNote that to be of much real use this should be defined in core Ruby.\n\nCREDIT: Florian Gross","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_regexp()","arguments":[]}],"returns":[],"file":"/lib/core/facets/regexp/to_re.rb","line":null,"source":"def to_regexp\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Regexp#to_re":{"!":"method","declarations":["instance","public"],"path":"Regexp#to_re","name":"to_re","namespace":"Regexp","comment":"Simply returns itself. Helpful when converting\nstrings to regular expressions, where regexp\nmight occur as well --in the same vien as using\n#to_s on symbols. The parameter is actaully a\ndummy parameter to coincide with String#to_re.\n\n  /abc/.to_re  #=> /abc/\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_re(esc=false)","arguments":[{"name":"esc","default":"false"}]}],"returns":[],"file":"/lib/core/facets/regexp/to_re.rb","line":null,"source":"def to_re(esc=false)\n  self  # Of course, things really should know how to say \"I\" ;)\nend","language":"ruby","dynamic":null,"tags":{}},"Proc#compose":{"!":"method","declarations":["instance","public"],"path":"Proc#compose","name":"compose","namespace":"Proc","comment":"Returns a new proc that is the functional\ncomposition of two procs, in order.\n\n  a = lambda { |x| x + 4 }\n  b = lambda { |y| y / 2 }\n\n  a.compose(b).call(4)  #=> 6\n  b.compose(a).call(4)  #=> 4\n\nCREDIT: Dave","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"compose(g)","arguments":[{"name":"g"}]}],"returns":[],"file":"/lib/core/facets/proc/compose.rb","line":null,"source":"def compose(g)\n  raise ArgumentError, \"arity count mismatch\" unless arity == g.arity\n  lambda{ |*a| self[ *g[*a] ] }\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Proc#*":{"!":"method","declarations":["instance","public"],"path":"Proc#*","name":"*","namespace":"Proc","comment":"Operator for Proc#compose and Integer#times_collect/of.\n\n  a = lambda { |x| x + 4 }\n  b = lambda { |y| y / 2 }\n\n  (a * b).call(4)  #=> 6\n  (b * a).call(4)  #=> 4\n\nCREDIT: Dave","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"*(x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/core/facets/proc/compose.rb","line":null,"source":"def *(x)\n  if Integer===x\n    # collect times\n    c = []\n    x.times{|i| c << call(i)}\n    c\n  else\n    # compose procs\n    lambda{|*a| self[x[*a]]}\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Proc#bind_to":{"!":"method","declarations":["instance","public"],"path":"Proc#bind_to","name":"bind_to","namespace":"Proc","comment":"Bind a procedure to an object. This works\nwrapping instance_eval on the Proc object\nand then wrapping this in a new Proc.\n\n   a = [1,2,3]\n   p1 = Proc.new{ join(' ') }\n   p2 = p1.bind_to(a)\n   p2.call  #=> '1 2 3'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bind_to(object)","arguments":[{"name":"object"}]}],"returns":[],"file":"/lib/core/facets/proc/bind_to.rb","line":null,"source":"def bind_to(object)\n  Proc.new{object.instance_eval(&self)}\nend","language":"ruby","dynamic":null,"tags":{}},"Proc#partial":{"!":"method","declarations":["instance","public"],"path":"Proc#partial","name":"partial","namespace":"Proc","comment":"Convert a Proc object into new partial Proc object.\n\n  a = proc { |a,b,c| a+b+c }\n  b = a.partial(NA,2,NA)\n  b[1,3] #=> 6\n\nNote, the #__ method, which used to be used in stay of NA,\nhas been deprecated.\n\n--\n  a = proc { |a,b,c| a+b+c }\n  b = a.partial(__,2,__)\n  b[1,3] #=> 6\n++\n\nThis method is similar to Proc#curry.\n\nCREDT Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"partial(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/proc/partial.rb","line":null,"source":"def partial(*args)\n  Proc.new do |*spice|\n    result = args.collect do |a|\n      NA == a ? spice.pop : a\n    end\n    call(*result)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#nodef":{"!":"method","declarations":["instance","public"],"path":"Module#nodef","name":"nodef","namespace":"Module","comment":"Alias for undef_method. This has been called \"nodef\" instead of\nundef to help clarify that it doesn't get rid of the method, but\nrather represses repsonse.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"nodef","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/nodef.rb","line":null,"source":"alias_method :nodef, :undef_method","language":"ruby","dynamic":null,"tags":{}},"Module#remove":{"!":"method","declarations":["instance","public"],"path":"Module#remove","name":"remove","namespace":"Module","comment":"Alias for remove_method. This method actually \"undefines\" a method\nand will raise an error is the method is not defined in receiver.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"remove","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/nodef.rb","line":null,"source":"alias_method :remove,  :remove_method","language":"ruby","dynamic":null,"tags":{}},"String#mscan":{"!":"method","declarations":["instance","public"],"path":"String#mscan","name":"mscan","namespace":"String","comment":"Like #scan but returns MatchData ($~) rather\nthen matched string ($&).\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mscan(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/core/facets/string/mscan.rb","line":null,"source":"def mscan(re) #:yield:\n  if block_given?\n    scan(re) { yield($~) }\n  else\n    m = []\n    scan(re) { m << $~ }\n    m\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#divide":{"!":"method","declarations":["instance","public"],"path":"Array#divide","name":"divide","namespace":"Array","comment":"Divide on matching pattern.\n\n  ['a1','b1','a2','b2'].divide(/^a/)\n  #=> [['a1','b1'],['a2','b2']]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"divide(pattern)","arguments":[{"name":"pattern"}]}],"returns":[],"file":"/lib/core/facets/array/divide.rb","line":null,"source":"def divide(pattern)\n  memo = []\n  each do |obj|\n    memo.push [] if pattern === obj\n    memo.last << obj\n  end\n  memo\nend","language":"ruby","dynamic":null,"tags":{}},"Array#**":{"!":"method","declarations":["instance","public"],"path":"Array#**","name":"**","namespace":"Array","comment":"Array#** is an alias for Array#product.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"**","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/op_pow.rb","line":null,"source":"alias_method :**, :product","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/array/op_pow'"}},"Symbol#chomp":{"!":"method","declarations":["instance","public"],"path":"Symbol#chomp","name":"chomp","namespace":"Symbol","comment":"Just like String#chomp.\n\n  :ab.chomp(:b)  #=> :a\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"chomp(seperator)","arguments":[{"name":"seperator"}]}],"returns":[],"file":"/lib/core/facets/symbol/chomp.rb","line":null,"source":"def chomp(seperator)\n  to_s.chomp(seperator.to_s).to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#lchomp":{"!":"method","declarations":["instance","public"],"path":"Symbol#lchomp","name":"lchomp","namespace":"Symbol","comment":"Just like String#lchomp.\n\n  :ab.lchomp(:a)  #=> :b\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lchomp(seperator)","arguments":[{"name":"seperator"}]}],"returns":[],"file":"/lib/core/facets/symbol/chomp.rb","line":null,"source":"def lchomp(seperator)\n  to_s.reverse.chomp(seperator.to_s).reverse.to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"String#bytes":{"!":"method","declarations":["instance","public"],"path":"String#bytes","name":"bytes","namespace":"String","comment":"Upacks string into bytes.\n\nNote, this is not 100% compatible with 1.8.7+\nwhich returns an enumerator instead of an array.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bytes(&blk)","arguments":[],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/string/bytes.rb","line":null,"source":"def bytes(&blk)\n  if block_given?\n    self.unpack('C*').each(&blk)\n  else\n    self.unpack('C*')\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#splice":{"!":"method","declarations":["instance","public"],"path":"Array#splice","name":"splice","namespace":"Array","comment":"Splice acts a combination of #slice! and #store.\nIf two arguments are given it calls #store.\nIf a single argument is given it calls slice!.\n\n  a = [1,2,3]\n  a.splice(1)    #=> 2\n  a              #=> [1,3]\n\n  a = [1,2,3]\n  a.splice(1,4)  #=> 4\n  a              #=>[1,4,3]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"splice(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/array/splice.rb","line":null,"source":"def splice(*args)\n  if args.size == 1\n    slice!(*args)\n  else\n    store(*args)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#median":{"!":"method","declarations":["instance","public"],"path":"Array#median","name":"median","namespace":"Array","comment":"Determines the _sorted_ middle element.\n\n  a = %w{a a b b c c c}\n  a.median     #=> \"b\"\n\nWhen there are an even number of elements, the greater\nof the two middle elements is given.\n\n  a = %w{a a b b c c c d}\n  a.median     #=> \"c\"\n\nAn offset can be supplied to get an element relative\nto the middle.\n\n  a = %w{a a b b c c c d}\n  a.median(-1) #=> \"b\"\n\nThe the array is empty, +nil+ is returned.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"median(offset=0)","arguments":[{"name":"offset","default":"0"}]}],"returns":[{"type":"Object","comment":"sorted middle element"}],"file":"/lib/core/facets/array/median.rb","line":null,"source":"def median(offset=0)\n  return nil if self.size == 0\n\n  tmp = self.sort\n  mid = (tmp.size / 2).to_i + offset\n\n  tmp[mid]\nend","language":"ruby","dynamic":null,"tags":{}},"Binding":{"!":"class","superclass":"Object","path":"Binding","name":"Binding","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Binding#self","Binding#eval","Binding#with","Binding#caller","Binding#__LINE__","Binding#__FILE__","Binding#__DIR__","Binding#__method__","Binding#__callee__","Binding#[]","Binding#[]=","Binding#defined?","Binding#call_stack","Binding#callstack","Binding#local_variables"],"accessors":[],"files":["/lib/core/facets/binding/self.rb","/lib/core/facets/binding/eval.rb","/lib/core/facets/binding/with.rb","/lib/core/facets/binding/caller.rb","/lib/core/facets/binding/op_get.rb","/lib/core/facets/binding/defined.rb","/lib/core/facets/kernel/call_stack.rb","/lib/core/facets/binding/local_variables.rb"],"tags":{}},"Binding#self":{"!":"method","declarations":["instance","public"],"path":"Binding#self","name":"self","namespace":"Binding","comment":"Returns self of the binding's context.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"self()","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/self.rb","line":null,"source":"def self\n  eval('self')\nend","language":"ruby","dynamic":null,"tags":{}},"String#quote":{"!":"method","declarations":["instance","public"],"path":"String#quote","name":"quote","namespace":"String","comment":"Return a new string embraced by given +type+ and +count+\nof quotes. The arguments can be given in any order.\n\nIf no type is given, double quotes are assumed.\n\n  \"quote me\".quote     #=> '\"quote me\"'\n\nIf no type but a count is given then :mixed is assumed.\n\n  \"quote me\".quote(1)  #=> %q{'quote me'}\n  \"quote me\".quote(2)  #=> %q{\"quote me\"}\n  \"quote me\".quote(3)  #=> %q{'\"quote me\"'}\n\nSymbols can be used to describe the type.\n\n  \"quote me\".quote(:single)    #=> %q{'quote me'}\n  \"quote me\".quote(:double)    #=> %q{\"quote me\"}\n  \"quote me\".quote(:back)      #=> %q{`quote me`}\n  \"quote me\".quote(:bracket)   #=> %q{`quote me'}\n\nOr the character itself.\n\n  \"quote me\".quote(\"'\")     #=> %q{'quote me'}\n  \"quote me\".quote('\"')     #=> %q{\"quote me\"}\n  \"quote me\".quote(\"`\")     #=> %q{`quote me`}\n  \"quote me\".quote(\"`'\")    #=> %q{`quote me'}\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"quote(type=:double, count=nil)","arguments":[{"name":"type","default":":double"},{"name":"count","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/quote.rb","line":null,"source":"def quote(type=:double, count=nil)\n  if Integer === type\n    tmp   = count\n    count = type\n    type  = tmp || :mixed\n  else\n    count ||= 1\n  end\n\n  type = type.to_s unless Integer===type\n\n  case type\n  when \"'\", 'single', 's', 1\n    f = \"'\" * count\n    b = f\n  when '\"', 'double', 'd', 2\n    f = '\"' * count\n    b = f\n  when '`', 'back', 'b', -1\n    f = '`' * count\n    b = f\n  when \"`'\", 'bracket', 'sb'\n    f = \"`\" * count\n    b = \"'\" * count\n  when \"'\\\"\", 'mixed', \"m\", Integer\n    c = (count.to_f / 2).to_i\n    f = '\"' * c\n    b = f\n    if count % 2 != 0\n      f = \"'\" + f\n      b = b + \"'\"\n    end\n  else\n    raise ArgumentError, \"unrecognized quote type -- #{type}\"\n  end\n  \"#{f}#{self}#{b}\"\nend","language":"ruby","dynamic":null,"tags":{}},"String#unquote":{"!":"method","declarations":["instance","public"],"path":"String#unquote","name":"unquote","namespace":"String","comment":"Remove quotes from string.\n\n  \"'hi'\".unquote    #=> \"hi\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unquote()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/quote.rb","line":null,"source":"def unquote\n  s = self.dup\n\n  case self[0,1]\n  when \"'\", '\"', '`'\n    s[0] = ''\n  end\n\n  case self[-1,1]\n  when \"'\", '\"', '`'\n    s[-1] = ''\n  end\n\n  return s\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#maybe":{"!":"method","declarations":["instance","public"],"path":"Kernel#maybe","name":"maybe","namespace":"Kernel","comment":"Random generator that returns true or false.\nCan also take a block that has a 50/50 chance\nto being executed...\n\n  maybe  #=> true\n  maybe  #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"maybe(chance = 0.5, &block)","arguments":[{"name":"chance","default":"0.5"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/maybe.rb","line":null,"source":"def maybe(chance = 0.5, &block)\n  if block\n    yield if rand < chance\n  else\n    rand < chance\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#eigen":{"!":"method","declarations":["instance","public"],"path":"Kernel#eigen","name":"eigen","namespace":"Kernel","comment":"Call methods on the eigenclass (i.e. the singleton_class).\n\n  name = \"Tom\"\n  name.eigen.define_method(:turkey){ self + \" Turkey\" }\n  name.turkey #=> \"Tom Turkey\"\n\nOne the nice things you can do with #eigen, is define class attributes\nwithout having to open a `class << self` block.\n\n  c = Class.new do\n    eigen.attr_accessor :a\n  end\n  c.a = 1\n  c.a #=> 1\n\nNOTE: This was once called `#meta`, but meta is such a generic\nand overly used term that 'eigen' was decided upon as a better\nchoice. You can thank or blame _why for the term, if you like.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eigen()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/eigen.rb","line":null,"source":"def eigen\n  Functor.new do |op,*a,&b|\n    (class << self; self; end).class_eval do\n      __send__(op,*a,&b)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#eval":{"!":"method","declarations":["instance","public"],"path":"Binding#eval","name":"eval","namespace":"Binding","comment":"Evaluate a Ruby source code string (or block) in the binding context.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eval(str)","arguments":[{"name":"str"}]}],"returns":[],"file":"/lib/core/facets/binding/eval.rb","line":null,"source":"def eval(str)\n  Kernel.eval(str, self)\nend","language":"ruby","dynamic":null,"tags":{}},"String#tabto":{"!":"method","declarations":["instance","public"],"path":"String#tabto","name":"tabto","namespace":"String","comment":"Preserves relative tabbing.\nThe first non-empty line ends up with n spaces before nonspace.\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"tabto(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/string/tabto.rb","line":null,"source":"def tabto(n)\n  if self =~ /^( *)\\S/\n    indent(n - $1.length)\n  else\n    self\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#class?":{"!":"method","declarations":["instance","public"],"path":"Module#class?","name":"class?","namespace":"Module","comment":"Alias for #===. This provides a verbal method\nfor inquery.\n\n  s = \"HELLO\"\n  String.class?(s)  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class?","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/class.rb","line":null,"source":"alias_method :class?, :===","language":"ruby","dynamic":null,"tags":{}},"String#words":{"!":"method","declarations":["instance","public"],"path":"String#words","name":"words","namespace":"String","comment":"Returns an array of characters.\n\n  \"abc 123\".words  #=> [\"abc\",\"123\"]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"words()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/words.rb","line":null,"source":"def words\n  self.split(/\\s+/)\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#with":{"!":"method","declarations":["instance","public"],"path":"Binding#with","name":"with","namespace":"Binding","comment":"Returns a new binding with local varaibles set.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"with(_local_variables, &_yields)","arguments":[{"name":"_local_variables"}],"block":{"name":"&_yields"}}],"returns":[],"file":"/lib/core/facets/binding/with.rb","line":null,"source":"def with(_local_variables, &_yields)\n  eval(\"lambda{ |#{_local_variables.keys.join(',')},&yields| binding }\").call(*_local_variables.values, &_yields)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#cattr":{"!":"method","declarations":["instance","public"],"path":"Module#cattr","name":"cattr","namespace":"Module","comment":"Creates a class-variable attribute that can\nbe accessed both on an instance and class level.\n\n  class CARExample\n    @@a = 10\n    cattr :a\n  end\n\n  CARExample.a           #=> 10\n  CARExample.new.a       #=> 10\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cattr(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def cattr(*syms)\n  writers, readers = syms.flatten.partition{ |a| a.to_s =~ /=$/ }\n  writers = writers.map{ |e| e.to_s.chomp('=').to_sym }\n  ##readers.concat( writers ) # writers also get readers\n\n  cattr_reader(*readers)\n  cattr_writer(*writers)\n\n  return readers + writers\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#cattr_reader":{"!":"method","declarations":["instance","public"],"path":"Module#cattr_reader","name":"cattr_reader","namespace":"Module","comment":"Creates a class-variable attr_reader that can\nbe accessed both on an instance and class level.\n\n  class CARExample\n    @@a = 10\n    cattr_reader :a\n  end\n\n  CARExample.a           #=> 10\n  CARExample.new.a       #=> 10\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cattr_reader(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def cattr_reader(*syms)\n  syms.flatten.each do |sym|\n    module_eval(<<-EOS, __FILE__, __LINE__)\n      unless defined? @@#{sym}\n        @@#{sym} = nil\n      end\n\n      def self.#{sym}\n        @@#{sym}\n      end\n\n      def #{sym}\n        @@#{sym}\n      end\n    EOS\n  end\n  return syms\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#cattr_writer":{"!":"method","declarations":["instance","public"],"path":"Module#cattr_writer","name":"cattr_writer","namespace":"Module","comment":"Creates a class-variable attr_writer that can\nbe accessed both on an instance and class level.\n\n  class CAWExample\n    cattr_writer :a\n    def self.a\n      @@a\n    end\n  end\n\n  CAWExample.a = 10\n  CAWExample.a            #=> 10\n  CAWExample.new.a = 29\n  CAWExample.a            #=> 29\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cattr_writer(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def cattr_writer(*syms)\n  syms.flatten.each do |sym|\n    module_eval(<<-EOS, __FILE__, __LINE__)\n      unless defined? @@#{sym}\n        @@#{sym} = nil\n      end\n\n      def self.#{sym}=(obj)\n        @@#{sym} = obj\n      end\n\n      def #{sym}=(obj)\n        @@#{sym}=(obj)\n      end\n    EOS\n  end\n  return syms\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#cattr_accessor":{"!":"method","declarations":["instance","public"],"path":"Module#cattr_accessor","name":"cattr_accessor","namespace":"Module","comment":"Creates a class-variable attr_accessor that can\nbe accessed both on an instance and class level.\n\n  class CAAExample\n    cattr_accessor :a\n  end\n\n  CAAExample.a = 10\n  CAAExample.a           #=> 10\n  mc = CAAExample.new\n  mc.a                   #=> 10\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cattr_accessor(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def cattr_accessor(*syms)\n  cattr_reader(*syms) + cattr_writer(*syms)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#mattr":{"!":"method","declarations":["instance","public"],"path":"Module#mattr","name":"mattr","namespace":"Module","comment":"Creates a class-variable attribute that can\nbe accessed both on an instance and class level.\n\n  c = Class.new do\n    mattr :a\n    def initialize\n      @@a = 10\n    end\n  end\n\n  c.new.a       #=> 10\n  c.a           #=> 10\n\nNOTE: The #mattr methods may not be as useful for modules as the #cattr\nmethods are for classes, becuase class-level methods are not \"inherited\"\nacross the metaclass for included modules.\n\nNOTE: This methiod is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mattr(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def mattr(*syms)\n  writers, readers = syms.flatten.partition{ |a| a.to_s =~ /=$/ }\n  writers = writers.collect{ |e| e.to_s.chomp('=').to_sym }\n  ##readers.concat( writers ) # writers also get readers\n\n  mattr_writer( *writers )\n  mattr_reader( *readers )\n\n  return readers + writers\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#mattr_reader":{"!":"method","declarations":["instance","public"],"path":"Module#mattr_reader","name":"mattr_reader","namespace":"Module","comment":"Creates a class-variable attr_reader that can\nbe accessed both on an instance and class level.\n\n  c = Class.new do\n    @@a = 10\n    mattr_reader :a\n  end\n\n  c.a           #=> 10\n  c.new.a       #=> 10\n\nNOTE: This methiod is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mattr_reader(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def mattr_reader( *syms )\n  syms.flatten.each do |sym|\n    module_eval(<<-EOS, __FILE__, __LINE__)\n      unless defined? @@#{sym}\n        @@#{sym} = nil\n      end\n\n      def self.#{sym}\n        @@#{sym}\n      end\n\n      def #{sym}\n        @@#{sym}\n      end\n    EOS\n  end\n  return syms\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#mattr_writer":{"!":"method","declarations":["instance","public"],"path":"Module#mattr_writer","name":"mattr_writer","namespace":"Module","comment":"Creates a class-variable attr_writer that can\nbe accessed both on an instance and class level.\n\n  c = Class.new do\n    mattr_writer :a\n    def self.a\n      @@a\n    end\n  end\n\n  c.a = 10\n  c.a            #=> 10\n\n  c.new.a = 29\n  c.a            #=> 29\n\nNOTE: This methiod is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mattr_writer(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def mattr_writer(*syms)\n  syms.flatten.each do |sym|\n    module_eval(<<-EOS, __FILE__, __LINE__)\n      unless defined? @@#{sym}\n        @@#{sym} = nil\n      end\n\n      def self.#{sym}=(obj)\n        @@#{sym} = obj\n      end\n\n      def #{sym}=(obj)\n        @@#{sym}=(obj)\n      end\n    EOS\n  end\n  return syms\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Module#mattr_accessor":{"!":"method","declarations":["instance","public"],"path":"Module#mattr_accessor","name":"mattr_accessor","namespace":"Module","comment":"Creates a class-variable attr_accessor that can\nbe accessed both on an instance and class level.\n\n  c = Class.new do\n    mattr_accessor :a\n  end\n\n  c.a = 10\n  c.a           #=> 10\n\n  x = c.new\n  x.a           #=> 10\n\nNOTE: This methiod is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"mattr_accessor(*syms)","arguments":[{"name":"*syms"}]}],"returns":[],"file":"/lib/core/facets/module/mattr.rb","line":null,"source":"def mattr_accessor(*syms)\n  mattr_reader(*syms) + mattr_writer(*syms)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/cattr'"}},"Array#select!":{"!":"method","declarations":["instance","public"],"path":"Array#select!","name":"select!","namespace":"Array","comment":"As with #select but modifies the Array in place.\n\n  a = [1,2,3,4,5,6,7,8,9,10]\n  a.select!{ |e| e % 2 == 0 }\n  a  #=> [2,4,6,8,10]\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"select!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/select.rb","line":null,"source":"def select!  # :yield:\n  reject!{ |e| not yield(e) }\nend","language":"ruby","dynamic":null,"tags":{}},"String#nchar":{"!":"method","declarations":["instance","public"],"path":"String#nchar","name":"nchar","namespace":"String","comment":"Returns _n_ characters of the string. If _n_ is positive\nthe characters are from the beginning of the string.\nIf _n_ is negative from the end of the string.\n\n   str = \"this is text\"\n\n   str.nchar(4)            #=> \"this\"\n   str.nchar(-4)           #=> \"text\"\n\nAlternatively a replacement string can be given, which will\nreplace the _n_ characters.\n\n   str.nchar(4, 'that')    #=> \"that is text\"\n\nThe original string remains unaffected.\n\n   str  #=> \"this is text\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"nchar(n, replacement=nil)","arguments":[{"name":"n"},{"name":"replacement","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/nchar.rb","line":null,"source":"def nchar(n, replacement=nil)\n  if replacement\n    s = self.dup\n    n > 0 ? (s[0...n] = replacement) : (s[n..-1] = replacement)\n    s\n  else\n    n > 0 ? self[0...n] : self[n..-1]\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#_crypt":{"!":"method","declarations":["instance","public"],"path":"String#_crypt","name":"_crypt","namespace":"String","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_crypt","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/crypt.rb","line":null,"source":"alias_method :_crypt, :crypt","language":"ruby","dynamic":null,"tags":{}},"String#crypt":{"!":"method","declarations":["instance","public"],"path":"String#crypt","name":"crypt","namespace":"String","comment":"Common Unix cryptography method.\nThis adds a default salt to the built-in crypt method.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"crypt(salt=nil)","arguments":[{"name":"salt","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/crypt.rb","line":null,"source":"def crypt(salt=nil)\n  salt ||= (\n    (rand(26) + (rand(2) == 0 ? 65 : 97) ).chr +\n    (rand(26) + (rand(2) == 0 ? 65 : 97) ).chr\n  )\n  _crypt(salt)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/string/crypt'"}},"Array#before":{"!":"method","declarations":["instance","public"],"path":"Array#before","name":"before","namespace":"Array","comment":"Returns the value previous to the given value. The value previous\nto the first is the last. Returns nil if the given value is not\nin the array.\n\nExamples\n\n  sequence = ['a', 'b', 'c']\n  sequence.before('a')           #=> 'c'\n  sequence.before('b')           #=> 'a'\n  sequence.before('c')           #=> 'b'\n  sequence.before('d')           #=> nil\n\nCREDIT: Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"before(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/core/facets/array/before.rb","line":null,"source":"def before(value)\n  return nil unless include? value\n  self[(index(value).to_i - 1) % length]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#after":{"!":"method","declarations":["instance","public"],"path":"Array#after","name":"after","namespace":"Array","comment":"Returns the value after the given value. The value before the last\nis the first. Returns nil if the given value is not in the array.\n\nExamples\n\n  sequence = ['a', 'b', 'c']\n  sequence.after('a')           #=> 'b'\n  sequence.after('b')           #=> 'c'\n  sequence.after('c')           #=> 'a'\n  sequence.after('d')           #=> nil\n\nCREDIT: Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"after(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/core/facets/array/before.rb","line":null,"source":"def after(value)\n  return nil unless include? value\n  self[(index(value).to_i + 1) % length]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#rotate":{"!":"method","declarations":["instance","public"],"path":"Array#rotate","name":"rotate","namespace":"Array","comment":"Rotates an array's elements from back to front n times.\n\n  [1,2,3].rotate      #=> [2,3,1]\n  [2,3,1].rotate      #=> [3,1,2]\n  [3,1,2].rotate      #=> [1,2,3]\n\n  [1,2,3].rotate(3)   #=> [1,2,3]\n\nA negative parameter reverses the order from front to back.\n\n  [1,2,3].rotate(-1)  #=> [3,1,2]\n\nCREDIT: Florian Gross, Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rotate(n=1)","arguments":[{"name":"n","default":"1"}]}],"returns":[],"file":"/lib/core/facets/array/rotate.rb","line":null,"source":"def rotate(n=1)\n  self.dup.rotate!(n)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#rotate!":{"!":"method","declarations":["instance","public"],"path":"Array#rotate!","name":"rotate!","namespace":"Array","comment":"Same as #rotate, but acts in place.\n\n  a = [1,2,3]\n  a.rotate!\n  a  #=> [2,3,1]\n\nCREDIT: Florian Gross, Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rotate!(n=1)","arguments":[{"name":"n","default":"1"}]}],"returns":[],"file":"/lib/core/facets/array/rotate.rb","line":null,"source":"def rotate!(n=1)\n  n = n.to_int\n  return self if (n == 0 or self.empty?)\n  if n < 0\n    n.abs.times{ self.unshift( self.pop ) }\n  else\n    n.abs.times{ self.push( self.shift ) }\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Array#entropy":{"!":"method","declarations":["instance","public"],"path":"Array#entropy","name":"entropy","namespace":"Array","comment":"Shannon's entropy for an array - returns the average\nbits per symbol required to encode the array.\nLower values mean less \"entropy\" - i.e. less unique\ninformation in the array.\n\n  e = %w{ a b c d e e e }.entropy\n\n  (\"%.3f\" % e)  #=> \"2.128\"\n\nCREDIT: Derek","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"entropy()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/entropy.rb","line":null,"source":"def entropy\n  arr = self\n  probHash = arr.probability\n  # -- h is the Shannon entropy of the array\n  h = -1.to_f * probHash.keys.inject(0.to_f) do |sum, i|\n    sum + (probHash[i] * (Math.log(probHash[i])/Math.log(2.to_f)))\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Array#ideal_entropy":{"!":"method","declarations":["instance","public"],"path":"Array#ideal_entropy","name":"ideal_entropy","namespace":"Array","comment":"Returns the maximum possible Shannon entropy of the array\nwith given size assuming that it is an \"order-0\" source\n(each element is selected independently of the next).\n\nCREDIT: Derek","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ideal_entropy()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/entropy.rb","line":null,"source":"def ideal_entropy\n  arr = self\n  unitProb = 1.0.to_f / arr.size.to_f\n  (-1.to_f * arr.size.to_f * unitProb * Math.log(unitProb)/Math.log(2.to_f))\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#round_at":{"!":"method","declarations":["instance","public"],"path":"Numeric#round_at","name":"round_at","namespace":"Numeric","comment":"Conceptually, rounding is expected to apply to floating point numbers.\nHowever it can actually be applied to pretty much any Numeric object.\nFor example, one could round an Integer to the nearest kilo.\n\nSee Float#round_at.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"round_at(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/numeric/round.rb","line":null,"source":"def round_at(*args)\n  to_f.round_at(*args)\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#round_to":{"!":"method","declarations":["instance","public"],"path":"Numeric#round_to","name":"round_to","namespace":"Numeric","comment":"See Float#round_to.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"round_to(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/numeric/round.rb","line":null,"source":"def round_to(*args)\n  to_f.round_to(*args)\nend","language":"ruby","dynamic":null,"tags":{}},"Float":{"!":"class","superclass":"Object","path":"Float","name":"Float","namespace":"","comment":"class Integer\n\n  # See Float#round_at.\n\n  def round_at(*args)\n    to_f.round_at(*args)\n  end\n\n  # See Float#round_to.\n\n  def round_to(*args)\n    to_f.round_to(*args)\n  end\n\nend","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Float#round_at","Float#round_to"],"accessors":[],"files":["/lib/core/facets/numeric/round.rb"],"tags":{}},"Float#round_at":{"!":"method","declarations":["instance","public"],"path":"Float#round_at","name":"round_at","namespace":"Float","comment":"Rounds to the given decimal position.\n\n  4.555.round_at(0)  #=> 5.0\n  4.555.round_at(1)  #=> 4.6\n  4.555.round_at(2)  #=> 4.56\n  4.555.round_at(3)  #=> 4.555\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"round_at(d)","arguments":[{"name":"d"}]}],"returns":[],"file":"/lib/core/facets/numeric/round.rb","line":null,"source":"def round_at( d ) #d=0\n  (self * (10.0 ** d)).round.to_f / (10.0 ** d)\nend","language":"ruby","dynamic":null,"tags":{}},"Float#round_to":{"!":"method","declarations":["instance","public"],"path":"Float#round_to","name":"round_to","namespace":"Float","comment":"Rounds to the nearest _n_th degree.\n\n  4.555.round_to(1)     #=> 5.0\n  4.555.round_to(0.1)   #=> 4.6\n  4.555.round_to(0.01)  #=> 4.56\n  4.555.round_to(0)     #=> 4.555\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"round_to(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/numeric/round.rb","line":null,"source":"def round_to( n ) #n=1\n  return self if n == 0\n  (self * (1.0 / n)).round.to_f / (1.0 / n)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#fx":{"!":"method","declarations":["instance","public"],"path":"Enumerator#fx","name":"fx","namespace":"Enumerator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"fx()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerator/fx.rb","line":null,"source":"def fx\n  Functor.new(&method(:fx_send).to_proc)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerator#fx_send":{"!":"method","declarations":["instance","private"],"path":"Enumerator#fx_send","name":"fx_send","namespace":"Enumerator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"fx_send(op, *a, &b)","arguments":[{"name":"op"},{"name":"*a"}],"block":{"name":"&b"}}],"returns":[],"file":"/lib/core/facets/enumerator/fx.rb","line":null,"source":"def fx_send(op, *a, &b)\n  map{ |e| e.send(op, *a, &b) }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#to_obj":{"!":"method","declarations":["instance","public"],"path":"Module#to_obj","name":"to_obj","namespace":"Module","comment":"Create an instance of Object and extend it with +self+.\n\n  mod = Module.new do\n    def foo; \"foo\"; end\n  end\n\n  obj = mod.to_obj\n\n  obj.foo #=> \"foo\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_obj()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/to_obj.rb","line":null,"source":"def to_obj\n  o = Object.new\n  o.extend self\n  o\nend","language":"ruby","dynamic":null,"tags":{}},"NilClass#to_f":{"!":"method","declarations":["instance","public"],"path":"NilClass#to_f","name":"to_f","namespace":"NilClass","comment":"Allows <tt>nil</tt> to respond to #to_f.\nAlways returns <tt>0</tt>.\n\n  nil.to_f   #=> 0.0\n\nCREDIT: Matz","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_f()","arguments":[]}],"returns":[],"file":"/lib/core/facets/nilclass/to_f.rb","line":null,"source":"def to_f; 0.0; end","language":"ruby","dynamic":null,"tags":{}},"String#splice":{"!":"method","declarations":["instance","public"],"path":"String#splice","name":"splice","namespace":"String","comment":"String#slice is essentially the same as #store.\n\n  a = \"HELLO\"\n  a.splice(1, \"X\")\n  a                #=> \"HXLLO\"\n\nBut it acts like #slice! when given a single argument.\n\n  a = \"HELLO\"\n  a.splice(1)    #=> \"E\"\n  a              #=> \"HLLO\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"splice(idx, sub=nil)","arguments":[{"name":"idx"},{"name":"sub","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/splice.rb","line":null,"source":"def splice(idx, sub=nil)\n  if sub\n    store(idx, sub)\n  else\n    case idx\n    when Range\n      slice!(idx)\n    else\n      slice!(idx,1)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#uniq_by!":{"!":"method","declarations":["instance","public"],"path":"Array#uniq_by!","name":"uniq_by!","namespace":"Array","comment":"Like #uniq, but determines uniqueness based on a given block.\n\n  a = (-5..5).to_a\n  a.uniq_by!{ |i| i*i }\n  a #=> [-5, -4, -3, -2, -1, 0]\n\nAs can be seen in the example, order is significant.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"uniq_by!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/uniq_by.rb","line":null,"source":"def uniq_by! #:yield:\n  h = {}\n  replace( inject([]){|a,x| h[yield(x)] ||= a << x} )\nend","language":"ruby","dynamic":null,"tags":{}},"String#cleave":{"!":"method","declarations":["instance","public"],"path":"String#cleave","name":"cleave","namespace":"String","comment":"Cleave a string. Break a string in two parts at\nthe nearest whitespace.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cleave(threshold=nil, len=nil)","arguments":[{"name":"threshold","default":"nil"},{"name":"len","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/cleave.rb","line":null,"source":"def cleave(threshold=nil, len=nil)\n  l = (len || size / 2)\n  t = threshold || size\n\n  h1 = self[0...l]\n  h2 = self[l..-1]\n\n  i1 = h1.rindex(/\\s/) || 0\n  d1 = (i1 - l).abs\n\n  d2 = h2.index(/\\s/) || l\n  i2 = d2 + l\n\n  d1 = (i1-l).abs\n  d2 = (i2-l).abs\n\n  if [d1, d2].min > t\n    i = t\n  elsif d1 < d2\n    i = i1\n  else\n    i = i2\n  end\n\n  #dup.insert(l, \"\\n\").gsub(/^\\s+|\\s+$/, '')\n  return self[0..i].to_s.strip, self[i+1..-1].to_s.strip\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#equate?":{"!":"method","declarations":["instance","public"],"path":"Kernel#equate?","name":"equate?","namespace":"Kernel","comment":"Broad equality. Checks to see if the object +x+ is in any\nway equal to the reciever, starting with the identity\n#equal?, then #eql?, then #==, and ending with #===.\n\n  1.equate?(1.0)               #=> true\n  \"string\".equate?(\"string\")   #=> true\n  String.equate?(\"string\")     #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"equate?(x)","arguments":[{"name":"x"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/equate.rb","line":null,"source":"def equate?(x)\n  equal?(x) || eql?(x) || self == x || self === x\nend","language":"ruby","dynamic":null,"tags":{}},"Array#nonuniq":{"!":"method","declarations":["instance","public"],"path":"Array#nonuniq","name":"nonuniq","namespace":"Array","comment":"Returns a list of non-unique elements\n\n  [1,1,2,2,3,4,5].nonuniq  #=> [1,2]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"nonuniq()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/nonuniq.rb","line":null,"source":"def nonuniq\n  h1 = {}\n  h2 = {}\n  each {|i|\n    h2[i] = true if h1[i]\n    h1[i] = true\n  }\n  h2.keys\nend","language":"ruby","dynamic":null,"tags":{"author":"Martin DeMello"}},"Array#nonuniq!":{"!":"method","declarations":["instance","public"],"path":"Array#nonuniq!","name":"nonuniq!","namespace":"Array","comment":"Same as `#nonuniq` but acting in place.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"nonuniq!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/nonuniq.rb","line":null,"source":"def nonuniq!\n  h1 = {}\n  h2 = {}\n  each {|i|\n    h2[i] = true if h1[i]\n    h1[i] = true\n  }\n  self.replace(h2.keys)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#duplicates":{"!":"method","declarations":["instance","public"],"path":"Array#duplicates","name":"duplicates","namespace":"Array","comment":"Return list of duplictate elements.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"duplicates(min=2)","arguments":[{"name":"min","default":"2"}]}],"returns":[],"file":"/lib/core/facets/array/nonuniq.rb","line":null,"source":"def duplicates(min=2)\n  h = Hash.new( 0 )\n  each {|i|\n    h[i] += 1\n  }\n  h.delete_if{|_,v| v < min}.keys\nend","language":"ruby","dynamic":null,"tags":{"param":"The minimum number of duplicatation necessary for inclusion.","author":"Thibaut Barrre"}},"Array#occurent":{"!":"method","declarations":["instance","public"],"path":"Array#occurent","name":"occurent","namespace":"Array","comment":"Returns a list of elements that occur +n+ times.\n\n [0,1,1,1,3,0,1,2,4].occurent(3) #=> [1]\n\nIf +n+ is a Range then returns elements that occur a number\nof time within the range.\n\n [0,1,1,1,3,0,1,2,4].occurent(2..4) #=> [0,1]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"occurent(n=2)","arguments":[{"name":"n","default":"2"}]}],"returns":[],"file":"/lib/core/facets/array/nonuniq.rb","line":null,"source":"def occurent(n=2)\n  h = Hash.new( 0 )\n  each do |i|\n    h[i] += 1\n  end\n\n  case n\n  when nil\n    h.delete_if{ |_,v| ! yield(v) }.keys\n  when Range\n    h.delete_if{ |_,v| ! n.include?(v) }.keys\n  else\n    h.delete_if{|_,v| v != n}.keys\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Robert Dober"}},"Module#revise":{"!":"method","declarations":["instance","public"],"path":"Module#revise","name":"revise","namespace":"Module","comment":"Return a new module based on another. This includes the original module\ninto the new revised module.\n\n  module ReviseExample\n    def foo; \"foo\"; end\n  end\n\n  ReviseExample2 = ReviseExample.revise do\n    alias_method :bar, :foo\n  end\n\n  object = Object.new\n  object.extend ReviseExample2\n  object.bar  #=> 'foo'\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#revisal"],"singleton":null,"interfaces":[{"signature":"revise(&blk)","arguments":[],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/module/revise.rb","line":null,"source":"def revise(&blk)\n  base = self\n  nm = Module.new{ include base }\n  nm.class_eval(&blk)\n  nm\nend","language":"ruby","dynamic":null,"tags":{}},"Module#revisal":{"!":"method","declarations":["instance","public"],"path":"Module#revisal","name":"revisal","namespace":"Module","comment":"Return a new module based on another. This includes the original module\ninto the new revised module.\n\n  module ReviseExample\n    def foo; \"foo\"; end\n  end\n\n  ReviseExample2 = ReviseExample.revise do\n    alias_method :bar, :foo\n  end\n\n  object = Object.new\n  object.extend ReviseExample2\n  object.bar  #=> 'foo'\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"revise(&blk)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/revise.rb","line":null,"source":"def revise(&blk)\n  base = self\n  nm = Module.new{ include base }\n  nm.class_eval(&blk)\n  nm\nend","language":"ruby","dynamic":null,"tags":{}},"Class":{"!":"class","superclass":"Object","path":"Class","name":"Class","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Class#to_proc","Class#pathize","Class#singleton?","Class#methodize","Class#subclasses","Class#descendants","Class#preallocate","Class#class_extend"],"accessors":[],"files":["/lib/core/facets/module/revise.rb","/lib/core/facets/class/to_proc.rb","/lib/core/facets/class/pathize.rb","/lib/core/facets/class/singleton.rb","/lib/core/facets/class/methodize.rb","/lib/core/facets/class/subclasses.rb","/lib/core/facets/class/descendants.rb","/lib/core/facets/class/preallocate.rb","/lib/core/facets/module/class_extend.rb"],"tags":{}},"String#indent":{"!":"method","declarations":["instance","public"],"path":"String#indent","name":"indent","namespace":"String","comment":"Indent left or right by n spaces.\n(This used to be called #tab and aliased as #indent.)\n\nCREDIT: Gavin Sinclair, Trans, Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"indent(n, c=' ')","arguments":[{"name":"n"},{"name":"c","default":"' '"}]}],"returns":[],"file":"/lib/core/facets/string/indent.rb","line":null,"source":"def indent(n, c=' ')\n  if n >= 0\n    gsub(/^/, c * n)\n  else\n    gsub(/^#{Regexp.escape(c)}{0,#{-n}}/, \"\")\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#indent!":{"!":"method","declarations":["instance","public"],"path":"String#indent!","name":"indent!","namespace":"String","comment":"Equivalent to String#indent, but modifies the receiver in place.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"indent!(n, c=' ')","arguments":[{"name":"n"},{"name":"c","default":"' '"}]}],"returns":[],"file":"/lib/core/facets/string/indent.rb","line":null,"source":"def indent!(n, c=' ')\n  replace(indent(n,c))\nend","language":"ruby","dynamic":null,"tags":{}},"String#unindent":{"!":"method","declarations":["instance","public"],"path":"String#unindent","name":"unindent","namespace":"String","comment":"Remove excessive indentation. Useful for multi-line strings embeded in\nalready indented code.\n\n  <<-END.unindent\n      ohaie\n        wurld\n  END\n\nOutputs ...\n\n  ohaie\n    wurld\n\nInstead of ...\n\n      ohaie\n        wurld\n\nCREDIT: Noah Gibbs, mynyml","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unindent(size=nil)","arguments":[{"name":"size","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/indent.rb","line":null,"source":"def unindent(size=nil)\n  if size\n    indent(-size)\n  else\n    char = ' '\n    self.scan(/^[\\ \\t]*\\S/) do |m|\n      if size.nil? || m.size < size\n        size = m.size\n        char = m[0...-1]\n      end\n    end\n    size -= 1\n    indent(-size, char)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#unindent!":{"!":"method","declarations":["instance","public"],"path":"String#unindent!","name":"unindent!","namespace":"String","comment":"Equivalent to String#unindent, but modifies the receiver in place.\n\nCREDIT: mynyml","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unindent!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/indent.rb","line":null,"source":"def unindent!\n  self.replace(self.unindent)\nend","language":"ruby","dynamic":null,"tags":{}},"String#unfold":{"!":"method","declarations":["instance","public"],"path":"String#unfold","name":"unfold","namespace":"String","comment":"Unfold paragrpahs.\n\nFIXME: Sometimes adds one too many blank lines. TEST!!!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unfold()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/unfold.rb","line":null,"source":"def unfold\n  blank = false\n  text  = ''\n  split(/\\n/).each do |line|\n    if /\\S/ !~ line\n      text << \"\\n\\n\"\n      blank = true\n    else\n      if /^(\\s+|[*])/ =~ line\n        text << (line.rstrip + \"\\n\")\n      else\n        text << (line.rstrip + \" \")\n      end\n      blank = false\n    end\n  end\n  text = text.gsub(/(\\n){3,}/,\"\\n\\n\")\n  text.rstrip\nend","language":"ruby","dynamic":null,"tags":{}},"String#natcmp":{"!":"method","declarations":["instance","public"],"path":"String#natcmp","name":"natcmp","namespace":"String","comment":"'Natural order' comparison of strings, e.g. ...\n\n  \"my_prog_v1.1.0\" < \"my_prog_v1.2.0\" < \"my_prog_v1.10.0\"\n\nwhich does not follow alphabetically. A secondary\nparameter, if set to _true_, makes the comparison\ncase insensitive.\n\n  \"Hello.1\".natcmp(\"Hello.10\")  #=> -1\n\nTODO: Invert case flag?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"natcmp(str2, caseInsensitive=false)","arguments":[{"name":"str2"},{"name":"caseInsensitive","default":"false"}]}],"returns":[],"file":"/lib/core/facets/string/natcmp.rb","line":null,"source":"def natcmp(str2, caseInsensitive=false)\n  str1 = self.dup\n  str2 = str2.dup\n  compareExpression = /^(\\D*)(\\d*)(.*)$/\n\n  if caseInsensitive\n    str1.downcase!\n    str2.downcase!\n  end\n\n  # -- remove all whitespace\n  str1.gsub!(/\\s*/, '')\n  str2.gsub!(/\\s*/, '')\n\n  while (str1.length > 0) or (str2.length > 0) do\n    # -- extract non-digits, digits and rest of string\n    str1 =~ compareExpression\n    chars1, num1, str1 = $1.dup, $2.dup, $3.dup\n    str2 =~ compareExpression\n    chars2, num2, str2 = $1.dup, $2.dup, $3.dup\n    # -- compare the non-digits\n    case (chars1 <=> chars2)\n      when 0 # Non-digits are the same, compare the digits...\n        # If either number begins with a zero, then compare alphabetically,\n        # otherwise compare numerically\n        if (num1[0] != 48) and (num2[0] != 48)\n          num1, num2 = num1.to_i, num2.to_i\n        end\n        case (num1 <=> num2)\n          when -1 then return -1\n          when 1 then return 1\n        end\n      when -1 then return -1\n      when 1 then return 1\n    end # case\n  end # while\n\n  # -- strings are naturally equal\n  return 0\nend","language":"ruby","dynamic":null,"tags":{"author":"Martin Pool"}},"Array#recurse":{"!":"method","declarations":["instance","public"],"path":"Array#recurse","name":"recurse","namespace":"Array","comment":"Apply a block to array, and recursively apply that block\nto each sub-array or +types+.\n\n  arr = [\"a\", [\"b\", \"c\", nil], nil]\n  arr.recurse{ |a| a.compact! }\n  #=> [\"a\", [\"b\", \"c\"]]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recurse(*types, &block)","arguments":[{"name":"*types"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/recurse.rb","line":null,"source":"def recurse(*types, &block)\n  types = [self.class] if types.empty?\n  a = inject([]) do |array, value|\n    case value\n    when *types\n      array << value.recurse(*types, &block)\n    else\n      array << value\n    end\n    array\n  end\n  yield a\nend","language":"ruby","dynamic":null,"tags":{"yield":""}},"Array#recurse!":{"!":"method","declarations":["instance","public"],"path":"Array#recurse!","name":"recurse!","namespace":"Array","comment":"In place form of #recurse.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recurse!(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/recurse.rb","line":null,"source":"def recurse!(&block)\n  replace(recurse(&block))\nend","language":"ruby","dynamic":null,"tags":{}},"Array#conjoin":{"!":"method","declarations":["instance","public"],"path":"Array#conjoin","name":"conjoin","namespace":"Array","comment":"This is more advanced form of #join. It allows for fine control\nof separators.\n\nNOTE: The old version used to default its separator to \", \" and\ndefault the terminating separator to \" and \". This is no longer\nthe case. You must specifically provide these parameters.\n\nIf no paramters are given, it acts like #join but will a space\nseparator.\n\n  [1,2,3].conjoin\n  #=> \"1 2 3\"\n\nUse comma+space and 'and' on tail.\n\n  [1,2,3].conjoin(', ', ' and ')\n  #=> \"1, 2 and 3\"\n\nUse comma+space and 'or' on tail using :last option.\n\n  [1,2,3].conjoin(', ', :last => ' or ')\n  #=> \"1, 2 or 3\"\n\nUse semicolon+space and ampersand on tail using index.\n\n  [1,2,3].conjoin('; ', -1 => ' & ')\n  #=> \"1; 2 & 3\"\n\nCan take a block to determine separator.\n\n  [1,2,3,4].conjoin{ |i, a, b| i % 2 == 0 ? '.' : '-' }\n  #=> \"1.2-3.4\"\n\nThis makes very esoteric transformation possible.\n\n  [1,1,2,2].conjoin{ |i, a, b| a == b ? '=' : ' != ' }\n  #=> \"1=1 != 2=2\"\n\n  [1,2,3,4].conjoin{ |i, x, y| \"<#{i} #{x} #{y}>\" }\n  #=> \"1<0 1 2>2<1 2 3>3<2 3 4>4\"\n\nThere are also spacing options. Providing the :space option\npads the separators.\n\n  [1,2,3].conjoin(',', '&', :space=>2)\n  #=> \"1  ,  2  &  3\"\n\nAnd the :spacer option can set an alternate spacing string.\n\n  [1,2,3].conjoin('|', '>', :space=>2, :spacer=>'-')\n  #=> \"1--|--2-->--3\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"conjoin(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/conjoin.rb","line":null,"source":"def conjoin(*args, &block)\n  return first.to_s if size < 2\n\n  options = (Hash===args.last) ? args.pop : {}\n\n  spacing = options.delete(:space)  || 0\n  spacer  = options.delete(:spacer) || \" \"\n  space   = spacer * spacing.to_i\n\n  sep = []\n\n  if block_given?\n    (size - 1).times do |i|\n      sep << space + yield(i, *slice(i,2)) + space\n    end\n  else\n    separator   = args.shift || \" \"\n    options[-1] = args.shift if args.first\n\n    options[0]  = options.delete(:first) if options.key?(:first)\n    options[-1] = options.delete(:last)  if options.key?(:last)\n\n    separator = space + separator + space\n\n    sep = [separator] * (size - 1)\n\n    options.each{|i, s| sep[i] = space + s + space}\n  end\n  zip(sep).join\nend","language":"ruby","dynamic":null,"tags":{}},"String#margin":{"!":"method","declarations":["instance","public"],"path":"String#margin","name":"margin","namespace":"String","comment":"Provides a margin controlled string.\n\n  x = %Q{\n        | This\n        |   is\n        |     margin controlled!\n        }.margin\n\nNOTE: This may still need a bit of tweaking.\n\nTODO: describe its limits and caveats and edge cases\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"margin(n=0)","arguments":[{"name":"n","default":"0"}]}],"returns":[],"file":"/lib/core/facets/string/margin.rb","line":null,"source":"def margin(n=0)\n  #d = /\\A.*\\n\\s*(.)/.match( self )[1]\n  #d = /\\A\\s*(.)/.match( self)[1] unless d\n  d = ((/\\A.*\\n\\s*(.)/.match(self)) ||\n      (/\\A\\s*(.)/.match(self)))[1]\n  return '' unless d\n  if n == 0\n    gsub(/\\n\\s*\\Z/,'').gsub(/^\\s*[#{d}]/, '')\n  else\n    gsub(/\\n\\s*\\Z/,'').gsub(/^\\s*[#{d}]/, ' ' * n)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#assign":{"!":"method","declarations":["instance","public"],"path":"Kernel#assign","name":"assign","namespace":"Kernel","comment":"Assign via writer using arguments, hash or associative array.\n\nUsing name-value arguments:\n\n  object = Object.new\n\n  object.assign(:a, 1)\n  object.assign(:b, 2)\n\nUsing a hash:\n\n  object.assign(:a => 1, :b => 2)\n\nUse an associative array:\n\n  object.assign([[:a, 1], [:b, 2]])\n\nThese are all equivalent to:\n\n  object.a = 1 if object.respond_to?(:a=)\n  object.b = 2 if object.respond_to?(:b=)\n\nUsing an associative array instead of a hash guarantees order of assignment\nfor older versions of Ruby (< 1.8.7).\n\nTODO: Should this be called #set instead? Consider Module#set in this\nquestion, and also #set_from as the alias of #assign_from.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"assign(data=nil, value=NA)","arguments":[{"name":"data","default":"nil"},{"name":"value","default":"NA"}]}],"returns":[],"file":"/lib/core/facets/kernel/assign.rb","line":null,"source":"def assign(data=nil, value=NA)\n  return self unless data\n\n  if value==NA\n    data.each do |(k,v)|\n      __send__(\"#{k}=\", v) if respond_to?(\"#{k}=\")\n    end\n  else\n    __send__(\"#{data}=\", value) if respond_to?(\"#{data}=\")\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#assign_from":{"!":"method","declarations":["instance","public"],"path":"Kernel#assign_from","name":"assign_from","namespace":"Kernel","comment":"Set attribute writers using like readers from another object.\n\n  class AssignExample\n    attr_accessor :a, :b\n    def initialize(a, b)\n       @a, @b = a, b\n    end\n  end\n\n  obj1 = AssignExample.new(1,2)\n  obj2 = AssignExample.new(3,4)\n\n  obj2.assign_from(obj1, :a, :b)\n\n  obj2.a  #=> 1\n  obj2.b  #=> 2\n\nTODO: Should this be called #set_from ?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"assign_from(obj, *fields)","arguments":[{"name":"obj"},{"name":"*fields"}]}],"returns":[],"file":"/lib/core/facets/kernel/assign.rb","line":null,"source":"def assign_from(obj, *fields)\n  fields.flatten.each do |k|\n    send(\"#{k}=\", obj.__send__(\"#{k}\"))  #if self.respond_to?(\"#{k}=\") && obj.respond_to?(\"#{k}\")\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#divide":{"!":"method","declarations":["instance","public"],"path":"String#divide","name":"divide","namespace":"String","comment":"Breaks a string up into an array based on a regular expression.\nSimilar to scan, but includes the matches.\n\n  s = \"<p>This<b>is</b>a test.</p>\"\n  s.divide( /\\<.*?\\>/ )\n  #=> [\"<p>This\", \"<b>is\", \"</b>a test.\", \"</p>\"]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"divide(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/core/facets/string/divide.rb","line":null,"source":"def divide( re )\n  re2 = /#{re}.*?(?=#{re}|\\Z)/\n  scan(re2) #{re}(?=#{re})/)\nend","language":"ruby","dynamic":null,"tags":{}},"Range#overlap?":{"!":"method","declarations":["instance","public"],"path":"Range#overlap?","name":"overlap?","namespace":"Range","comment":"Do two ranges overlap?\n\nCREDIT: Daniel Schierbeck, Brandon Keepers","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"overlap?(other)","arguments":[{"name":"other"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/range/overlap.rb","line":null,"source":"def overlap?(other)\n  include?(other.first) or other.include?(first)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#product":{"!":"method","declarations":["instance","public"],"path":"Array#product","name":"product","namespace":"Array","comment":"Provides the cartesian product of two or more arrays.\n\n  a = [1,2].product([4,5])\n  a  #=> [[1, 4],[1, 5],[2, 4],[2, 5]]\n\nCREDIT: Thomas Hafner","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"product(*enums)","arguments":[{"name":"*enums"}]}],"returns":[],"file":"/lib/core/facets/array/product.rb","line":null,"source":"def product(*enums)\n  enums.unshift self\n  result = [[]]\n  while [] != enums\n    t, result = result, []\n    b, *enums = enums\n    t.each do |a|\n      b.each do |n|\n        result << a + [n]\n      end\n    end\n  end\n  result\nend","language":"ruby","dynamic":null,"tags":{}},"String#-":{"!":"method","declarations":["instance","public"],"path":"String#-","name":"-","namespace":"String","comment":"Removes occurances of a string or regexp.\n\n  (\"HELLO HELLO\" - \"LL\")    #=> \"HEO HEO\"\n\nCREDIT: Benjamin David Oakes","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"-(pattern)","arguments":[{"name":"pattern"}]}],"returns":[],"file":"/lib/core/facets/string/op_sub.rb","line":null,"source":"def -(pattern)\n  self.gsub(pattern, '')\nend","language":"ruby","dynamic":null,"tags":{}},"Range#combine":{"!":"method","declarations":["instance","public"],"path":"Range#combine","name":"combine","namespace":"Range","comment":"Combine ranges.\n\n  (1..2).combine(2..4)   #=> [1..4]\n  (1..2).combine(3..4)   #=> [1..2, 3..4]\n\nTODO: Incorporate end-sentinal inclusion vs. exclusion.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"combine(*intervals)","arguments":[{"name":"*intervals"}]}],"returns":[],"file":"/lib/core/facets/range/combine.rb","line":null,"source":"def combine(*intervals)\n  Range.combine(self, *intervals)\nend","language":"ruby","dynamic":null,"tags":{}},"Range.combine":{"!":"method","declarations":["class","public"],"path":"Range.combine","name":"combine","namespace":"Range","comment":"Combine intervals.\n\n  Range.combine(1..2, 2..4)   #=> [1..4]\n  Range.combine(1..2, 3..4)   #=> [1..2, 3..4]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"combine(.)","arguments":[{"name":"*intervals"}]}],"returns":[],"file":"/lib/core/facets/range/combine.rb","line":null,"source":"def self.combine(*intervals)\n  intype = intervals.first.class\n  result = []\n\n  intervals = intervals.collect do |i|\n    [i.first, i.last]\n  end\n\n  intervals.sort.each do |(from, to)|  #inject([]) do |result,\n    if result.empty? or from > result.last[1]\n      result << [from, to]\n    elsif to > result.last[1]\n      result.last[1] = to\n    end\n    #result\n  end\n\n  if intype <= Range\n    result.collect{ |i| ((i.first)..(i.last)) }\n  else\n    result\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#lchomp":{"!":"method","declarations":["instance","public"],"path":"String#lchomp","name":"lchomp","namespace":"String","comment":"Left chomp.\n\n  \"help\".lchomp(\"h\")  #=> \"elp\"\n  \"help\".lchomp(\"k\")  #=> \"help\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lchomp(match)","arguments":[{"name":"match"}]}],"returns":[],"file":"/lib/core/facets/string/lchomp.rb","line":null,"source":"def lchomp(match)\n  if index(match) == 0\n    self[match.size..-1]\n  else\n    self.dup\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#lchomp!":{"!":"method","declarations":["instance","public"],"path":"String#lchomp!","name":"lchomp!","namespace":"String","comment":"In-place left chomp.\n\n  \"help\".lchomp(\"h\")  #=> \"elp\"\n  \"help\".lchomp(\"k\")  #=> \"help\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lchomp!(match)","arguments":[{"name":"match"}]}],"returns":[],"file":"/lib/core/facets/string/lchomp.rb","line":null,"source":"def lchomp!(match)\n  if index(match) == 0\n    self[0...match.size] = ''\n    self\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#_extend":{"!":"method","declarations":["instance","private"],"path":"Kernel#_extend","name":"_extend","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"_extend","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/extend.rb","line":null,"source":"alias_method :_extend, :extend","language":"ruby","dynamic":null,"tags":{}},"Kernel#extend":{"!":"method","declarations":["instance","public"],"path":"Kernel#extend","name":"extend","namespace":"Kernel","comment":"Extend an object with a module.\n\nIf a block is given, it will be evaluated into an anonymous\nmodule and used to extend the object.\n\n  obj = Object.new\n\n  obj.extend do\n    def foo; \"foo\"; end\n  end\n\n  obj.foo  #=> \"foo\"\n\nNOTE: This is one of the few core overrides in Facets.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"extend(*mod, &blk)","arguments":[{"name":"*mod"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/extend.rb","line":null,"source":"def extend(*mod, &blk)\n  _extend(*mod) unless mod.empty?\n  _extend Module.new(&blk) if blk\n  self\nend","language":"ruby","dynamic":null,"tags":{"author":"Marco Otte-Witte (bug fix)"}},"String#squish":{"!":"method","declarations":["instance","public"],"path":"String#squish","name":"squish","namespace":"String","comment":"Returns the string, first removing all whitespace on both ends of\nthe string, and then changing remaining consecutive whitespace\ngroups into one space each.\n\n  %{ Multi-line\n     string }.squish                   # => \"Multi-line string\"\n\n  \" foo   bar    \\n   \\t   boo\".squish # => \"foo bar boo\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"squish()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/squish.rb","line":null,"source":"def squish\n  dup.squish!\nend","language":"ruby","dynamic":null,"tags":{}},"String#squish!":{"!":"method","declarations":["instance","public"],"path":"String#squish!","name":"squish!","namespace":"String","comment":"Performs a destructive squish. See String#squish.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"squish!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/squish.rb","line":null,"source":"def squish!\n  strip!\n  gsub!(/\\s+/, ' ')\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Class#to_proc":{"!":"method","declarations":["instance","public"],"path":"Class#to_proc","name":"to_proc","namespace":"Class","comment":"Convert instatiation of a class into a Proc.\n\n  class Person\n    def initialize(name)\n      @name = name\n    end\n\n    def inspect\n      @name.to_str\n    end\n  end\n\n  persons = %w(john bob jane hans).map(&Person)\n\n  persons.map{ |p| p.inspect }  #=> ['john', 'bob', 'jane', 'hans']\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_proc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/class/to_proc.rb","line":null,"source":"def to_proc\n  proc{|*args| new(*args)}\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#/":{"!":"method","declarations":["instance","public"],"path":"Symbol#/","name":"/","namespace":"Symbol","comment":"Join with _path_ as a file path.\n\n* path - The path component(s) to append. [#to_s]\n\nExamples\n\n  (:merb / \"string\")   #=> \"merb/string\"\n  (:merb / :symbol)    #=> \"merb/symbol\"\n\nReturns String of the receiver (as a path string), concatenated\nwith _path_.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"/(path)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/symbol/op_div.rb","line":null,"source":"def /(path)\n  File.join(to_s, path.to_s)\nend","language":"ruby","dynamic":null,"tags":{}},"String#/":{"!":"method","declarations":["instance","public"],"path":"String#/","name":"/","namespace":"String","comment":"Treats +self+ and +path+ as representations\nof pathnames, joining thme together as a\nsingle path.\n\n  ('home' / 'trans')  #=> 'home/trans'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"/(path)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/string/op_div.rb","line":null,"source":"def /(path)\n  File.join(self, path.to_s)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#method!":{"!":"method","declarations":["instance","public"],"path":"Kernel#method!","name":"method!","namespace":"Kernel","comment":"Easy access to method as object, and they retain state.\n\n  def hello\n    puts \"Hello World!\"\n  end\n\n  m1 = method!(:hello)\n\n  def m1.annotate\n    \"simple example\"\n  end\n\n  m2 = method!(:hello)\n  m2.annotate  #=> \"simple example\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method!(s)","arguments":[{"name":"s"}]}],"returns":[],"file":"/lib/core/facets/kernel/method.rb","line":null,"source":"def method!(s)\n  #( @__methods__ ||= {} )[s.to_sym] ||= method(s)\n  $FIRST_CLASS_METHODS[self][s.to_sym] ||= method(s)\nend","language":"ruby","dynamic":null,"tags":{}},"File.rootname":{"!":"method","declarations":["class","public"],"path":"File.rootname","name":"rootname","namespace":"File","comment":"Returns only the first portion of the directory of\na file path name.\n\n  File.rootname('lib/jump.rb')  #=> 'lib'\n  File.rootname('/jump.rb')     #=> '/'\n  File.rootname('jump.rb')      #=> '.'\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rootname(.)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/file/rootname.rb","line":null,"source":"def self.rootname(path)\n  # -- this should be fairly robust\n  path_re = Regexp.new('[' + Regexp.escape(File::Separator + %q{\\/}) + ']')\n\n  head, tail = path.split(path_re, 2)\n  return '.' if path == head\n  return '/' if head.empty?\n  return head\nend","language":"ruby","dynamic":null,"tags":{}},"Class#pathize":{"!":"method","declarations":["instance","public"],"path":"Class#pathize","name":"pathize","namespace":"Class","comment":"Converts a class name to a unix path.\n\n  module ::Example\n    class PathizeExample\n    end\n  end\n\n  Example::PathizeExample.pathize  #=> \"example/pathize_example\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pathize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/class/pathize.rb","line":null,"source":"def pathize\n  name.pathize\nend","language":"ruby","dynamic":null,"tags":{}},"File.sanitize":{"!":"method","declarations":["class","public"],"path":"File.sanitize","name":"sanitize","namespace":"File","comment":"Cleans up a filename to ensure it will work on a filesystem.\n\n  File.sanitize(\"yo+baby!\")   #=> 'yo+baby_'\n  File.sanitize(\".what&up\")  #=> '.what_up'\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sanitize(.)","arguments":[{"name":"filename"}]}],"returns":[],"file":"/lib/core/facets/file/sanitize.rb","line":null,"source":"def self.sanitize(filename)\n  filename = File.basename(filename.gsub(\"\\\\\", \"/\")) # work-around for IE\n  filename.gsub!(/[^a-zA-Z0-9\\.\\-\\+_]/,\"_\")\n  filename = \"_#{filename}\" if filename =~ /^\\.+$/\n  filename\nend","language":"ruby","dynamic":null,"tags":{}},"FileTest":{"!":"module","path":"FileTest","name":"FileTest","namespace":"","comment":"","format":"rdoc","constants":["FileTest::SEPARATOR_PATTERN"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["FileTest#safe?","FileTest#root?","FileTest#contains?","FileTest#absolute?","FileTest#relative?","FileTest#chop_basename"],"accessors":[],"files":["/lib/core/facets/filetest/safe.rb","/lib/core/facets/filetest/root.rb","/lib/core/facets/filetest/contains.rb","/lib/core/facets/filetest/relative.rb","/lib/core/facets/filetest/separator_pattern.rb"],"tags":{}},"FileTest::SEPARATOR_PATTERN":{"!":"constant","path":"FileTest::SEPARATOR_PATTERN","name":"SEPARATOR_PATTERN","namespace":"FileTest","comment":"","format":"rdoc","value":"(\n  if File::ALT_SEPARATOR\n    /[#{Regexp.quote File::ALT_SEPARATOR}#{Regexp.quote File::SEPARATOR}]/\n  else\n    /#{Regexp.quote File::SEPARATOR}/\n  end\n).freeze","tags":{},"files":["/lib/core/facets/filetest/separator_pattern.rb"]},"FileTest#safe?":{"!":"method","declarations":["instance","public"],"path":"FileTest#safe?","name":"safe?","namespace":"FileTest","comment":"Is a path considered reasonably \"safe\"?\n\nDo not mistake this for a perfect solution!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"safe?(path)","arguments":[{"name":"path"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/filetest/safe.rb","line":null,"source":"def safe?(path)\n  case path\n  when /\\A(#{SEPARATOR_PATTERN}|\\~)(#{SEPARATOR_PATTERN}|\\*)+/\n    false\n  else\n    true\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"FileTest#root?":{"!":"method","declarations":["instance","public"],"path":"FileTest#root?","name":"root?","namespace":"FileTest","comment":"Is the specified directory the root directory?\n\nCREDIT: Jeffrey Schwab","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"root?(dir=nil)","arguments":[{"name":"dir","default":"nil"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/filetest/root.rb","line":null,"source":"def root?(dir=nil)\n  pth = File.expand_path(dir||Dir.pwd)\n  return true if pth == '/'\n  return true if pth =~ /^(\\w:)?\\/$/\n  false\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#thrown?":{"!":"method","declarations":["instance","public"],"path":"Symbol#thrown?","name":"thrown?","namespace":"Symbol","comment":"Does the block throw the symbol?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"thrown?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/symbol/thrown.rb","line":null,"source":"def thrown?\n  catch(self) do\n    begin\n      yield\n      true\n    rescue ArgumentError => err     # 1.9 exception\n      false  #msg += \", not #{err.message.split(/ /).last}\"\n    rescue NameError => err         # 1.8 exception\n      false  #msg += \", not #{err.name.inspect}\"\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash.new_with":{"!":"method","declarations":["class","public"],"path":"Hash.new_with","name":"new_with","namespace":"Hash","comment":"Instantiate a new hash with a default\nvalue determined by the block.\n\nHash.new_with{ [] } \n\nCREDIT: Pit Capitan","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"new_with(.)","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/new_with.rb","line":null,"source":"def self.new_with #:yield:\n  new { |h, k| h[k] = yield }\nend","language":"ruby","dynamic":null,"tags":{}},"Dir.multiglob":{"!":"method","declarations":["class","public"],"path":"Dir.multiglob","name":"multiglob","namespace":"Dir","comment":"Like +glob+ but can take multiple patterns.\n\n  Dir.multiglob('tmp/*.rb', 'tmp/*.py')\n\nRather then constants for options multiglob accepts a trailing options\nhash of symbol keys...\n\n  :noescape    File::FNM_NOESCAPE\n  :casefold    File::FNM_CASEFOLD\n  :pathname    File::FNM_PATHNAME\n  :dotmatch    File::FNM_DOTMATCH\n  :strict      File::FNM_PATHNAME && File::FNM_DOTMATCH\n\nIt also has an option for recurse...\n\n  :recurse     Recurively include contents of directories.\n\nFor example\n\n  Dir.multiglob('tmp/*', :recurse => true)\n\nwould have the same result as\n\n  Dir.multiglob('tmp/**/*')","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiglob(.)","arguments":[{"name":"*patterns"}]}],"returns":[],"file":"/lib/core/facets/dir/multiglob.rb","line":null,"source":"def self.multiglob(*patterns)\n  options  = (Hash === patterns.last ? patterns.pop : {})\n\n  if options.delete(:recurse)\n    ##patterns += patterns.collect{ |f| File.join(f, '**', '**') }\n    multiglob_r(*patterns)\n  end\n\n  bitflags = 0\n  bitflags |= File::FNM_NOESCAPE if options[:noescape]\n  bitflags |= File::FNM_CASEFOLD if options[:casefold]\n  bitflags |= File::FNM_PATHNAME if options[:pathname] or options[:strict]\n  bitflags |= File::FNM_DOTMATCH if options[:dotmatch] or options[:strict]\n\n  patterns = [patterns].flatten.compact\n\n  if options[:recurse]\n    patterns += patterns.collect{ |f| File.join(f, '**', '**') }\n  end\n\n  files = []\n  files += patterns.collect{ |pattern| Dir.glob(pattern, bitflags) }.flatten.uniq\n\n  return files\nend","language":"ruby","dynamic":null,"tags":{}},"Dir.multiglob_r":{"!":"method","declarations":["class","public"],"path":"Dir.multiglob_r","name":"multiglob_r","namespace":"Dir","comment":"The same as +multiglob+, but recusively includes directories.\n\n  Dir.multiglob_r('tmp')\n\nis equivalent to\n\n  Dir.multiglob('tmp', :recurse=>true)\n\nThe effect of which is\n\n  Dir.multiglob('tmp', 'tmp/**/**')","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiglob_r(.)","arguments":[{"name":"*patterns"}]}],"returns":[],"file":"/lib/core/facets/dir/multiglob.rb","line":null,"source":"def self.multiglob_r(*patterns)\n  options = Hash === patterns.last ? patterns.pop : {}\n  matches = multiglob(*patterns)\n  directories = matches.select{ |m| File.directory?(m) }\n  matches += directories.map{ |d| multiglob_r(File.join(d, '**'), options) }.flatten\n  matches.uniq\n  ##options = (Hash === patterns.last ? patterns.pop : {})\n  ##options[:recurse] = true\n  ##patterns << options\n  ##multiglob(*patterns)\nend","language":"ruby","dynamic":null,"tags":{}},"Regexp#+":{"!":"method","declarations":["instance","public"],"path":"Regexp#+","name":"+","namespace":"Regexp","comment":"Add regular expressions.\n\n  /a/ + /b/ == /(?-mix:a)(?-mix:b)/\n\nFunctionally equivalent to:\n\n  /ab/\n\nCREDIT: Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"+(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/regexp/op_add.rb","line":null,"source":"def +(other)\n  other = Regexp.escape(other) if other.is_a?(String)\n  /#{self}#{other}/\nend","language":"ruby","dynamic":null,"tags":{}},"Time#round_to":{"!":"method","declarations":["instance","public"],"path":"Time#round_to","name":"round_to","namespace":"Time","comment":"Round time at the nearest range (in seconds).\n\n  t1 = Time.now\n  t2 = t1.round_to(60*60)\n  t2.min #=> 0\n  t2.sec #=> 0\n\nTODO: What about `round(:minute)`?\n\nTODO: Fractional seconds should round the usec.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"round_to(seconds)","arguments":[{"name":"seconds"}]}],"returns":[],"file":"/lib/core/facets/time/round_to.rb","line":null,"source":"def round_to(seconds)\n  (self + seconds / 2.0).trunc(seconds)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#traverse":{"!":"method","declarations":["instance","public"],"path":"Hash#traverse","name":"traverse","namespace":"Hash","comment":"Returns a new hash created by traversing the hash and its subhashes,\nexecuting the given block on the key and value. The block should\nreturn a 2-element array of the form +[key, value]+.\n\n  h = {\"A\"=>\"A\", \"B\"=>\"B\", \"C\"=>{\"X\"=>\"X\"}}\n\n  g = h.traverse{ |k,v| [k.downcase, v] }\n\n  g  #=> {\"a\"=>\"A\", \"b\"=>\"B\", \"c\"=>{\"x\"=>\"X\"}}\n\nNOTE: Hash#traverse is the same as `recursive.graph` and\nmight be deprecated in the future (if it ever works!)\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"traverse(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/traverse.rb","line":null,"source":"def traverse(&block)\n  inject({}) do |h,(k,v)|\n    if Hash === v\n      v = v.traverse(&block)\n    elsif v.respond_to?(:to_hash)\n      v = v.to_hash.traverse(&block)\n    end\n    nk, nv = block.call(k,v)\n    h[nk] = nv\n    h\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#traverse!":{"!":"method","declarations":["instance","public"],"path":"Hash#traverse!","name":"traverse!","namespace":"Hash","comment":"In place version of traverse, which traverses the hash and its\nsubhashes, executing the given block on the key and value.\n\n  h = { \"A\"=>\"A\", \"B\"=>\"B\" }\n\n  h.traverse!{ |k,v| [k.downcase, v] }\n\n  h  #=> { \"a\"=>\"A\", \"b\"=>\"B\" }\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"traverse!(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/traverse.rb","line":null,"source":"def traverse!(&block)\n  replace(traverse(&block))\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#caller":{"!":"method","declarations":["instance","public"],"path":"Binding#caller","name":"caller","namespace":"Binding","comment":"Returns the call stack, same format as Kernel#caller()","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"caller(skip=0)","arguments":[{"name":"skip","default":"0"}]}],"returns":[],"file":"/lib/core/facets/binding/caller.rb","line":null,"source":"def caller( skip=0 )\n  eval(\"caller(#{skip})\")\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#__LINE__":{"!":"method","declarations":["instance","public"],"path":"Binding#__LINE__","name":"__LINE__","namespace":"Binding","comment":"Return the line number on which the binding was created.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__LINE__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/caller.rb","line":null,"source":"def __LINE__\n  Kernel.eval(\"__LINE__\", self)\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#__FILE__":{"!":"method","declarations":["instance","public"],"path":"Binding#__FILE__","name":"__FILE__","namespace":"Binding","comment":"Returns file name in which the binding was created.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__FILE__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/caller.rb","line":null,"source":"def __FILE__\n  Kernel.eval(\"__FILE__\", self)\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#__DIR__":{"!":"method","declarations":["instance","public"],"path":"Binding#__DIR__","name":"__DIR__","namespace":"Binding","comment":"Return the directory of the file in which the binding was created.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__DIR__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/caller.rb","line":null,"source":"def __DIR__  \n  File.dirname(self.__FILE__)\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#__method__":{"!":"method","declarations":["instance","public"],"path":"Binding#__method__","name":"__method__","namespace":"Binding","comment":"Retreive the current running method.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__method__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/caller.rb","line":null,"source":"def __method__\n  Kernel.eval(\"__method__\", self)\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#__callee__":{"!":"method","declarations":["instance","public"],"path":"Binding#__callee__","name":"__callee__","namespace":"Binding","comment":"Retreive the current running method.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__callee__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/caller.rb","line":null,"source":"def __callee__\n  Kernel.eval(\"__callee__\", self)\nend","language":"ruby","dynamic":null,"tags":{}},"Method":{"!":"class","superclass":"Object","path":"Method","name":"Method","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["Method::Composition"],"methods":["Method#memoize","Method#*","Method#^"],"accessors":[],"files":["/lib/core/facets/method/memoize.rb","/lib/core/facets/method/composition.rb"],"tags":{}},"Method#memoize":{"!":"method","declarations":["instance","public"],"path":"Method#memoize","name":"memoize","namespace":"Method","comment":"Memoize a method by defining a singleton override.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"memoize(value)","arguments":[{"name":"value"}]}],"returns":[],"file":"/lib/core/facets/method/memoize.rb","line":null,"source":"def memoize(value)\n  singleton = (class << receiver; self; end)\n  singleton.__send__(:define_method, name){ value }\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/method/memoize'"}},"File.atomic_id":{"!":"method","declarations":["class","public"],"path":"File.atomic_id","name":"atomic_id","namespace":"File","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"atomic_id(.)","arguments":[]}],"returns":[],"file":"/lib/core/facets/file/atomic_id.rb","line":null,"source":"def self.atomic_id\n  @atomic_id ||= 0\n  @atomic_id += 1\nend","language":"ruby","dynamic":null,"tags":{}},"File.read_list":{"!":"method","declarations":["class","public"],"path":"File.read_list","name":"read_list","namespace":"File","comment":"Reads in a file, removes blank lines and removes lines starting\nwith '#' and then returns an array of all the remaining lines.\n\nThr remark indicator can be overridden via the +:omit:+ option, which\ncan be a regualar expression or a string that is match against the\nstart of a line.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"read_list(.)","arguments":[{"name":"filepath"},{"name":"options","default":"{}"}]}],"returns":[],"file":"/lib/core/facets/file/read_list.rb","line":null,"source":"def self.read_list(filepath, options={})\n  chomp = options[:chomp]\n  omit  = case options[:omit]\n          when Regexp\n            omit\n          when nil\n            /^\\s*\\#/\n          else\n            /^\\s*#{Regexp.escape(omit)}/\n          end\n\n  list = []\n  readlines(filepath).each do |line|\n    line = line.strip.chomp(chomp)\n    next if line.empty?\n    next if omit === line\n    list << line\n  end\n  list\nend","language":"ruby","dynamic":null,"tags":{}},"Dir#each_child":{"!":"method","declarations":["instance","public"],"path":"Dir#each_child","name":"each_child","namespace":"Dir","comment":"Like #each, except the \".\" and \"..\" special files are ignored.\nYou can use +ignore+ to override '.' and '..' and ignore \nother entries via a exact match or regular expression.\n\nCREDIT: Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_child(*ignore)","arguments":[{"name":"*ignore"}]}],"returns":[],"file":"/lib/core/facets/dir/each_child.rb","line":null,"source":"def each_child(*ignore)\n  ignore = ['.', '..'] if ignore.empty?\n  each do |file|\n    yield file unless ignore.any?{ |i| i === file }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#pathize":{"!":"method","declarations":["instance","public"],"path":"String#pathize","name":"pathize","namespace":"String","comment":"Transforms a namespace, i.e. a class or module name, into a viable \nfile path.\n\n  \"ExamplePathize\".pathize           #=> \"example_pathize\"\n  \"ExamplePathize::Example\".pathize  #=> \"example_pathize/example\"\n\nCompare this method to {String#modulize) and {String#methodize).","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pathize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/pathize.rb","line":null,"source":"def pathize\n  gsub(/([A-Z]+)([A-Z])/,'\\1_\\2').\n  gsub(/([a-z])([A-Z])/,'\\1_\\2').\n  gsub('__','/').\n  gsub('::','/').\n  gsub(/\\s+/, '').                # spaces are bad form\n  gsub(/[?%*:|\"<>.]+/, '').   # reserved characters\n  downcase\nend","language":"ruby","dynamic":null,"tags":{}},"Module#pathize":{"!":"method","declarations":["instance","public"],"path":"Module#pathize","name":"pathize","namespace":"Module","comment":"Converts a class name to a unix path.\n\n  module ::ExamplePathize\n    module Example\n    end\n  end\n\n  ExamplePathize.pathize           #=> \"example_pathize\"\n  ExamplePathize::Example.pathize  #=> \"example_pathize/example\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pathize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/pathize.rb","line":null,"source":"def pathize\n  name.pathize\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#one?":{"!":"method","declarations":["instance","public"],"path":"Enumerable#one?","name":"one?","namespace":"Enumerable","comment":"Enumerable#one? returns +true+ if and only if <em>exactly one</em>\nelement in the collection satisfies the given predicate.\n\nIf no predicate is provided, Enumerable#one? returns +true+ if\nand only if <em>exactly one</em> element has a true value\n(i.e. not +nil+ or +false+).\n\n  [].one?                      # => false\n  [nil].one?                   # => false\n  [5].one?                     # => true\n  [5,8,9].one?                 # => false\n  (1...10).one? { |n| n == 5 } # => true\n  (1...10).one? { |n| n < 5 }  # => false\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"one?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/enumerable/one.rb","line":null,"source":"def one?  # :yield: e\n  matches = 0\n  if block_given?\n    self.each do |e|\n      if yield(e)\n        matches += 1\n        return false if matches > 1\n      end\n    end\n    return (matches == 1)\n  else\n    one? { |e| e }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#__DIR__":{"!":"method","declarations":["instance","public"],"path":"Kernel#__DIR__","name":"__DIR__","namespace":"Kernel","comment":"Similar to __FILE__, __DIR__ provides the directory\npath to the current executing script.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__DIR__(*paths)","arguments":[{"name":"*paths"}]}],"returns":[],"file":"/lib/core/facets/kernel/__dir__.rb","line":null,"source":"def __DIR__(*paths)\n  c = caller.first\n  return nil unless c.rindex(/:\\d+(:in `.*')?$/)\n  file = $` # File.dirname(c)\n  return nil if /\\A\\((.*)\\)/ =~ file # eval, etc.\n  #File.expand_path(File.join(File.dirname(file), paths))\n  File.join(File.dirname(file), paths)\nend","language":"ruby","dynamic":null,"tags":{}},"Object#replace":{"!":"method","declarations":["instance","public"],"path":"Object#replace","name":"replace","namespace":"Object","comment":"Replace state of object with the state of another object of the\nsame class (or superclass).\n\n  class ReplaceExample\n    attr_reader :a, :b\n    def initialize(a,b)\n      @a, @b = a, b\n    end\n  end\n\n  obj1 = ReplaceExample.new(1,2)\n  obj1.a  #=> 1\n  obj1.b  #=> 2\n\n  obj2 = ReplaceExample.new(3,4)\n  obj2.a  #=> 3\n  obj2.b  #=> 4\n\n  obj1.replace(obj2)\n  obj1.a  #=> 3\n  obj1.b  #=> 4\n\nThis is very similar to <code>instance.update</code>, but it is limited\nby the class of objects, in the same manner as Array#replace.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"replace(source)","arguments":[{"name":"source"}]}],"returns":[],"file":"/lib/core/facets/object/replace.rb","line":null,"source":"def replace(source)\n  raise ArgumentError, \"not a #{self.class} -- #{source}\" unless source.is_a?(self.class)\n  instance_variables.each do |iv|\n    instance_variable_set(iv, source.instance_variable_get(iv))\n  end\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Struct#replace":{"!":"method","declarations":["instance","public"],"path":"Struct#replace","name":"replace","namespace":"Struct","comment":"Struct#replace can take any +source+ that responds to #each_pair.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"replace(source)","arguments":[{"name":"source"}]}],"returns":[],"file":"/lib/core/facets/object/replace.rb","line":null,"source":"def replace(source)\n  source.each_pair{ |k,v| send(k.to_s + \"=\", v) }\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#sum":{"!":"method","declarations":["instance","public"],"path":"Enumerable#sum","name":"sum","namespace":"Enumerable","comment":"Uses #+ to sum the enumerated elements.\n\n  [1,2,3].sum  #=> 6\n  [3,3,3].sum  #=> 9","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"sum(identity=0, &block)","arguments":[{"name":"identity","default":"0"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/sum.rb","line":null,"source":"def sum(identity=0, &block)\n  if block_given?\n    map(&block).sum(identity)\n  else\n    inject{ |sum, element| sum + element } || identity\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Dawid Marcin Grzesiak (bug fix)"}},"Symbol#to_proc":{"!":"method","declarations":["instance","public"],"path":"Symbol#to_proc","name":"to_proc","namespace":"Symbol","comment":"Turn a symbol into a proc calling the method to which it refers.\n\n  up = :upcase.to_proc\n  up.call(\"hello\")  #=> 'HELLO'\n\nMore useful is the fact that this allows <tt>&</tt>\nto be used to coerce Symbol into Proc.\n\n  %w{foo bar qux}.map(&:upcase)   #=> [\"FOO\",\"BAR\",\"QUX\"]\n  [1, 2, 3].inject(&:+)           #=> 6\n\nTODO: This will be deprecated as of Ruby 1.9, since it will become standard Ruby.\n\nCREDIT: Florian Gross (orignal), Nobuhiro Imai (current)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_proc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/symbol/to_proc.rb","line":null,"source":"def to_proc\n  Proc.new{|*args| args.shift.__send__(self, *args)}\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#__get__":{"!":"method","declarations":["instance","public"],"path":"Kernel#__get__","name":"__get__","namespace":"Kernel","comment":"Shadow method for instance_variable_get.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__get__(ivar)","arguments":[{"name":"ivar"}]}],"returns":[],"file":"/lib/core/facets/kernel/__get__.rb","line":null,"source":"def __get__(ivar)\n  #ivar = \"@#{ivar}\" unless ivar.to_s[0,1] == '@'\n  instance_variable_get(ivar)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#__set__":{"!":"method","declarations":["instance","public"],"path":"Kernel#__set__","name":"__set__","namespace":"Kernel","comment":"Shadow method for instance_variable_set.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__set__(ivar, val)","arguments":[{"name":"ivar"},{"name":"val"}]}],"returns":[],"file":"/lib/core/facets/kernel/__get__.rb","line":null,"source":"def __set__(ivar, val)\n  #ivar = \"@#{ivar}\" unless ivar.to_s[0,1] == '@'\n  instance_variable_set(ivar, val)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#contains?":{"!":"method","declarations":["instance","public"],"path":"Array#contains?","name":"contains?","namespace":"Array","comment":"Alias for #include?.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"contains?","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/contains.rb","line":null,"source":"alias_method :contains?, :include?","language":"ruby","dynamic":null,"tags":{}},"Kernel#not_nil?":{"!":"method","declarations":["instance","public"],"path":"Kernel#not_nil?","name":"not_nil?","namespace":"Kernel","comment":"The opposite of #nil?.\n\n  \"hello\".not_nil?     # -> true\n  nil.not_nil?         # -> false\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"not_nil?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/kernel/not_nil.rb","line":null,"source":"def not_nil?\n  ! nil?\nend","language":"ruby","dynamic":null,"tags":{}},"Process":{"!":"module","path":"Process","name":"Process","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Process.daemon"],"accessors":[],"files":["/lib/core/facets/process/daemon.rb"],"tags":{}},"Process.daemon":{"!":"method","declarations":["class","public"],"path":"Process.daemon","name":"daemon","namespace":"Process","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"daemon(.)","arguments":[{"name":"nochdir","default":"nil"},{"name":"noclose","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/process/daemon.rb","line":null,"source":"def self.daemon(nochdir=nil, noclose=nil)\n  exit if fork # Parent exits, child continues.\n  Process.setsid # Become session leader.\n  exit if fork # Zap session leader. See [1].\n\n  unless nochdir\n    Dir.chdir \"/\" # Release old working directory.\n  end\n\n  File.umask 0000 # Ensure sensible umask. Adjust as needed.\n\n  unless noclose\n    STDIN.reopen \"/dev/null\" # Free file descriptors and\n    STDOUT.reopen \"/dev/null\", \"a\" # point them somewhere sensible.\n    STDERR.reopen '/dev/null', 'a'\n  end\n\n  trap(\"TERM\") { exit }\n\n  return 0\nend","language":"ruby","dynamic":null,"tags":{}},"Module#memoize":{"!":"method","declarations":["instance","public"],"path":"Module#memoize","name":"memoize","namespace":"Module","comment":"This is here for backward compatibility.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"memoize(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/memoize.rb","line":null,"source":"def memoize(*args)\n  include Memoizable\n  Memoizable.instance_method(:memoize).bind(self).call(*args)\n  #super(*args)  # TODO: why is super not working here?\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/memoize'"}},"Numeric#approx?":{"!":"method","declarations":["instance","public"],"path":"Numeric#approx?","name":"approx?","namespace":"Numeric","comment":"Determines if another number is approximately equal within a given\n_n_th degree. Defaults to 100ths if the degree is not specified.\n\nCurrently defaults to 1/10,000,000 if the degree is not specified.\nBut this may change once a \"most commonly useful\" factor is determined.\n\nThis is the same a {#close?} but has a different defualt.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"approx?(x, n=0.0000001)","arguments":[{"name":"x"},{"name":"n","default":"0.0000001"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/numeric/approx.rb","line":null,"source":"def approx?(x, n=0.0000001)\n  close?(x, n)\nend","language":"ruby","dynamic":null,"tags":{"author":"Gavin Sinclair"}},"Numeric#close?":{"!":"method","declarations":["instance","public"],"path":"Numeric#close?","name":"close?","namespace":"Numeric","comment":"Determines if another number is approximately equal\nwithin a given +epsilon+.\n\nThis is the same a {#approx?} but has a different defualt.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"close?(number, epsilon=0.01)","arguments":[{"name":"number"},{"name":"epsilon","default":"0.01"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/numeric/approx.rb","line":null,"source":"def close?(number, epsilon=0.01)\n  return(self == number) if epsilon.zero?\n\n  a, b = self.to_f, number.to_f\n  if a.zero? or b.zero?\n    ## There's no scale, so we can only go on difference.\n    (a - b).abs < @epsilon\n  else\n    ## We go by ratio. The ratio of two equal numbers is one, so the ratio\n    ## of two practically-equal floats will be very nearly one.\n    (a/b - 1).abs < epsilon\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Gavin Sinclair"}},"Enumerable#per":{"!":"method","declarations":["instance","public"],"path":"Enumerable#per","name":"per","namespace":"Enumerable","comment":"Per element meta-functor.\n\n  ([1,2,3].per(:map) + 3)     #=> [4,5,6]\n  ([1,2,3].per(:select) > 1)  #=> [2,3]\n\nUsing fluid notation.\n\n  ([1,2,3].per.map + 3)       #=> [4,5,6]\n  ([1,2,3].per.select > 1)    #=> [2,3]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"per(enum_method=nil, *enum_args)","arguments":[{"name":"enum_method","default":"nil"},{"name":"*enum_args"}]}],"returns":[],"file":"/lib/core/facets/enumerable/per.rb","line":null,"source":"def per(enum_method=nil, *enum_args)\n  if enum_method\n    Permeator.new(self, enum_method, *enum_args)\n  else\n    Functor.new do |enumr_method, *enumr_args|\n      Permeator.new(self, enumr_method, *enumr_args)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Permeator":{"!":"class","superclass":"Object","path":"Enumerable::Permeator","name":"Permeator","namespace":"Enumerable","comment":"Permeator is a Functor for operating over each element of an Enumearble.\n(Note: This used to be called an Elementor.)\n\nTODO: With Ruby 1.9+ this would not be required, as it can be replaced\nby a generic Functor, becuase then lambda definitions can pass blocks.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Enumerable::Permeator#initialize","Enumerable::Permeator#instance_delegate","Enumerable::Permeator#instance_operator","Enumerable::Permeator#method_missing"],"accessors":[],"files":["/lib/core/facets/enumerable/per.rb"],"tags":{}},"Enumerable::Permeator#initialize":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Permeator#initialize","name":"initialize","namespace":"Enumerable::Permeator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(enum_object, enum_method=nil, *enum_args)","arguments":[{"name":"enum_object"},{"name":"enum_method","default":"nil"},{"name":"*enum_args"}]}],"returns":[{"type":"Permeator","comment":"a new instance of Permeator"}],"file":"/lib/core/facets/enumerable/per.rb","line":null,"source":"def initialize(enum_object, enum_method=nil, *enum_args)\n  @enum_object = enum_object\n  @enum_method = enum_method || :map\n  @enum_args   = enum_args\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Permeator#instance_delegate":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Permeator#instance_delegate","name":"instance_delegate","namespace":"Enumerable::Permeator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_delegate()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/per.rb","line":null,"source":"def instance_delegate\n  @enum_object\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Permeator#instance_operator":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Permeator#instance_operator","name":"instance_operator","namespace":"Enumerable::Permeator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_operator()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/per.rb","line":null,"source":"def instance_operator\n  @enum_method\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Permeator#method_missing":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Permeator#method_missing","name":"method_missing","namespace":"Enumerable::Permeator","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(sym, *args, &blk)","arguments":[{"name":"sym"},{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/enumerable/per.rb","line":null,"source":"def method_missing(sym, *args, &blk)\n  @enum_object.__send__(@enum_method){ |x| x.__send__(sym, *args, &blk) }\nend","language":"ruby","dynamic":null,"tags":{}},"Array#collapse":{"!":"method","declarations":["instance","public"],"path":"Array#collapse","name":"collapse","namespace":"Array","comment":"Simplify an array by flattening it then compacting it.\n\n  [1,[2,nil,[3]],nil,4].collapse  #=> [1,2,3,4]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"collapse()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/collapse.rb","line":null,"source":"def collapse\n  flatten.compact\nend","language":"ruby","dynamic":null,"tags":{}},"String#shatter":{"!":"method","declarations":["instance","public"],"path":"String#shatter","name":"shatter","namespace":"String","comment":"Breaks a string up into an array based on a regular expression.\nSimilar to scan, but includes the matches.\n\n  s = \"<p>This<b>is</b>a test.</p>\"\n  s.shatter( /\\<.*?\\>/ )\n\n_produces_\n\n  [\"<p>\", \"This\", \"<b>\", \"is\", \"</b>\", \"a test.\", \"</p>\"]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"shatter(re)","arguments":[{"name":"re"}]}],"returns":[],"file":"/lib/core/facets/string/shatter.rb","line":null,"source":"def shatter( re )\n  r = self.gsub( re ){ |s| \"\\1\" + s + \"\\1\" }\n  while r[0,1] == \"\\1\" ; r[0] = '' ; end\n  while r[-1,1] == \"\\1\" ; r[-1] = '' ; end\n  r.split(\"\\1\")\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#length":{"!":"method","declarations":["instance","public"],"path":"Numeric#length","name":"length","namespace":"Numeric","comment":"Returns +self+, useful for polymorphic cases.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"length()","arguments":[]}],"returns":[],"file":"/lib/core/facets/numeric/length.rb","line":null,"source":"def length\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Range#quantile":{"!":"method","declarations":["instance","public"],"path":"Range#quantile","name":"quantile","namespace":"Range","comment":"Calculate the kth n-tile in a range.\n\nIf n=4 the quantity is called a quartile, and if n=100\nit is called a percentile.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"quantile(k, n=100)","arguments":[{"name":"k"},{"name":"n","default":"100"}]}],"returns":[{"type":"Integer","comment":"the kth n-tile"}],"file":"/lib/core/facets/range/quantile.rb","line":null,"source":"def quantile(k, n=100)\n  return 1 if k < first\n  return n if k >= last\n  ((k - first) / ((last - first) / n.to_f)).to_i + 1\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/range/quantile'"}},"Kernel#writers":{"!":"method","declarations":["instance","public"],"path":"Kernel#writers","name":"writers","namespace":"Kernel","comment":"Returns an Array of methods ending in '='.\n\n  class WritersExample\n    attr_reader :a, :b\n    attr_accessor :x, :y\n    private\n    def q=(q); @q=q; end\n  end\n\n  w = WritersExample.new\n\n  syms = w.writers      # [:x=, :y=]\n\n  syms.include?(:x=)    #=> true\n  syms.include?(:y=)    #=> true\n\nIf the +chomp+ option is true, then the trailing '=' will be removed.\n\n  syms = w.writers(:chomp=>true)\n\n  syms.include?(:x)     #=> true\n  syms.include?(:y)     #=> true\n\nBy default #writers only includes public methods. To see private or\nprotected methods use the +:access+ option.\n\n  w.writers(:access=>:private)  #=> [:q=]\n\nOr multiple access options,\n\n  syms = w.writers(:access=>[:public,:private])    # [:q=,:x=,:y=]\n\n  syms.include?(:q=)    #=> true\n  syms.include?(:x=)    #=> true\n  syms.include?(:y=)    #=> true\n\nYou can simply supply `:all` to get all method regardless accessibility.\n\nAlso, by default this method excludes all writers defined in Object \nor Kernel. To include these set +ancestors+ to Object or Kernel.\n\n  w.writers(Object)\n\nTODO: Create Module#instance_writers.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"writers(*ancestors_and_options)","arguments":[{"name":"*ancestors_and_options"}]}],"returns":[],"file":"/lib/core/facets/kernel/writers.rb","line":null,"source":"def writers(*ancestors_and_options)\n  options   = (Hash === ancestors_and_options.last ? ancestors_and_options.pop : {})\n  chomp     = options[:chomp]\n  access    = options[:access] || []\n  ancestors = ancestors_and_options.first\n\n  access = [access].flatten\n  if access.include?(:all)\n    access.concat([:public, :protected, :private])\n  end\n  access << :public if access.empty?\n\n  writers = []\n\n  if access.include?(:private)\n    writers += private_methods(ancestors).select{ |m| /=$/ =~ m.to_s  }\n  end\n\n  if access.include?(:protected)\n    writers += protected_methods(ancestors).select{ |m| /=$/ =~ m.to_s  }\n  end\n\n  if access.include?(:public)\n    writers += public_methods(ancestors).select{ |m| /=$/ =~ m.to_s  }\n  end\n\n  if ancestors == Kernel\n    exclude = nil\n  elsif ancestors == Object\n    exclude = Kernel\n  else\n    exclude = Object\n  end\n\n  if exclude\n    kernel_writers = exclude.instance_methods.select{ |m| /=$/ =~ m.to_s  }\n    writers = writers - kernel_writers\n  end\n\n  writers = writers.map{ |w| w.to_s.chomp('=') } if chomp\n  writers.map{ |w| w.to_sym }\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#delete_at":{"!":"method","declarations":["instance","public"],"path":"Hash#delete_at","name":"delete_at","namespace":"Hash","comment":"Polymorphic with Array#delete_at.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_at","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/delete_at.rb","line":null,"source":"alias_method :delete_at, :delete","language":"ruby","dynamic":null,"tags":{}},"Hash#to_struct":{"!":"method","declarations":["instance","public"],"path":"Hash#to_struct","name":"to_struct","namespace":"Hash","comment":"A method to convert a Hash into a Struct.\n\n  h = {:name=>\"Dan\",\"age\"=>33,\"rank\"=>\"SrA\",\"grade\"=>\"E4\"}\n  s = h.to_struct(\"Foo\")\n\nTODO: Is this robust enough considerd hashes aren't ordered?\n\nCREDIT: Daniel Berger","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_struct(struct_name)","arguments":[{"name":"struct_name"}]}],"returns":[],"file":"/lib/core/facets/hash/to_struct.rb","line":null,"source":"def to_struct(struct_name)\n  Struct.new(struct_name,*keys).new(*values)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#silence":{"!":"method","declarations":["instance","public"],"path":"Kernel#silence","name":"silence","namespace":"Kernel","comment":"Silence a stream and/or warnings...\n\n  silence(:stdout) do\n    puts \"won't see me\"\n  end\n\nSupported +streams+ are +stderr+, +stdout+, +verbose+, +debug+,\nand +warnings+, which is the same as +verbose+. You can also\nuse the actual streams, STDERR and STDOUT.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"silence(*streams)","arguments":[{"name":"*streams"}]}],"returns":[],"file":"/lib/core/facets/kernel/silence.rb","line":null,"source":"def silence(*streams) #:yield:\n  streams = streams.map do |stream|\n    case stream\n    when :stderr\n      STDERR\n    when :stdout\n      STDOUT\n    else\n      stream\n    end\n  end\n\n  if streams.empty?\n    yield\n  else\n    silence_stream(*streams){ yield }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#silently":{"!":"method","declarations":["instance","public"],"path":"Kernel#silently","name":"silently","namespace":"Kernel","comment":"Just like silence_stream, but will default to\nSTDOUT, STDERR if no streams are given.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"silently(*streams)","arguments":[{"name":"*streams"}]}],"returns":[],"file":"/lib/core/facets/kernel/silence.rb","line":null,"source":"def silently(*streams) #:yeild:\n  streams = [STDOUT, STDERR] if streams.empty?\n  silence_stream(*streams){ yield }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#silence_stream":{"!":"method","declarations":["instance","public"],"path":"Kernel#silence_stream","name":"silence_stream","namespace":"Kernel","comment":"Silences any stream for the duration of the block...\n\n  silence_stream(STDOUT) do\n    puts 'This will never be seen'\n  end\n\n  puts 'But this will'\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"silence_stream(*streams)","arguments":[{"name":"*streams"}]}],"returns":[],"file":"/lib/core/facets/kernel/silence.rb","line":null,"source":"def silence_stream(*streams) #:yeild:\n  on_hold = streams.collect{ |stream| stream.dup }\n  streams.each do |stream|\n    stream.reopen(RUBY_PLATFORM =~ /mswin/ ? 'NUL:' : '/dev/null')\n    stream.sync = true\n  end\n  yield\nensure\n  streams.each_with_index do |stream, i|\n    stream.reopen(on_hold[i])\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#silence_stderr":{"!":"method","declarations":["instance","public"],"path":"Kernel#silence_stderr","name":"silence_stderr","namespace":"Kernel","comment":"Equivalent to `silence_stream(STDERR)`.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"silence_stderr()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/silence.rb","line":null,"source":"def silence_stderr #:yeild:\n  silence_stream(STDERR) { yield }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#silence_stdout":{"!":"method","declarations":["instance","public"],"path":"Kernel#silence_stdout","name":"silence_stdout","namespace":"Kernel","comment":"Equivalent to `silence_stream(STDOUT)`.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"silence_stdout()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/silence.rb","line":null,"source":"def silence_stdout #:yeild:\n  silence_stream(STDOUT) { yield }\nend","language":"ruby","dynamic":null,"tags":{}},"File.split_all":{"!":"method","declarations":["class","public"],"path":"File.split_all","name":"split_all","namespace":"File","comment":"Splits a file path into an array of individual path components.\nThis differs from <tt>File.split</tt>, which divides the path into\nonly two parts, directory path and basename.\n\n  File.split_all(\"a/b/c\")  #=> ['a', 'b', 'c']\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"split_all(.)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/file/split_all.rb","line":null,"source":"def self.split_all(path)\n  head, tail = File.split(path)\n  return [tail] if head == '.' || tail == '/'\n  return [head, tail] if head == '/'\n  return split_all(head) + [tail]\nend","language":"ruby","dynamic":null,"tags":{}},"Array#traverse":{"!":"method","declarations":["instance","public"],"path":"Array#traverse","name":"traverse","namespace":"Array","comment":"Returns a new array created by traversing the array and its\nsub-arrays, executing the given block on the elements.\n\n  h = [\"A\", \"B\", [\"X\", \"Y\"]]\n\n  g = h.traverse{ |e| e.downcase }\n\n  g  #=> [\"a\", \"b\", [\"x\", \"y\"]]\n\nThis is the same as <code>recursive.map</code> and will\nlikely be deprecated in the future because of it.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"traverse(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/traverse.rb","line":null,"source":"def traverse(&block)\n  if block_given?\n    map do |e|\n      if e.respond_to?(:to_ary)\n        e.to_ary.traverse(&block)\n      else\n        block.call(e)\n      end\n    end\n  else\n    to_enum(:traverse)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#traverse!":{"!":"method","declarations":["instance","public"],"path":"Array#traverse!","name":"traverse!","namespace":"Array","comment":"Like #recursive_map, but will change the array in place.\n\n  h = [\"A\", \"B\", [\"X\", \"Y\"]]\n\n  h.traverse!{ |e| e.downcase }\n\n  h  #=> [\"a\", \"b\", [\"x\", \"y\"]]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"traverse!(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/traverse.rb","line":null,"source":"def traverse!(&block)\n  replace(traverse(&block))\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#respond":{"!":"method","declarations":["instance","public"],"path":"Kernel#respond","name":"respond","namespace":"Kernel","comment":"Like #respond_to? but returns the result of the call\nif it does indeed respond.\n\n  class RespondExample\n    def f; \"f\"; end\n  end\n\n  x = RespondExample.new\n  x.respond(:f)  #=> \"f\"\n  x.respond(:g)  #=> nil\n\nor\n\n  x.respond.f   #=> \"f\"\n  x.respond.g   #=> nil\n\nThis method was known as #try until Rails defined #try\nto be something more akin to #ergo.\n\nCREDIT: Trans, Chris Wanstrath","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"respond(sym=nil, *args, &blk)","arguments":[{"name":"sym","default":"nil"},{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/respond.rb","line":null,"source":"def respond(sym=nil, *args, &blk)\n  if sym\n    return nil if not respond_to?(sym)\n    __send__(sym, *args, &blk)\n  else\n    ## TODO: use after 1.8.6 not supported anymore\n    ##Functor.new do |op, *a, &b|\n    ##  respond(op, *a, &b)\n    ##end\n    Functor.new(&method(:respond).to_proc)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#exclude?":{"!":"method","declarations":["instance","public"],"path":"String#exclude?","name":"exclude?","namespace":"String","comment":"The inverse of include?.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exclude?(str)","arguments":[{"name":"str"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/string/exclude.rb","line":null,"source":"def exclude?(str)\n  !include?(str)\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#[]":{"!":"method","declarations":["instance","public"],"path":"Binding#[]","name":"[]","namespace":"Binding","comment":"Returns the value of some variable.\n\n  a = 2\n  binding[\"a\"]  #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/core/facets/binding/op_get.rb","line":null,"source":"def []( x )\n  eval( x.to_s )\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#[]=":{"!":"method","declarations":["instance","public"],"path":"Binding#[]=","name":"[]=","namespace":"Binding","comment":"Set the value of a local variable.\n\n  binding[\"a\"] = 4\n  a  #=> 4","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[]=(l, v)","arguments":[{"name":"l"},{"name":"v"}]}],"returns":[],"file":"/lib/core/facets/binding/op_get.rb","line":null,"source":"def []=( l, v )\n  eval( \"lambda {|v| #{l} = v}\").call( v )\nend","language":"ruby","dynamic":null,"tags":{"deprecated":"No longer wortks in Ruby 1.9+.","see":"for an alternative."}},"String#rewrite":{"!":"method","declarations":["instance","public"],"path":"String#rewrite","name":"rewrite","namespace":"String","comment":"Apply a set of rules in the form of regular expression matches\nto the string.\n\n* rules - The array containing rule-pairs (match, write).\n\nKeep in mind that the order of rules is significant.\n\nReturns the rewritten String.\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rewrite(rules)","arguments":[{"name":"rules"}]}],"returns":[],"file":"/lib/core/facets/string/rewrite.rb","line":null,"source":"def rewrite(rules)\n  raise ArgumentError.new('The rules parameter is nil') unless rules\n  rewritten_string = dup\n  rules.each do |(match,write)|\n    rewritten_string.gsub!(match,write)\n  end\n  return rewritten_string\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Proc#to_method":{"!":"method","declarations":["instance","public"],"path":"Proc#to_method","name":"to_method","namespace":"Proc","comment":"Convert Proc to method.\n\n  object = Object.new\n\n  function = lambda { |x| x + 1 }\n\n  function.to_method(object, 'foo')\n\n  object.foo(1)  #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_method(object, name=nil)","arguments":[{"name":"object"},{"name":"name","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/proc/to_method.rb","line":null,"source":"def to_method(object, name=nil)\n  ##object = object || eval(\"self\", self)\n  block, time = self, Time.now\n  method_name = name || \"__bind_#{time.to_i}_#{time.usec}\"\n  begin\n    object.singleton_class.class_eval do\n      define_method(method_name, &block)\n      method = instance_method(method_name)\n      remove_method(method_name) unless name\n      method\n    end.bind(object)\n  rescue TypeError\n    object.class.class_eval do\n      define_method(method_name, &block)\n      method = instance_method(method_name)\n      remove_method(method_name) unless name\n      method\n    end.bind(object)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable":{"!":"module","path":"Comparable","name":"Comparable","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Comparable#cmp","Comparable#at_least","Comparable#at_most","Comparable#cap","Comparable#clip","Comparable#bound","Comparable.[]"],"accessors":[],"files":["/lib/core/facets/comparable/cmp.rb","/lib/core/facets/comparable/cap.rb","/lib/core/facets/comparable/clip.rb","/lib/core/facets/comparable/op_get.rb"],"tags":{}},"Comparable#cmp":{"!":"method","declarations":["instance","public"],"path":"Comparable#cmp","name":"cmp","namespace":"Comparable","comment":"Alternate name for comparison operator #<=>.\n\n  3.cmp(1)   #=>  1\n  3.cmp(3)   #=>  0\n  3.cmp(10)  #=> -1\n\nThis fundamental compare method is used to keep\ncomparison compatible with <tt>#succ</tt>.\n\nCREDIT: Peter Vanbroekhoven","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cmp(o)","arguments":[{"name":"o"}]}],"returns":[],"file":"/lib/core/facets/comparable/cmp.rb","line":null,"source":"def cmp(o)\n  self<=>o\nend","language":"ruby","dynamic":null,"tags":{}},"String#cmp":{"!":"method","declarations":["instance","public"],"path":"String#cmp","name":"cmp","namespace":"String","comment":"Compare method that takes length into account.\nUnlike #<=>, this is compatible with #succ.\n\n  \"abc\".cmp(\"abc\")   #=>  0\n  \"abcd\".cmp(\"abc\")  #=>  1\n  \"abc\".cmp(\"abcd\")  #=> -1\n  \"xyz\".cmp(\"abc\")   #=>  1\n\nCREDIT: Peter Vanbroekhoven\n\nTODO: Move String#cmp to string/ directory.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cmp(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/comparable/cmp.rb","line":null,"source":"def cmp(other)\n  return -1 if length < other.length\n  return 1 if length > other.length\n  self <=> other  # alphabetic compare\nend","language":"ruby","dynamic":null,"tags":{}},"String#bracket":{"!":"method","declarations":["instance","public"],"path":"String#bracket","name":"bracket","namespace":"String","comment":"Return a new string embraced by given brackets.\nIf only one bracket char is given it will be placed\non either side.\n\n  \"wrap me\".bracket('{')        #=> \"{wrap me}\"\n  \"wrap me\".bracket('--','!')   #=> \"--wrap me!\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bracket(bra, ket=nil)","arguments":[{"name":"bra"},{"name":"ket","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/bracket.rb","line":null,"source":"def bracket(bra, ket=nil)\n  #ket = String.bra2ket[$&] if ! ket && /^[\\[({<]$/ =~ bra\n  ket = BRA2KET[bra] unless ket\n  \"#{bra}#{self}#{ket ? ket : bra}\"\nend","language":"ruby","dynamic":null,"tags":{}},"String#bracket!":{"!":"method","declarations":["instance","public"],"path":"String#bracket!","name":"bracket!","namespace":"String","comment":"Inplace version of #bracket.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bracket!(bra, ket=nil)","arguments":[{"name":"bra"},{"name":"ket","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/bracket.rb","line":null,"source":"def bracket!(bra, ket=nil)\n  self.replace(bracket(bra, ket))\nend","language":"ruby","dynamic":null,"tags":{}},"String#unbracket":{"!":"method","declarations":["instance","public"],"path":"String#unbracket","name":"unbracket","namespace":"String","comment":"Return a new string with the given brackets removed.\nIf only one bracket char is given it will be removed\nfrom either side.\n\n  \"{unwrap me}\".unbracket('{')        #=> \"unwrap me\"\n  \"--unwrap me!\".unbracket('--','!')  #=> \"unwrap me\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unbracket(bra=nil, ket=nil)","arguments":[{"name":"bra","default":"nil"},{"name":"ket","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/bracket.rb","line":null,"source":"def unbracket(bra=nil, ket=nil)\n  if bra\n    ket = BRA2KET[bra] unless ket\n    ket = ket ? ket : bra\n    s = self.dup\n    s.gsub!(%r[^#{Regexp.escape(bra)}], '')\n    s.gsub!(%r[#{Regexp.escape(ket)}$], '')\n    return s\n  else\n    if m = BRA2KET[ self[0,1] ]\n      return self.slice(1...-1) if self[-1,1]  == m\n    end\n  end\n  return self.dup  # if nothing else\nend","language":"ruby","dynamic":null,"tags":{}},"String#unbracket!":{"!":"method","declarations":["instance","public"],"path":"String#unbracket!","name":"unbracket!","namespace":"String","comment":"Inplace version of #unbracket.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"unbracket!(bra=nil, ket=nil)","arguments":[{"name":"bra","default":"nil"},{"name":"ket","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/string/bracket.rb","line":null,"source":"def unbracket!(bra=nil, ket=nil)\n  self.replace( unbracket(bra, ket) )\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable#at_least":{"!":"method","declarations":["instance","public"],"path":"Comparable#at_least","name":"at_least","namespace":"Comparable","comment":"Returns the lower of self or x.\n\n  4.at_least(5)  #=> 5\n  6.at_least(5)  #=> 6\n\nCREDIT: Florian Gross","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_least(lower)","arguments":[{"name":"lower"}]}],"returns":[],"file":"/lib/core/facets/comparable/cap.rb","line":null,"source":"def at_least(lower)\n  (self >= lower) ? self : lower\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable#at_most":{"!":"method","declarations":["instance","public"],"path":"Comparable#at_most","name":"at_most","namespace":"Comparable","comment":"Returns the greater of self or x.\n\n  4.at_most(5)  #=> 4\n  6.at_most(5)  #=> 5\n\nCREDIT: Florian Gross","format":"rdoc","aliases":["Comparable#cap"],"singleton":null,"interfaces":[{"signature":"at_most(upper)","arguments":[{"name":"upper"}]}],"returns":[],"file":"/lib/core/facets/comparable/cap.rb","line":null,"source":"def at_most(upper)\n  (self <= upper) ? self : upper\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable#cap":{"!":"method","declarations":["instance","public"],"path":"Comparable#cap","name":"cap","namespace":"Comparable","comment":"Returns the greater of self or x.\n\n  4.at_most(5)  #=> 4\n  6.at_most(5)  #=> 5\n\nCREDIT: Florian Gross\nReturns the greater of self or x.\n\n  4.cap(5)  #=> 4\n  6.cap(5)  #=> 5\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"at_most(upper)","arguments":[]}],"returns":[],"file":"/lib/core/facets/comparable/cap.rb","line":null,"source":"def at_most(upper)\n  (self <= upper) ? self : upper\nend","language":"ruby","dynamic":null,"tags":{}},"String#acronym":{"!":"method","declarations":["instance","public"],"path":"String#acronym","name":"acronym","namespace":"String","comment":"Transform a string into an acronym.\n\nCREDIT: Robert Fey","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"acronym(\t)","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/acronym.rb","line":null,"source":"def acronym\n gsub(/(([a-zA-Z0-9])([a-zA-Z0-9])*)./,\"\\\\2\")\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#defined?":{"!":"method","declarations":["instance","public"],"path":"Binding#defined?","name":"defined?","namespace":"Binding","comment":"Returns the nature of something within the context of the binding.\nReturns nil if that thing is not defined.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"defined?(x)","arguments":[{"name":"x"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/binding/defined.rb","line":null,"source":"def defined?(x)\n  eval(\"defined? #{x}\")\nend","language":"ruby","dynamic":null,"tags":{}},"Array#not_empty?":{"!":"method","declarations":["instance","public"],"path":"Array#not_empty?","name":"not_empty?","namespace":"Array","comment":"Not empty?\n\n  [].not_empty?     #=> false\n  [1,2].not_empty?  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"not_empty?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/array/not_empty.rb","line":null,"source":"def not_empty?\n  !empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Array#each_pair":{"!":"method","declarations":["instance","public"],"path":"Array#each_pair","name":"each_pair","namespace":"Array","comment":"Iterate over index and value. The intention of this\nmethod is to provide polymorphism with Hash.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_pair()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/each_pair.rb","line":null,"source":"def each_pair #:yield:\n  i = -1\n  each_value do |x|\n    yield(i+=1, x)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#first!":{"!":"method","declarations":["instance","public"],"path":"Array#first!","name":"first!","namespace":"Array","comment":"Alias for shift, which removes and returns\nthe first element in an array.\n\n  a = [\"a\",\"y\",\"z\"]\n  a.first!      #=> \"a\"\n  a             #=> [\"y\",\"z\"]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"first!","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/indexable.rb","line":null,"source":"alias_method :first!, :shift","language":"ruby","dynamic":null,"tags":{}},"Array#last!":{"!":"method","declarations":["instance","public"],"path":"Array#last!","name":"last!","namespace":"Array","comment":"Alias for pop, which removes and returns\nthe last element in an array.\n\n  a = [1,2,3]\n  a.last!       #=> 3\n  a             #=> [1,2]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"last!","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/indexable.rb","line":null,"source":"alias_method :last!, :pop","language":"ruby","dynamic":null,"tags":{}},"Hash#url_params":{"!":"method","declarations":["instance","public"],"path":"Hash#url_params","name":"url_params","namespace":"Hash","comment":"Allows for taking a hash and turning it into CGI params\nSince 1.8.x does not have ordered hashes the params might not\nbe ordered.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"url_params()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/url_params.rb","line":null,"source":"def url_params\n  map do |k,v|\n    if v.respond_to?(:join)\n      \"#{k}=#{v.join(\",\")}\"\n    else\n      \"#{k}=#{v}\"\n    end\n  end.join(\"&\")\nend","language":"ruby","dynamic":null,"tags":{"todo":"Hash#url_params may require some URL escaping.","author":"Matt Kirk"}},"Numeric#spacing":{"!":"method","declarations":["instance","public"],"path":"Numeric#spacing","name":"spacing","namespace":"Numeric","comment":"Returns the size of the string representation of\na numerical value.\n\n     1.spacing   #=> 1\n    10.spacing   #=> 2\n   100.spacing   #=> 3\n  -100.spacing   #=> 4\n   1.2.spacing   #=> 3\n\nCREDIT: Victor H. Goff III","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"spacing()","arguments":[]}],"returns":[],"file":"/lib/core/facets/numeric/spacing.rb","line":null,"source":"def spacing\n  to_s.length\nend","language":"ruby","dynamic":null,"tags":{}},"String#modulize":{"!":"method","declarations":["instance","public"],"path":"String#modulize","name":"modulize","namespace":"String","comment":"Converts a string to module name representation.\n\nThis is essentially #camelcase, but it also converts\n'/' to '::' which is useful for converting paths to\nnamespaces.\n\nExamples\n\n  \"method_name\".modulize    #=> \"MethodName\"\n  \"method/name\".modulize    #=> \"Method::Name\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"modulize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/modulize.rb","line":null,"source":"def modulize\n  #gsub('__','/').  # why was this ever here?\n  gsub(/__(.?)/){ \"::#{$1.upcase}\" }.\n  gsub(/\\/(.?)/){ \"::#{$1.upcase}\" }.\n  gsub(/(?:_+|-+)([a-z])/){ $1.upcase }.\n  gsub(/(\\A|\\s)([a-z])/){ $1 + $2.upcase }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#basename":{"!":"method","declarations":["instance","public"],"path":"Module#basename","name":"basename","namespace":"Module","comment":"Returns the root name of the module/class.\n\n  module ::BaseName\n    class Example\n    end\n  end\n\n  BaseName::Example.name       #=> \"BaseName::Example\"\n  BaseName::Example.basename   #=> \"Example\"\n\nFor anonymous modules this will provide a basename\nbased on Module#inspect.\n\n  m = Module.new\n  m.inspect       # \"#<Module:0xb7bb0434>\"\n  m.basename      # \"Module_0xb7bb0434\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"basename()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/basename.rb","line":null,"source":"def basename\n  if name and not name.empty?\n    name.gsub(/^.*::/, '')\n  else\n    nil #inspect.gsub('#<','').gsub('>','').sub(':', '_')\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#constant":{"!":"method","declarations":["instance","public"],"path":"Kernel#constant","name":"constant","namespace":"Kernel","comment":"This is similar to +Module#const_get+ but is accessible at all levels,\nand, unlike +const_get+, can handle module hierarchy.\n\n  constant(\"Fixnum\")                  # => Fixnum\n  constant(:Fixnum)                   # => Fixnum\n\n  constant(\"Process::Sys\")            # => Process::Sys\n  constant(\"Regexp::MULTILINE\")       # => 4\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"constant(const)","arguments":[{"name":"const"}]}],"returns":[],"file":"/lib/core/facets/kernel/constant.rb","line":null,"source":"def constant(const)\n  const = const.to_s.dup\n  base = const.sub!(/^::/, '') ? Object : ( self.kind_of?(Module) ? self : self.class )\n  const.split(/::/).inject(base){ |mod, name| mod.const_get(name) }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#ancestor?":{"!":"method","declarations":["instance","public"],"path":"Module#ancestor?","name":"ancestor?","namespace":"Module","comment":"Is a given class or module an ancestor of\nthis class or module?\n\n class X ; end\n class Y < X ; end\n\n  X.ancestor?(Y)","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ancestor?(mod)","arguments":[{"name":"mod"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/module/ancestor.rb","line":null,"source":"def ancestor?( mod )\n  ancestors.include?(mod)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#none?":{"!":"method","declarations":["instance","public"],"path":"Enumerable#none?","name":"none?","namespace":"Enumerable","comment":"Enumerable#none? is the logical opposite of the builtin method\nEnumerable#any?.  It returns +true+ if and only if _none_ of\nthe elements in the collection satisfy the predicate.\n\nIf no predicate is provided, Enumerable#none? returns +true+\nif and only if _none_ of the elements have a true value\n(i.e. not +nil+ or +false+).\n\n  [].none?                      # => true\n  [nil].none?                   # => true\n  [5,8,9].none?                 # => false\n  (1...10).none? { |n| n < 0 }  # => true\n  (1...10).none? { |n| n > 0 }  # => false\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"none?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/enumerable/none.rb","line":null,"source":"def none?  # :yield: e\n  if block_given?\n    not self.any? { |e| yield e }\n  else\n    not self.any?\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#newlines":{"!":"method","declarations":["instance","public"],"path":"String#newlines","name":"newlines","namespace":"String","comment":"Returns an Enumerator for iterating over each\nline of the string, void of the termining newline\ncharacter, in contrast to #lines which retains it.\n\n  \"a\\nb\\nc\".newlines.class.assert == Enumerator\n  \"a\\nb\\nc\".newlines.to_a.assert == %w{a b c}\n\n  a = []\n  \"a\\nb\\nc\".newlines{|nl| a << nl}\n  a.assert == %w{a b c}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"newlines(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/string/newlines.rb","line":null,"source":"def newlines(&block)\n  if block\n    scan(/^.*?$/) do |line|\n      block.call(line.chomp)\n    end\n  else\n    str = self\n    Enumerator.new do |output|\n      str.scan(/^.*?$/) do |line|\n        output.yield(line.chomp)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#abstract":{"!":"method","declarations":["instance","public"],"path":"Module#abstract","name":"abstract","namespace":"Module","comment":"Create an abstract method. If it is not overridden, it will\nraise a TypeError when called.\n\n  class AbstractExample\n    abstract :a\n  end\n\n  c = AbstractExample.new\n\n  expect TypeError do\n    c.a\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"abstract(*sym)","arguments":[{"name":"*sym"}]}],"returns":[],"file":"/lib/core/facets/module/abstract.rb","line":null,"source":"def abstract(*sym)\n  sym.each do |s|\n    define_method(s){ raise TypeError, \"undefined abstraction ##{s}\" }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol.generate":{"!":"method","declarations":["class","public"],"path":"Symbol.generate","name":"generate","namespace":"Symbol","comment":"Generate a unique symbol.\n\n  Symbol.generate  #=> :\"-1\"\n\nIf +key+ is given the new symbol will be prefixed with it.\n\n  Symbol.generate(:foo)  #=> :\"foo-1\"\n\nTODO: Is the generated symbol format acceptable?\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"generate(.)","arguments":[{"name":"key","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/symbol/generate.rb","line":null,"source":"def self.generate(key=nil)\n  key = key.to_sym if key\n  @symbol_generate_counter ||= {}\n  @symbol_generate_counter[key] ||= 0\n  num = @symbol_generate_counter[key] += 1\n  (\"#{key}-%X\" % num).to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"MatchData":{"!":"class","superclass":"Object","path":"MatchData","name":"MatchData","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["MatchData#match","MatchData#matchset","MatchData#matchtree"],"accessors":[],"files":["/lib/core/facets/matchdata/match.rb","/lib/core/facets/matchdata/matchset.rb"],"tags":{}},"MatchData#match":{"!":"method","declarations":["instance","public"],"path":"MatchData#match","name":"match","namespace":"MatchData","comment":"Return the primary match string. This is equivalent to +md[0]+.\n\n  md = /123/.match \"123456\"\n  md.match  #=> \"123\"\n\nCREDIT: Martin DeMello","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"match(index=0)","arguments":[{"name":"index","default":"0"}]}],"returns":[],"file":"/lib/core/facets/matchdata/match.rb","line":null,"source":"def match(index=0)\n  self[index]\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#deep_merge":{"!":"method","declarations":["instance","public"],"path":"Hash#deep_merge","name":"deep_merge","namespace":"Hash","comment":"Same as Hash#merge but recursively merges sub-hashes.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deep_merge(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/deep_merge.rb","line":null,"source":"def deep_merge(other)\n  hash = self.dup\n  other.each do |key, value|\n    myval = self[key]\n    if value.is_a?(Hash) && myval.is_a?(Hash)\n      hash[key] = myval.deep_merge(value)\n    else\n      hash[key] = value\n    end\n  end\n  hash\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#deep_merge!":{"!":"method","declarations":["instance","public"],"path":"Hash#deep_merge!","name":"deep_merge!","namespace":"Hash","comment":"Same as Hash#merge! but recursively merges sub-hashes.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deep_merge!(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/deep_merge.rb","line":null,"source":"def deep_merge!(other)\n  other.each do |key, value|\n    myval = self[key]\n    if value.is_a?(Hash) && myval.is_a?(Hash)\n      myval.deep_merge!(value)\n    else\n      self[key] = value\n    end\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Class#singleton?":{"!":"method","declarations":["instance","public"],"path":"Class#singleton?","name":"singleton?","namespace":"Class","comment":"Return true if a class is the singleton class of\nan object.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"singleton?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/class/singleton.rb","line":null,"source":"def singleton? \n  ! ancestors.include?( self ) rescue false \nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/class/singleton'"}},"Enumerable#take":{"!":"method","declarations":["instance","public"],"path":"Enumerable#take","name":"take","namespace":"Enumerable","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"take(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/enumerable/take.rb","line":null,"source":"def take(n)\n  res = []\n  count = 0\n  each do |e|\n    break if count >= n\n    res << e\n    count += 1\n  end\n  res\nend","language":"ruby","dynamic":null,"tags":{}},"File.split_root":{"!":"method","declarations":["class","public"],"path":"File.split_root","name":"split_root","namespace":"File","comment":"Return the head of path from the rest of the path.\n\n  File.split_root('etc/xdg/gtk')  #=> ['etc', 'xdg/gtk']","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"split_root(.)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/file/split_root.rb","line":null,"source":"def self.split_root(path)\n  path_re = Regexp.new('[' + Regexp.escape(File::Separator + %q{\\/}) + ']')\n  path.split(path_re, 2)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#meta_def":{"!":"method","declarations":["instance","public"],"path":"Kernel#meta_def","name":"meta_def","namespace":"Kernel","comment":"Add method to a meta-class --i.e. a singleton method.\n\n  class X; end\n  X.meta_def(:x){\"x\"}\n  X.x  #=> \"x\"\n\nCREDIT: WhyTheLuckyStiff","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"meta_def(name, &block)","arguments":[{"name":"name"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/meta_def.rb","line":null,"source":"def meta_def( name, &block )\n  meta_class do\n    define_method( name, &block )\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable#clip":{"!":"method","declarations":["instance","public"],"path":"Comparable#clip","name":"clip","namespace":"Comparable","comment":"Returns self if above the given lower bound, or\nwithin the given lower and upper bounds,\notherwise returns the the bound of which the\nvalue falls outside.\n\n  4.clip(3)    #=> 4\n  4.clip(5)    #=> 5\n  4.clip(2,7)  #=> 4\n  9.clip(2,7)  #=> 7\n  1.clip(2,7)  #=> 2\n\nCREDIT Florian Gross, Trans","format":"rdoc","aliases":["Comparable#bound"],"singleton":null,"interfaces":[{"signature":"clip(lower, upper=nil)","arguments":[{"name":"lower"},{"name":"upper","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/comparable/clip.rb","line":null,"source":"def clip(lower, upper=nil)\n  return lower if self < lower\n  return self unless upper\n  return upper if self > upper\n  return self\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable#bound":{"!":"method","declarations":["instance","public"],"path":"Comparable#bound","name":"bound","namespace":"Comparable","comment":"Returns self if above the given lower bound, or\nwithin the given lower and upper bounds,\notherwise returns the the bound of which the\nvalue falls outside.\n\n  4.clip(3)    #=> 4\n  4.clip(5)    #=> 5\n  4.clip(2,7)  #=> 4\n  9.clip(2,7)  #=> 7\n  1.clip(2,7)  #=> 2\n\nCREDIT Florian Gross, Trans\nReturns self if above the given lower bound, or\nwithin the given lower and upper bounds,\notherwise returns the the bound of which the\nvalue falls outside.\n\n  4.bound(3)    #=> 4\n  4.bound(5)    #=> 5\n  4.bound(2,7)  #=> 4\n  9.bound(2,7)  #=> 7\n  1.bound(2,7)  #=> 2\n\nCREDIT: Florian Gross","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"clip(lower, upper=nil)","arguments":[]}],"returns":[],"file":"/lib/core/facets/comparable/clip.rb","line":null,"source":"def clip(lower, upper=nil)\n  return lower if self < lower\n  return self unless upper\n  return upper if self > upper\n  return self\nend","language":"ruby","dynamic":null,"tags":{}},"Class#methodize":{"!":"method","declarations":["instance","public"],"path":"Class#methodize","name":"methodize","namespace":"Class","comment":"Translate a class name to a suitable method name.\n\n  module ::Example\n    class MethodizeExample\n    end\n  end\n\n  Example::MethodizeExample.methodize  #=> \"example__methodize_example\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"methodize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/class/methodize.rb","line":null,"source":"def methodize\n  name.methodize\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#bit":{"!":"method","declarations":["instance","public"],"path":"Integer#bit","name":"bit","namespace":"Integer","comment":"Set a bit.\n\n  0.bit(4)  #=> 16\n\nUsing a negative figure will clear a bit.\n\n  10.bit(-4)      #=> 2\n\nThis is more easily seen using binary.\n\n  0b0100.bit(-3)  #=> 0\n\nCREDIT: Thomas Sawyer, George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bit(bit)","arguments":[{"name":"bit"}]}],"returns":[],"file":"/lib/core/facets/integer/bitmask.rb","line":null,"source":"def bit(bit)\n  if bit < 0\n    mask = (1 << ~bit)\n    self & ~mask\n  else\n    mask = (1 << bit)\n    self | mask\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#bit_clear":{"!":"method","declarations":["instance","public"],"path":"Integer#bit_clear","name":"bit_clear","namespace":"Integer","comment":"Clear bit.\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bit_clear(bit)","arguments":[{"name":"bit"}]}],"returns":[],"file":"/lib/core/facets/integer/bitmask.rb","line":null,"source":"def bit_clear(bit)\n  mask = (1 << bit)\n  self & ~mask\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#bit?":{"!":"method","declarations":["instance","public"],"path":"Integer#bit?","name":"bit?","namespace":"Integer","comment":"Is a bit set?\n\n  8.bit?(3)  #=> true\n  8.bit?(2)  #=> false\n\nCREDIT: Thomas Sawyer, George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bit?(bit)","arguments":[{"name":"bit"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/integer/bitmask.rb","line":null,"source":"def bit?(bit)\n  mask = (1 << bit)\n  (self & mask) != 0\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#bitmask":{"!":"method","declarations":["instance","public"],"path":"Integer#bitmask","name":"bitmask","namespace":"Integer","comment":"Apply a bitmask.\n\n  1.bitmask(6) #=> 7\n\nUsing a inverted bitmask clears bits.\n\n  7.bitmask(~2) #=> 5\n  5.bitmask(~2) #=> 5\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bitmask(mask)","arguments":[{"name":"mask"}]}],"returns":[],"file":"/lib/core/facets/integer/bitmask.rb","line":null,"source":"def bitmask(mask)\n  if mask < 0\n    self & mask\n  else\n    self | mask\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#bitmask?":{"!":"method","declarations":["instance","public"],"path":"Integer#bitmask?","name":"bitmask?","namespace":"Integer","comment":"Is bitmask set?\n\n  7.bitmask?(7) #=> true\n  7.bitmask?(5) #=> true\n  8.bitmask?(3) #=> false\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"bitmask?(mask)","arguments":[{"name":"mask"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/integer/bitmask.rb","line":null,"source":"def bitmask?(mask)\n  (self & mask) != 0\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#Bit":{"!":"method","declarations":["instance","public"],"path":"Kernel#Bit","name":"Bit","namespace":"Kernel","comment":"Create a single bit bitmask.\n\n  Bit(0)  #=> 1\n  Bit(1)  #=> 2\n  Bit(2)  #=> 4\n\nThis is equivalent to n-shift: \"1 << n\".\n\nCREDIT: Thomas Sawyer, George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"Bit(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/integer/bitmask.rb","line":null,"source":"def Bit(n)\n  1 << Integer(n)\nend","language":"ruby","dynamic":null,"tags":{}},"File.writelines":{"!":"method","declarations":["class","public"],"path":"File.writelines","name":"writelines","namespace":"File","comment":"Writes the given array of data to the given path and closes the file.\nThis is done in binary mode, complementing <tt>IO.readlines</tt> in\nstandard Ruby.\n\nNote that +readlines+ (the standard Ruby method) returns an array of lines\n<em>with newlines intact</em>, whereas +writelines+ uses +puts+, and so\nappends newlines if necessary.  In this small way, +readlines+ and\n+writelines+ are not exact opposites.\n\n  data = ['The content', ['for the file']]\n  File.writelines('writelines.txt', data)\n\nReturns number of lines written.\n\nCREDIT: Noah Gibbs, Gavin Sinclair","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"writelines(.)","arguments":[{"name":"path"},{"name":"data"}]}],"returns":[],"file":"/lib/core/facets/file/writelines.rb","line":null,"source":"def self.writelines(path, data)\n  File.open(path, \"wb\") do |file|\n    file.puts(data)\n  end\n  data.size\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#ordinal":{"!":"method","declarations":["instance","public"],"path":"Integer#ordinal","name":"ordinal","namespace":"Integer","comment":"","format":"rdoc","aliases":["Integer#ordinalize"],"singleton":null,"interfaces":[{"signature":"ordinal()","arguments":[]}],"returns":[],"file":"/lib/core/facets/integer/ordinal.rb","line":null,"source":"def ordinal\n  if [11,12,13].include?(self % 100)\n    \"#{self}th\"\n  else\n    case (self % 10)\n    when 1\n      \"#{self}st\"\n    when 2\n      \"#{self}nd\"\n    when 3\n      \"#{self}rd\"\n    else\n      \"#{self}th\"\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#ordinalize":{"!":"method","declarations":["instance","public"],"path":"Integer#ordinalize","name":"ordinalize","namespace":"Integer","comment":"Rails term.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ordinal()","arguments":[]}],"returns":[],"file":"/lib/core/facets/integer/ordinal.rb","line":null,"source":"def ordinal\n  if [11,12,13].include?(self % 100)\n    \"#{self}th\"\n  else\n    case (self % 10)\n    when 1\n      \"#{self}st\"\n    when 2\n      \"#{self}nd\"\n    when 3\n      \"#{self}rd\"\n    else\n      \"#{self}th\"\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#complete":{"!":"method","declarations":["instance","public"],"path":"Kernel#complete","name":"complete","namespace":"Kernel","comment":"Repeat loop until it yeilds false or nil.\n\n  a = [3, 2, 1]\n  b = []\n\n  complete do\n    x = a.pop\n    b << x\n    x\n  end\n\n  b  #=> [1, 2, 3, nil]\n\nBe \"aware\" when using this method, it easy to accidently\ninduce infinite loops.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"complete()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/complete.rb","line":null,"source":"def complete\n  loop { break unless yield }\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#recursively":{"!":"method","declarations":["instance","public"],"path":"Hash#recursively","name":"recursively","namespace":"Hash","comment":"Apply a block to a hash, and recursively apply that block\nto each sub-hash:\n\n  h = {:a=>1, :b=>{:x=>1, :y=>2}}\n  h.recursively.map{ |k,v| [k.to_s, v] }\n  #=> [[\"a\", 1], [\"b\", [[\"y\", 2], [\"x\", 1]]]]\n\nThe recursive iteration can be treated separately from the non-recursive\niteration by passing a block to the #recursive method:\n\n  h = {:a=>1, :b=>{:x=>1, :y=>2}}\n  h.recursively{ |k,v| [k.to_s, v] }.map{ |k,v| [k.to_s, v.to_s] }\n  #=> [[\"a\", \"1\"], [\"b\", [[\"y\", \"2\"], [\"x\", \"1\"]]]]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recursively(*types, &block)","arguments":[{"name":"*types"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/hash/recursively.rb","line":null,"source":"def recursively(*types, &block)\n  Recursor.new(self, *types, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash::Recursor":{"!":"class","superclass":"Enumerable::Recursor","path":"Hash::Recursor","name":"Recursor","namespace":"Hash","comment":":nodoc:","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Hash::Recursor#method_missing"],"accessors":[],"files":["/lib/core/facets/hash/recursively.rb"],"tags":{}},"Hash::Recursor#method_missing":{"!":"method","declarations":["instance","public"],"path":"Hash::Recursor#method_missing","name":"method_missing","namespace":"Hash::Recursor","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(op, &yld)","arguments":[{"name":"op"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/hash/recursively.rb","line":null,"source":"def method_missing(op, &yld)\n  yld = yld    || lambda{ |k,v| [k,v] }  # ? to_enum\n  rec = @block || yld #lambda{ |k,v| [k,v] }\n  @enum.__send__(op) do |k,v|\n    case v\n    when String # b/c of 1.8\n      yld.call(k,v)\n    when *@types\n      res = v.recursively(*@types, &@block).__send__(op,&yld)\n      rec.call(k, res)\n    else\n      yld.call(k,v)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Class#subclasses":{"!":"method","declarations":["instance","public"],"path":"Class#subclasses","name":"subclasses","namespace":"Class","comment":"Returns an array with the direct children of +self+.\n\n  Integer.subclasses # => [Fixnum, Bignum]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"subclasses()","arguments":[]}],"returns":[],"file":"/lib/core/facets/class/subclasses.rb","line":null,"source":"def subclasses\n  list = []\n  ObjectSpace.each_object(Class) do |c|\n    list.unshift c if c.superclass == self\n  end\n  list.uniq\nend","language":"ruby","dynamic":null,"tags":{}},"String#each_char":{"!":"method","declarations":["instance","public"],"path":"String#each_char","name":"each_char","namespace":"String","comment":"Yields a single-character string for each character in the string.\nWhen $KCODE = 'UTF8', multi-byte characters are yielded appropriately.\n\n  a = ''\n  \"HELLO\".each_char{ |c| a << \"#{c.downcase}\" }\n  a  #=> 'hello'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_char()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/each_char.rb","line":null,"source":"def each_char # :yield:\n  scanner, char = StringScanner.new(self), /./mu\n  loop{ yield(scanner.scan(char) || break) }\nend","language":"ruby","dynamic":null,"tags":{}},"String#snakecase":{"!":"method","declarations":["instance","public"],"path":"String#snakecase","name":"snakecase","namespace":"String","comment":"Underscore a string such that camelcase, dashes and spaces are\nreplaced by underscores. This is the reverse of {#camelcase},\nalbeit not an exact inverse.\n\n  \"SnakeCase\".snakecase         #=> \"snake_case\"\n  \"Snake-Case\".snakecase        #=> \"snake_case\"\n  \"Snake Case\".snakecase        #=> \"snake_case\"\n  \"Snake  -  Case\".snakecase    #=> \"snake_case\"\n\nNote, this method no longer converts `::` to `/`, in that case\nuse the {#pathize} method instead.","format":"rdoc","aliases":["String#underscore"],"singleton":null,"interfaces":[{"signature":"snakecase()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/snakecase.rb","line":null,"source":"def snakecase\n  #gsub(/::/, '/').\n  gsub(/([A-Z]+)([A-Z][a-z])/,'\\1_\\2').\n  gsub(/([a-z\\d])([A-Z])/,'\\1_\\2').\n  tr('-', '_').\n  gsub(/\\s/, '_').\n  gsub(/__+/, '_').\n  downcase\nend","language":"ruby","dynamic":null,"tags":{}},"String#underscore":{"!":"method","declarations":["instance","public"],"path":"String#underscore","name":"underscore","namespace":"String","comment":"Underscore a string such that camelcase, dashes and spaces are\nreplaced by underscores. This is the reverse of {#camelcase},\nalbeit not an exact inverse.\n\n  \"SnakeCase\".snakecase         #=> \"snake_case\"\n  \"Snake-Case\".snakecase        #=> \"snake_case\"\n  \"Snake Case\".snakecase        #=> \"snake_case\"\n  \"Snake  -  Case\".snakecase    #=> \"snake_case\"\n\nNote, this method no longer converts `::` to `/`, in that case\nuse the {#pathize} method instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"snakecase()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/snakecase.rb","line":null,"source":"def snakecase\n  #gsub(/::/, '/').\n  gsub(/([A-Z]+)([A-Z][a-z])/,'\\1_\\2').\n  gsub(/([a-z\\d])([A-Z])/,'\\1_\\2').\n  tr('-', '_').\n  gsub(/\\s/, '_').\n  gsub(/__+/, '_').\n  downcase\nend","language":"ruby","dynamic":null,"tags":{}},"File.atomic_open":{"!":"method","declarations":["class","public"],"path":"File.atomic_open","name":"atomic_open","namespace":"File","comment":"Same as `File.open`, but acts on a temporary copy of named\nfile, copying the file back to the original on completion.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"atomic_open(.)","arguments":[{"name":"file_name"},{"name":"mode","default":"\"r\""},{"name":"temp_dir","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/file/atomic_open.rb","line":null,"source":"def self.atomic_open(file_name, mode=\"r\", temp_dir=nil, &block)\n  temp_dir  = temp_dir || Dir.tmpdir\n  temp_file = Tempfile.new(\"#{aomtic_id}-\" + basename(file_name), temp_dir)\n\n  if File.exist?(file_name)\n    FileUtils.cp(file_name, temp_file)\n  end\n\n  open(temp_file, mode, &block)\n\n  FileUtils.cp(temp_file, file_name)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/fileutils/atomic_open'"}},"String#methodize":{"!":"method","declarations":["instance","public"],"path":"String#methodize","name":"methodize","namespace":"String","comment":"Translate a class or module name to a suitable method name.\n\n  \"My::CoolClass\".methodize  #=> \"my__cool_class\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"methodize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/methodize.rb","line":null,"source":"def methodize\n  gsub(/([A-Z]+)([A-Z])/,'\\1_\\2').\n  gsub(/([a-z])([A-Z])/,'\\1_\\2').\n  gsub('/' ,'__').\n  gsub('::','__').\n  downcase\nend","language":"ruby","dynamic":null,"tags":{}},"File.read_binary":{"!":"method","declarations":["class","public"],"path":"File.read_binary","name":"read_binary","namespace":"File","comment":"Read in a file as binary data.\n\nAssuming we had a binary file 'binary.dat'.\n\n  File.read_binary('binary.dat')\n\nCREDIT: George Moschovitis","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"read_binary(.)","arguments":[{"name":"fname"}]}],"returns":[],"file":"/lib/core/facets/file/read_binary.rb","line":null,"source":"def self.read_binary(fname)\n  open(fname, 'rb') do |f|\n    return f.read\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#titlecase":{"!":"method","declarations":["instance","public"],"path":"String#titlecase","name":"titlecase","namespace":"String","comment":"Transform a string into a form that makes for an acceptable title.\n\n  \"this is a string\".titlecase\n  #=> \"This Is A String\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"titlecase()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/titlecase.rb","line":null,"source":"def titlecase\n  tr('_', ' ').\n  gsub(/\\s+/, ' ').\n  gsub(/\\b\\w/){ $`[-1,1] == \"'\" ? $& : $&.upcase }\nend","language":"ruby","dynamic":null,"tags":{"author":"Angelo Lakra (apostrophe fix)"}},"String#briefcase":{"!":"method","declarations":["instance","public"],"path":"String#briefcase","name":"briefcase","namespace":"String","comment":"Transform a string into a sentence like form.\n\n  \"This Is A String\".briefcase\n  #=> \"This is a string\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"briefcase()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/titlecase.rb","line":null,"source":"def briefcase\n  titlecase.capitalize\nend","language":"ruby","dynamic":null,"tags":{}},"Array#each_value":{"!":"method","declarations":["instance","public"],"path":"Array#each_value","name":"each_value","namespace":"Array","comment":"Alias for #each. The intention of this method\nis to provide polymorphism with Hash.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_value","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/each_value.rb","line":null,"source":"alias :each_value :each","language":"ruby","dynamic":null,"tags":{}},"Kernel#returning":{"!":"method","declarations":["instance","public"],"path":"Kernel#returning","name":"returning","namespace":"Kernel","comment":"A Ruby-ized realization of the K combinator.\n\n  book_class = Struct.new(:title, :author)\n\n  book = returning book_class.new do |book|\n    book.title = \"Imperium\"\n    book.author = \"Ulick Varange\"\n  end\n\n  book.class  #=> book_class\n\nTechnically, #returning probably should force the return of\nthe stated object irregardless of any return statements that\nmight appear within it's block. This might differentiate\n#returning from #with, however it also would require\nimplementation in Ruby itself.\n\nCREDIT: Mikael Brockman","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"returning(obj=self)","arguments":[{"name":"obj","default":"self"}]}],"returns":[],"file":"/lib/core/facets/kernel/returning.rb","line":null,"source":"def returning(obj=self) #:yield:\n  yield obj\n  obj\nend","language":"ruby","dynamic":null,"tags":{"yield":""}},"String#word_wrap":{"!":"method","declarations":["instance","public"],"path":"String#word_wrap","name":"word_wrap","namespace":"String","comment":"Word wrap a string not exceeding max width.\n\n  \"this is a test\".word_wrap(4)\n\n_produces_ ...\n\n  this\n  is a\n  test\n\nThis is basic implementation of word wrap, but smart\nenough to suffice for most use cases.\n\nCREDIT: Gavin Kistner, Dayne Broderson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"word_wrap(col_width=80)","arguments":[{"name":"col_width","default":"80"}]}],"returns":[],"file":"/lib/core/facets/string/word_wrap.rb","line":null,"source":"def word_wrap( col_width=80 )\n  self.dup.word_wrap!( col_width )\nend","language":"ruby","dynamic":null,"tags":{}},"String#word_wrap!":{"!":"method","declarations":["instance","public"],"path":"String#word_wrap!","name":"word_wrap!","namespace":"String","comment":"As with #word_wrap, but modifies the string in place.\n\nCREDIT: Gavin Kistner, Dayne Broderson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"word_wrap!(col_width=80)","arguments":[{"name":"col_width","default":"80"}]}],"returns":[],"file":"/lib/core/facets/string/word_wrap.rb","line":null,"source":"def word_wrap!( col_width=80 )\n  self.gsub!( /(\\S{#{col_width}})(?=\\S)/, '\\1 ' )\n  self.gsub!( /(.{1,#{col_width}})(?:\\s+|$)/, \"\\\\1\\n\" )\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"String#camelcase":{"!":"method","declarations":["instance","public"],"path":"String#camelcase","name":"camelcase","namespace":"String","comment":"Converts a string to camelcase. This method leaves the first character\nas given. This allows other methods to be used first, such as #uppercase\nand #lowercase.\n\n  \"camel_case\".camelcase          #=> \"camelCase\"\n  \"Camel_case\".camelcase          #=> \"CamelCase\"\n\nCustom +separators+ can be used to specify the patterns used to determine\nwhere capitalization should occur. By default these are underscores (`_`)\nand space characters (`\\s`).\n\n  \"camel/case\".camelcase('/')     #=> \"camelCase\"\n\nIf the first separator is a symbol, either `:lower` or `:upper`, then\nthe first characters of the string will be downcased or upcased respectively.\n\n  \"camel_case\".camelcase(:upper)  #=> \"CamelCase\"\n\nNote that this implementation is different from ActiveSupport's.\nIf that is what you are looking for you may want {#modulize}.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"camelcase(*separators)","arguments":[{"name":"*separators"}]}],"returns":[],"file":"/lib/core/facets/string/camelcase.rb","line":null,"source":"def camelcase(*separators)\n  case separators.first\n  when Symbol, TrueClass, FalseClass, NilClass\n    first_letter = separators.shift\n  end\n\n  separators = ['_', '\\s'] if separators.empty?\n\n  str = self.dup\n\n  separators.each do |s|\n    str = str.gsub(/(?:#{s}+)([a-z])/){ $1.upcase }\n  end\n\n  case first_letter\n  when :upper, true\n    str = str.gsub(/(\\A|\\s)([a-z])/){ $1 + $2.upcase }\n  when :lower, false\n    str = str.gsub(/(\\A|\\s)([A-Z])/){ $1 + $2.downcase }\n  end\n\n  str\nend","language":"ruby","dynamic":null,"tags":{}},"String#upper_camelcase":{"!":"method","declarations":["instance","public"],"path":"String#upper_camelcase","name":"upper_camelcase","namespace":"String","comment":"Same as +#camelcase+ but converts first letter to uppercase.\n\n  \"camel_case\".upper_camelcase   #=> \"CamelCase\"\n  \"Camel_case\".upper_camelcase   #=> \"CamelCase\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"upper_camelcase(*separators)","arguments":[{"name":"*separators"}]}],"returns":[],"file":"/lib/core/facets/string/camelcase.rb","line":null,"source":"def upper_camelcase(*separators)\n  camelcase(:upper, *separators)\nend","language":"ruby","dynamic":null,"tags":{"deprecated":"Use `#camelcase(:upper)` instead."}},"String#lower_camelcase":{"!":"method","declarations":["instance","public"],"path":"String#lower_camelcase","name":"lower_camelcase","namespace":"String","comment":"Same as +#camelcase+ but converts first letter to lowercase.\n\n  \"camel_case\".lower_camelcase   #=> \"camelCase\"\n  \"Camel_case\".lower_camelcase   #=> \"camelCase\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lower_camelcase(*separators)","arguments":[{"name":"*separators"}]}],"returns":[],"file":"/lib/core/facets/string/camelcase.rb","line":null,"source":"def lower_camelcase(*separators)\n  camelcase(:lower, *separators)\nend","language":"ruby","dynamic":null,"tags":{"deprecated":"Use `#camelcase(:lower)` instead."}},"Hash#update_each":{"!":"method","declarations":["instance","public"],"path":"Hash#update_each","name":"update_each","namespace":"Hash","comment":"Iterates through each pair and updates a the hash\nin place. This is formally equivalent to #mash!\nBut does not use #mash to accomplish the task.\nHence #update_each is probably a touch faster.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update_each()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/update_each.rb","line":null,"source":"def update_each  # :yield:\n  dup.each do |k,v|\n   update(yield(k,v))\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#update_keys":{"!":"method","declarations":["instance","public"],"path":"Hash#update_keys","name":"update_keys","namespace":"Hash","comment":"Iterate over hash updating just the keys.\n\n  h = {:a=>1, :b=>2}\n  h.update_keys{ |k| \"#{k}!\" }\n  h  #=> { \"a!\"=>1, \"b!\"=>2 }","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update_keys()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/update_keys.rb","line":null,"source":"def update_keys #:yield:\n  if block_given?\n    keys.each { |old_key| store(yield(old_key), delete(old_key)) }\n  else\n    to_enum(:update_keys)\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Evgeniy Dolzhenko (bug fix)"}},"String#line_wrap":{"!":"method","declarations":["instance","public"],"path":"String#line_wrap","name":"line_wrap","namespace":"String","comment":"Line wrap at width.\n\n  s = \"1234567890\".line_wrap(5)\n\n  s  #=> \"12345\\n67890\\n\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"line_wrap(width, tabs=4)","arguments":[{"name":"width"},{"name":"tabs","default":"4"}]}],"returns":[],"file":"/lib/core/facets/string/line_wrap.rb","line":null,"source":"def line_wrap(width, tabs=4)\n  s = gsub(/\\t/,' ' * tabs) # tabs default to 4 spaces\n  s = s.gsub(/\\n/,' ')\n  r = s.scan( /.{1,#{width}}/ )\n  r.join(\"\\n\") << \"\\n\"\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#purge":{"!":"method","declarations":["instance","public"],"path":"Enumerable#purge","name":"purge","namespace":"Enumerable","comment":"A versitle compaction method. Like #map but used\nto filter out multiple items in a single step.\n\nWithout +trash+ arguments +nil+ is assumed.\n\n  [1, nil, 2].purge  #=> [1,2]\n\nIf +trash+ arguments are given, each argument is\ncompared for a match using #==.\n\n  (1..6).purge(3,4)  #=> [1,2,5,6]\n\nIf a block is given, the yield is used in the\nmatching condition instead of the element itsef.\n\n  (1..6).purge(0){ |n| n % 2 }  #=> [1,3,5]\n\nNOTE: This could just as well be an override of the\ncore #compact method, but to avoid potential issues\nassociated with overriding core methods we use the\nalternate name #purge.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"purge(*trash, &block)","arguments":[{"name":"*trash"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/purge.rb","line":null,"source":"def purge(*trash, &block)\n  trash = [nil] if trash.empty?\n  r = []\n  if block_given?\n    each do |e|\n      y = yield(e)\n      r << e unless trash.any?{|t| t == y}\n    end\n  else\n    each do |e|\n      r << e unless trash.any?{|t| t == e}\n    end\n  end\n  r\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#qua_class":{"!":"method","declarations":["instance","public"],"path":"Kernel#qua_class","name":"qua_class","namespace":"Kernel","comment":"Easy access to an object qua class, otherwise known as the object's\nsingleton class. #qua_class can also take a block.\n\n  string = \"Hello World\"\n\n  string.qua_class do\n    def important\n       self + \"!\"\n    end\n  end\n\n  string.important  #=> \"Hello World!\"\n\nYes, another one.\n\nCREDIT: Trans","format":"rdoc","aliases":["Kernel#quaclass"],"singleton":null,"interfaces":[{"signature":"qua_class(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/qua_class.rb","line":null,"source":"def qua_class(&block)\n  if block_given?\n    (class << self; self; end).class_eval(&block)\n  else\n    (class << self; self; end)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#quaclass":{"!":"method","declarations":["instance","public"],"path":"Kernel#quaclass","name":"quaclass","namespace":"Kernel","comment":"Easy access to an object qua class, otherwise known as the object's\nsingleton class. #qua_class can also take a block.\n\n  string = \"Hello World\"\n\n  string.qua_class do\n    def important\n       self + \"!\"\n    end\n  end\n\n  string.important  #=> \"Hello World!\"\n\nYes, another one.\n\nCREDIT: Trans\nThe +qua_class+ method can also be written +quaclass+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"qua_class(&block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/qua_class.rb","line":null,"source":"def qua_class(&block)\n  if block_given?\n    (class << self; self; end).class_eval(&block)\n  else\n    (class << self; self; end)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#uppercase":{"!":"method","declarations":["instance","public"],"path":"String#uppercase","name":"uppercase","namespace":"String","comment":"Upcase first letter.\n\nNOTE: One might argue that this method should behave the same as\n+#upcase+ and rather this behavior should be in place of +#captialize+.\nProbably so, but since Matz has already defined +#captialize+ the way\nit is, this name seems most fitting to the missing behavior.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"uppercase()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/uppercase.rb","line":null,"source":"def uppercase\n  str = to_s\n  str[0,1].upcase + str[1..-1]\nend","language":"ruby","dynamic":null,"tags":{}},"String#lowercase":{"!":"method","declarations":["instance","public"],"path":"String#lowercase","name":"lowercase","namespace":"String","comment":"Downcase first letter.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"lowercase()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/uppercase.rb","line":null,"source":"def lowercase\n  str = to_s\n  str[0,1].downcase + str[1..-1]\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#every":{"!":"method","declarations":["instance","public"],"path":"Enumerable#every","name":"every","namespace":"Enumerable","comment":"Returns an elemental object. This allows\nyou to map a method on to every element.\n\n  r = [1,2,3].every + 3\n  r  #=> [4,5,6]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"every()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/every.rb","line":null,"source":"def every\n  per(:map)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#every!":{"!":"method","declarations":["instance","public"],"path":"Enumerable#every!","name":"every!","namespace":"Enumerable","comment":"In place version of #every.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"every!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/every.rb","line":null,"source":"def every!\n  raise NoMethodError unless respond_to?(:map!)\n  per(:map!)\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Hash#argumentize":{"!":"method","declarations":["instance","public"],"path":"Hash#argumentize","name":"argumentize","namespace":"Hash","comment":"Turn a hash into a method arguments.\n\n  h = { :list => [1,2], :base => \"HI\" }\n\nWithout an argument field.\n\n  h.argumentize #=> [ { :list => [1,2], :base => \"HI\" } ]\n\nWith an argument field.\n\n  h.argumentize(:list)   #=> [ 1, 2, { :base => \"HI\" } ]\n  h.argumentize(:base)   #=> [ \"HI\", { :list => [1,2] } ]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"argumentize(args_field=nil)","arguments":[{"name":"args_field","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/hash/argumentize.rb","line":null,"source":"def argumentize(args_field=nil)\n  config = dup\n  if args_field\n    args = [config.delete(args_field)].flatten.compact\n  else\n    args = []\n  end\n  args << config\n  return args\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#count":{"!":"method","declarations":["instance","public"],"path":"Enumerable#count","name":"count","namespace":"Enumerable","comment":"Count the number of items in an enumerable equal (==)\nto the given object(s).\n\n  e = [ 'a', 1, 'a' ]\n\n  e.count(1)       #=> 1\n  e.count('a')     #=> 2\n\nThe method can count more than one item by supplying additional\narguments.\n\n  e.count('a', 1)  #=> 3\n\nA block may also be used to select countable entries.\n\n  e.count{ |x| String === x }  #=> 2\n\nNote that Hash#count only considers values.\n\n  e = { 'a' => 2, 'x' => 2, 'b' => 1 }\n\n  e.count(1)  #=> 1\n  e.count(2)  #=> 2\n\nNOTE: This is one of the few method overrides in Facets.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"count(*items, &block)","arguments":[{"name":"*items"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/count.rb","line":null,"source":"def count(*items, &block)\n  if block || !items.empty?\n    r = self\n    r = r.select(&block) if block\n    r = r.select{ |x| items.any?{ |i| i == x } } if !items.empty?\n    r.size\n  else\n    begin\n      size\n    rescue\n      i=0; each{ |e| i+=1 }; i\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#positive?":{"!":"method","declarations":["instance","public"],"path":"Numeric#positive?","name":"positive?","namespace":"Numeric","comment":"Is a number greater than zero.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"positive?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/numeric/positive.rb","line":null,"source":"def positive?\n  self > 0\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#negative?":{"!":"method","declarations":["instance","public"],"path":"Numeric#negative?","name":"negative?","namespace":"Numeric","comment":"Is a number less than zero.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"negative?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/numeric/positive.rb","line":null,"source":"def negative?\n  self < 0\nend","language":"ruby","dynamic":null,"tags":{}},"String#each_word":{"!":"method","declarations":["instance","public"],"path":"String#each_word","name":"each_word","namespace":"String","comment":"Iterate through each word of a string.\n\n  a = []\n\n  \"list of words\".each_word { |word| a << word }\n\n  a  #=> ['list', 'of', 'words']","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_word(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/string/each_word.rb","line":null,"source":"def each_word(&block)\n  words.each(&block)\nend","language":"ruby","dynamic":null,"tags":{}},"String#index_all":{"!":"method","declarations":["instance","public"],"path":"String#index_all","name":"index_all","namespace":"String","comment":"Like index but returns an array of all index locations.\nThe reuse flag allows the trailing portion of a match to be\nreused for subsquent matches.\n\n  \"abcabcabc\".index_all('a')  #=> [0,3,6]\n\n  \"bbb\".index_all('bb', false)  #=> [0]\n  \"bbb\".index_all('bb', true)   #=> [0,1]\n\nTODO: Culd probably be defined for Indexable in general too.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"index_all(s, reuse=false)","arguments":[{"name":"s"},{"name":"reuse","default":"false"}]}],"returns":[],"file":"/lib/core/facets/string/index_all.rb","line":null,"source":"def index_all(s, reuse=false)\n  s = Regexp.new(Regexp.escape(s)) unless Regexp===s\n  ia = []; i = 0\n  while (i = index(s,i))\n    ia << i\n    i += (reuse ? 1 : $~[0].size)\n  end\n  ia\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#extension":{"!":"method","declarations":["instance","public"],"path":"Kernel#extension","name":"extension","namespace":"Kernel","comment":"Don't say it!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"extension()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/extension.rb","line":null,"source":"def extension\n  class << self; self; end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#__class__":{"!":"method","declarations":["instance","public"],"path":"Kernel#__class__","name":"__class__","namespace":"Kernel","comment":"Defines core method __class__ as an alias of class.\nThis allows you to use #class as your own method, without\nloosing the ability to determine the object's class.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__class__","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/__class__.rb","line":null,"source":"alias_method :__class__, :class","language":"ruby","dynamic":null,"tags":{}},"Module#enclosure":{"!":"method","declarations":["instance","public"],"path":"Module#enclosure","name":"enclosure","namespace":"Module","comment":"Returns the module which contains this one according to its name.\n\n  module ::EncExample\n    module M\n      module N\n      end\n    end\n  end\n\n  EncExample::M::N.enclosure  #=> EncExample::M\n\nThe enclosure of top-level and anonymous modules is Object.\n\n  EncExample.enclosure   #=> Object\n  Module.new.enclosure   #=> Object\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"enclosure()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/enclosure.rb","line":null,"source":"def enclosure\n  name = /::[^:]+\\Z/ =~ self.name ? $` : nil\n  if name\n    #base = name.sub!(/^::/, '') ? Object : self\n    name.split(/::/).inject(self) do |mod, cref|\n      if /\\:(0x.*?)\\>$/ =~ cref   # TODO: does this ever happen?\n        #p $1.to_i(16)\n        ObjectSpace._idref($1.to_i(16))\n      else\n        mod.const_get(cref)\n      end\n    end\n  else\n    Object\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/enclosure'"}},"Module#enclosures":{"!":"method","declarations":["instance","public"],"path":"Module#enclosures","name":"enclosures","namespace":"Module","comment":"Returns all the namespaces of this module according ordered from\nnearest and moving outwards. The receiver is not contained within\nthe result.\n\n  module ::EncExample\n    module M\n      module N\n      end\n    end\n  end\n\n  EncExample.enclosures        #=> [Object]\n  EncExample::M.enclosures     #=> [EncExample, Object]\n  EncExample::M::N.enclosures  #=> [EncExample::M, EncExample, Object]\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"enclosures()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/enclosure.rb","line":null,"source":"def enclosures\n  n = []\n  name.split(/::/).inject(self) do |mod, cref|\n    c = mod.const_get(cref) ; n.unshift(c) ; c\n  end\n  n << Object # ?\n  n.shift # we really don't need +self+ too.\n  n\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/enclosures'"}},"Module#encname":{"!":"method","declarations":["instance","public"],"path":"Module#encname","name":"encname","namespace":"Module","comment":"Enclosure name.\n\n  module ::EncExample\n    module M\n      module N\n      end\n    end\n  end\n\n  EncExample::M::N.encname  #=> \"EncExample::M\"\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"encname()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/enclosure.rb","line":null,"source":"def encname\n  /::[^:]+\\Z/ =~ self.name ? $` : nil\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/enclosure'"}},"Module#spacename":{"!":"method","declarations":["instance","public"],"path":"Module#spacename","name":"spacename","namespace":"Module","comment":"Returns the name of module's container module.\n\n  module ::SpaceName\n    class Example\n    end\n  end\n\n  SpaceName::Example.name         #=> \"SpaceName::Example\"\n  SpaceName::Example.spacename    #=> \"SpaceName\"\n\nThis used to be called +dirname+.\n\nSee also Module#basename.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"spacename()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/spacename.rb","line":null,"source":"def spacename\n  name[0...(name.rindex('::') || 0)]\n  #name.gsub(/::[^:]*$/, '')\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#deep_copy":{"!":"method","declarations":["instance","public"],"path":"Kernel#deep_copy","name":"deep_copy","namespace":"Kernel","comment":"Anything that can be marshaled can be copied in totality.\n\n  \"ABC\".deep_copy  #=> \"ABC\"\n\nNOTE: Not sure why we wouldn't just call this #copy, but\nthe term +deep_copy+ seems to be the common practive.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deep_copy()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/deep_copy.rb","line":null,"source":"def deep_copy\n  Marshal::load(Marshal::dump(self))\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#deep_clone":{"!":"method","declarations":["instance","public"],"path":"Kernel#deep_clone","name":"deep_clone","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"deep_clone(cache={})","arguments":[{"name":"cache","default":"{}"}]}],"returns":[],"file":"/lib/core/facets/kernel/deep_copy.rb","line":null,"source":"def deep_clone(cache={})\n  return cache[self] if cache.key?(self) #@deep_cloning_obj if @deep_cloning\n  copy = clone\n  cache[self] = copy #@deep_cloning_obj = clone\n  copy.instance_variables.each do |var|\n    val = instance_variable_get(var)\n    begin\n      #@deep_cloning = true\n      val = val.deep_clone(cache)\n    rescue TypeError\n      next\n    ensure\n      #@deep_cloning = false\n    end\n    copy.instance_variable_set(var, val)\n    #@deep_cloning_obj.instance_variable_set(var, val)\n  end\n  #deep_cloning_obj = @deep_cloning_obj\n  #@deep_cloning_obj = nil\n  #deep_cloning_obj\n  copy\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#defer":{"!":"method","declarations":["instance","public"],"path":"Enumerable#defer","name":"defer","namespace":"Enumerable","comment":"Without a block: wrap the Enumerable object in such a way that map,\nselect and similar operations are performed \"horizontally\" across a\nseries of blocks, instead of building an array of results at each step.\nThis reduces memory usage, allows partial results to be provided\nearly, and permits working with infinite series.\n\n  a = (1..1_000_000_000).defer.select{ |i| i % 2 == 0 }.\n                               map{ |i| i + 100 }.\n                               take(10).to_a\n\nWith a block: the block acts as an arbitrary filter on the data. Unlike\nmap, it can choose to drop elements from the result, and/or add\nadditional ones. The first object passed to the block is the receiver\nof the output.\n\n  (1..1_000_000_000).\n    defer { |out,i| out << i if i % 2 == 0 }.  # like select\n    defer { |out,i| out << i + 100 }.          # like map\n    take(10).to_a\n\nUse a method like to_a or to_h at the end of the chain when you want an\nArray or Hash built with the results, or each{...} if you just want\nto output each result and discard it.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"defer(&blk)","arguments":[],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/enumerable/defer.rb","line":null,"source":"def defer(&blk)\n  if block_given?\n    Denumerator.new do |output|\n      each do |*input|\n        yield(output, *input)\n      end\n    end\n  else\n    Denumerator.new do |output|\n      each do |*input|\n        output.yield(*input)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#meta_eval":{"!":"method","declarations":["instance","public"],"path":"Kernel#meta_eval","name":"meta_eval","namespace":"Kernel","comment":"Evaluate code in a metaclass. This is equivalent to:\n\n  meta_class.instance_eval(...)\n\nCREDIT: WhyTheLuckyStiff","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"meta_eval(str=nil, *file_and_line, &blk)","arguments":[{"name":"str","default":"nil"},{"name":"*file_and_line"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/meta_eval.rb","line":null,"source":"def meta_eval(str=nil, *file_and_line, &blk)\n  if str\n    meta_class.instance_eval(str, *file_and_line)\n  else\n    meta_class.instance_eval(&blk)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Numeric#distance":{"!":"method","declarations":["instance","public"],"path":"Numeric#distance","name":"distance","namespace":"Numeric","comment":"Returns the distance between self an another value.\nThis is the same as #- but it provides an alternative\nfor common naming between variant classes.\n\n  4.distance(3)  #=> 1","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"distance(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/numeric/distance.rb","line":null,"source":"def distance(other)\n  self - other\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#occur":{"!":"method","declarations":["instance","public"],"path":"Enumerable#occur","name":"occur","namespace":"Enumerable","comment":"Returns an array of elements for the elements that occur n times.\nOr according to the results of a given block.\n\n  a = [1,1,2,3,3,4,5,5]\n\n  a.occur(1).sort               #=> [2,4]\n  a.occur(2).sort               #=> [1,3,5]\n  a.occur(3).sort               #=> []\n\n  a.occur(1..1).sort            #=> [2,4]\n  a.occur(2..3).sort            #=> [1,3,5]\n\n  a.occur { |n| n == 1 }.sort   #=> [2,4]\n  a.occur { |n| n > 1 }.sort    #=> [1,3,5]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"occur(n=nil)","arguments":[{"name":"n","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/enumerable/occur.rb","line":null,"source":"def occur(n=nil) #:yield:\n  result = Hash.new { |hash, key| hash[key] = Array.new }\n  self.each do |item|\n    key = item\n    result[key] << item\n  end\n  if block_given?\n    result.reject! { |key, values| ! yield(values.size) }\n  else\n    raise ArgumentError unless n\n    if Range === n\n      result.reject! { |key, values| ! n.include?(values.size) }\n    else\n      result.reject! { |key, values| values.size != n }\n    end\n  end\n  return result.values.flatten.uniq\nend","language":"ruby","dynamic":null,"tags":{}},"Module#integrate":{"!":"method","declarations":["instance","public"],"path":"Module#integrate","name":"integrate","namespace":"Module","comment":"Using integrate is just like using include except the\nmodule included is a reconstruction of the one given\naltered by the commands given in the block.\n\nConvenient commands available are: #rename, #redef,\n#remove, #nodef and #wrap. But any module method\ncan be used.\n\n  module IntegrateExampleModule\n    def q ; \"q\" ; end\n    def y ; \"y\" ; end\n  end\n\n  class InegrateExampleClass\n    integrate IntegrateExampleModule do\n      undef_method :y\n    end\n  end\n\n  x = InegrateExampleClass.new\n  x.q  #=> \"q\"\n\n  expect NameError do\n    x.y\n  end\n\nThis is like #revisal, but #revisal only\nreturns the reconstructred module. It does not\ninclude it.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"integrate(mod, &block)","arguments":[{"name":"mod"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/module/integrate.rb","line":null,"source":"def integrate(mod, &block)\n  #include mod.revisal( &blk )\n  m = Module.new{ include mod }\n  m.class_eval(&block)\n  include m\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#ewise":{"!":"method","declarations":["instance","public"],"path":"Enumerable#ewise","name":"ewise","namespace":"Enumerable","comment":"Returns an elementwise Functor designed to make R-like\nelementwise operations possible. This is very much like\nthe #every method, but it treats array argument specially.\n\n  ([1,2].ewise + 3)          #=> [4,5]\n\nVector to vector\n\n  ([1,2].ewise + [4,5])      #=> [5,7]\n\nSpecial thanks to Martin DeMello for helping to develop this.","format":"rdoc","aliases":["Enumerable#elementwise"],"singleton":null,"interfaces":[{"signature":"ewise(count=1)","arguments":[{"name":"count","default":"1"}]}],"returns":[],"file":"/lib/core/facets/enumerable/ewise.rb","line":null,"source":"def ewise(count=1)\n  Functor.new do |op,*args|\n    if args.empty?\n      r = self\n      count.times do\n        r = r.collect{ |a| a.send(op) }\n      end\n      r\n    else\n      r = args.collect do |arg|\n        if Array === arg #arg.kind_of?(Enumerable)\n          x = self\n          count.times do\n            ln = (arg.length > length ? length : arg.length )\n            x = x.slice(0...ln)\n            x = x.zip(arg[0...ln])\n            x = x.collect{ |a,b| a.send(op,b) }  #x = x.collect{ |a,b| b ? a.send(op,b) : nil }\n          end\n          x\n        else\n          x = self\n          count.times do\n            x = x.collect{ |a| a.send(op,arg) }\n          end\n          x\n        end\n      end\n      r.flatten! if args.length == 1\n      r\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#elementwise":{"!":"method","declarations":["instance","public"],"path":"Enumerable#elementwise","name":"elementwise","namespace":"Enumerable","comment":"Returns an elementwise Functor designed to make R-like\nelementwise operations possible. This is very much like\nthe #every method, but it treats array argument specially.\n\n  ([1,2].ewise + 3)          #=> [4,5]\n\nVector to vector\n\n  ([1,2].ewise + [4,5])      #=> [5,7]\n\nSpecial thanks to Martin DeMello for helping to develop this.\nLong-term for #ewise.\n\n  a = [1,2]\n  (a.elementwise + 3)          #=> [4,5]\n  (a.elementwise + [4,5])      #=> [5,7]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"ewise(count=1)","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/ewise.rb","line":null,"source":"def ewise(count=1)\n  Functor.new do |op,*args|\n    if args.empty?\n      r = self\n      count.times do\n        r = r.collect{ |a| a.send(op) }\n      end\n      r\n    else\n      r = args.collect do |arg|\n        if Array === arg #arg.kind_of?(Enumerable)\n          x = self\n          count.times do\n            ln = (arg.length > length ? length : arg.length )\n            x = x.slice(0...ln)\n            x = x.zip(arg[0...ln])\n            x = x.collect{ |a,b| a.send(op,b) }  #x = x.collect{ |a,b| b ? a.send(op,b) : nil }\n          end\n          x\n        else\n          x = self\n          count.times do\n            x = x.collect{ |a| a.send(op,arg) }\n          end\n          x\n        end\n      end\n      r.flatten! if args.length == 1\n      r\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#methodize":{"!":"method","declarations":["instance","public"],"path":"Module#methodize","name":"methodize","namespace":"Module","comment":"Translate a module name to a suitable method name.\n\n  module ::EgMethodize\n    module Eg\n    end\n  end\n\n  EgMethodize.methodize      #=> \"eg_methodize\"\n  EgMethodize::Eg.methodize  #=> \"eg_methodize__eg\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"methodize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/methodize.rb","line":null,"source":"def methodize\n  name.methodize\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#graph":{"!":"method","declarations":["instance","public"],"path":"Enumerable#graph","name":"graph","namespace":"Enumerable","comment":"Like `#map`/`#collect`, but generates a Hash. The block is expected\nto return two values: the key and the value for the new hash.\n\n  numbers  = (1..3)\n  squares  = numbers.graph{ |n| [n, n*n] }   # { 1=>1, 2=>4, 3=>9 }\n  sq_roots = numbers.graph{ |n| [n*n, n] }   # { 1=>1, 4=>2, 9=>3 }\n\nCREDIT: Andrew Dudzik (adudzik), Trans","format":"rdoc","aliases":["Enumerable#mash"],"singleton":null,"interfaces":[{"signature":"graph(&yld)","arguments":[],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/enumerable/graph.rb","line":null,"source":"def graph(&yld)\n  if yld\n    h = {}\n    each do |*kv|\n      r = yld[*kv]\n      case r\n      when Hash\n        nk, nv = *r.to_a[0]\n      when Range\n        nk, nv = r.first, r.last\n      else\n        nk, nv = *r\n      end\n      h[nk] = nv\n    end\n    h\n  else\n    Enumerator.new(self,:graph)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#mash":{"!":"method","declarations":["instance","public"],"path":"Enumerable#mash","name":"mash","namespace":"Enumerable","comment":"Like `#map`/`#collect`, but generates a Hash. The block is expected\nto return two values: the key and the value for the new hash.\n\n  numbers  = (1..3)\n  squares  = numbers.graph{ |n| [n, n*n] }   # { 1=>1, 2=>4, 3=>9 }\n  sq_roots = numbers.graph{ |n| [n*n, n] }   # { 1=>1, 4=>2, 9=>3 }\n\nCREDIT: Andrew Dudzik (adudzik), Trans\nAlias for #graph, which stands for \"map hash\".","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"graph(&yld)","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/graph.rb","line":null,"source":"def graph(&yld)\n  if yld\n    h = {}\n    each do |*kv|\n      r = yld[*kv]\n      case r\n      when Hash\n        nk, nv = *r.to_a[0]\n      when Range\n        nk, nv = r.first, r.last\n      else\n        nk, nv = *r\n      end\n      h[nk] = nv\n    end\n    h\n  else\n    Enumerator.new(self,:graph)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#preextend":{"!":"method","declarations":["instance","public"],"path":"Module#preextend","name":"preextend","namespace":"Module","comment":"Prepend an +aspect+ module to a module.\nThis only works at the module level.\n\n  module ::PreX\n    def x; \"x\"; end\n  end\n\n  module ::PreU\n    def x; '{' + super + '}'; end\n  end\n\n  PreX.preextend(PreU)\n\n  PreX.x  # => \"{x}\"\n\nNOTE: This is not a common core extension and is not loaded\nautomatically when using <code>require 'facets'</code>.\n\nCREDIT Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"preextend(aspect)","arguments":[{"name":"aspect"}]}],"returns":[],"file":"/lib/core/facets/module/preextend.rb","line":null,"source":"def preextend(aspect)\n  aspect.__send__(:include, self)\n  extend aspect\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/preextend'"}},"Enumerable#visit":{"!":"method","declarations":["instance","public"],"path":"Enumerable#visit","name":"visit","namespace":"Enumerable","comment":"Recursively iterate over all Enumerable elements, or\nsubset given :type=>[type1, type2, ...].\n\n  [1, 2, 8..9].visit{ |x| x.succ }\n  # => [2, 3, [9, 10]]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"visit(opts={}, &block)","arguments":[{"name":"opts","default":"{}"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/visit.rb","line":null,"source":"def visit(opts={}, &block)\n  type = opts[:type] ? [opts[:type]].flatten : [Enumerable]\n  skip = opts[:skip]\n\n  map do |v|\n    case v\n    when String # b/c of 1.8\n      block.call(v)\n    when *type\n      v.visit(opts, &block)\n    else\n      if skip && Enumerable === v\n        v\n      else\n        block.call(v)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#identical?":{"!":"method","declarations":["instance","public"],"path":"Kernel#identical?","name":"identical?","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"identical?","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/identical.rb","line":null,"source":"alias_method :identical?, :equal?","language":"ruby","dynamic":null,"tags":{}},"Regexp#multiline?":{"!":"method","declarations":["instance","public"],"path":"Regexp#multiline?","name":"multiline?","namespace":"Regexp","comment":"Is a regular expression multiline?\n\n  /x/.multiline?   #=> false\n  /x/m.multiline?  #=> true","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiline?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/regexp/multiline.rb","line":null,"source":"def multiline?\n  options & MULTILINE == MULTILINE\nend","language":"ruby","dynamic":null,"tags":{}},"Exception":{"!":"class","superclass":"Object","path":"Exception","name":"Exception","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Exception.raised?","Exception#detail","Exception.suppress","Exception.error_print","Exception#error_print"],"accessors":[],"files":["/lib/core/facets/exception/raised.rb","/lib/core/facets/exception/detail.rb","/lib/core/facets/exception/suppress.rb","/lib/core/facets/exception/error_print.rb"],"tags":{}},"Exception.raised?":{"!":"method","declarations":["class","public"],"path":"Exception.raised?","name":"raised?","namespace":"Exception","comment":"Does a block raise an a given +exception+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"raised?(.)","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/exception/raised.rb","line":null,"source":"def self.raised? #:yeild:\n  begin\n    yield\n    false\n  rescue self\n    true\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#anonymous?":{"!":"method","declarations":["instance","public"],"path":"Module#anonymous?","name":"anonymous?","namespace":"Module","comment":"A module may or may not have a name.\n\nmodule M; end\nM.name # => \"M\"\n\nm = Module.new\nm.name # => \"\"\n\nA module gets a name when it is first assigned to a constant. Either\nvia the +module+ or +class+ keyword or by an explicit assignment:\n\nm = Module.new # creates an anonymous module\nM = m # => m gets a name here as a side-effect\nm.name # => \"M\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"anonymous?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/module/anonymous.rb","line":null,"source":"def anonymous?\n  # The name of an anonymous class is an empty\n  # string in 1.8, and nil in 1.9.\n  name.nil? || name.empty?\nend","language":"ruby","dynamic":null,"tags":{}},"Exception#detail":{"!":"method","declarations":["instance","public"],"path":"Exception#detail","name":"detail","namespace":"Exception","comment":"Pretty string output of exception/error object useful for helpful\ndebug messages.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"detail()","arguments":[]}],"returns":[],"file":"/lib/core/facets/exception/detail.rb","line":null,"source":"def detail\n  if backtrace\n    %{#{self.class.name}: #{message}\\n  #{backtrace.join(\"\\n  \")}\\n  LOGGED FROM: #{caller[0]}}\n  else\n    %{#{self.class.name}: #{message}\\n  LOGGED FROM: #{caller[0]}}\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"George Moschovitis"}},"Integer#multiple?":{"!":"method","declarations":["instance","public"],"path":"Integer#multiple?","name":"multiple?","namespace":"Integer","comment":"Is +self+ a multiple of a given number?\n\n  7.multiple?(2)  #=> false\n  8.multiple?(2)  #=> true\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"multiple?(number)","arguments":[{"name":"number"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/integer/multiple.rb","line":null,"source":"def multiple?(number)\n  if number.zero?\n    zero? ? true : false\n  else\n    self % number == 0\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Comparable.[]":{"!":"method","declarations":["class","public"],"path":"Comparable.[]","name":"[]","namespace":"Comparable","comment":"Automatically generate comparitive definitions based on\nattribute fields.\n\n  include Comparable[:a, :b]\n\nis equivalent to including a module containing:\n\n  def <=>(other)\n    cmp = self.a <=> other.a; return cmp unless cmp == 0\n    cmp = self.b <=> other.b; return cmp unless cmp == 0\n    0\n  end","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](.)","arguments":[{"name":"*accessors"}]}],"returns":[],"file":"/lib/core/facets/comparable/op_get.rb","line":null,"source":"def self.[](*accessors)\n  Module.new do\n    include Comparable\n    define_method(:comparability){ accessors }\n    define_method(:<=>) do |other|\n      comparability.each do |a|\n        cmp = (send(a) <=> other.send(a))\n        break cmp unless cmp == 0\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#incase?":{"!":"method","declarations":["instance","public"],"path":"Enumerable#incase?","name":"incase?","namespace":"Enumerable","comment":"The same as #include? but tested using #=== instead of #==.\n\n  [1, 2, \"a\"].incase?(2)       #=> true\n  [1, 2, \"a\"].incase?(String)  #=> true\n  [1, 2, \"a\"].incase?(3)       #=> false\n\nWhy the name `incase`? Because the method uses case-equality.\nAlong with the alliteration for \"in case\" and the similarity\nwith \"include?\", it seemed like the perfect fit.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"incase?(what)","arguments":[{"name":"what"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/enumerable/incase.rb","line":null,"source":"def incase?(what)\n  any? { |x| what === x }\nend","language":"ruby","dynamic":null,"tags":{"author":"Lavir the Whiolet"}},"Enumerable#filter":{"!":"method","declarations":["instance","public"],"path":"Enumerable#filter","name":"filter","namespace":"Enumerable","comment":"The block acts as an arbitrary filter on the data. Unlike map,\nit can choose to drop elements from the result and/or add\nadditional elements. The first object passed to the block is\nthe receiver of the output.\n\n  x = (1..10000)\n  x = x.filter{ |out,i| out << i if i % 2 == 0 }   # like select\n  x = x.filter{ |out,i| out << i + 100 }           # like map\n  x = x.take(3)\n\n  x  #=> [102, 104, 106]\n\nThis is very similar to #each_with_object, but #filter handles\nargument better by reversing their order and using the splat\noperator. (This was also once known as #injecting.)\n\nCREDIT: David Black, Louis J Scoras","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"filter(output=[])","arguments":[{"name":"output","default":"[]"}]}],"returns":[],"file":"/lib/core/facets/enumerable/filter.rb","line":null,"source":"def filter(output=[]) #:yeild:\n  if block_given?\n    each do |*input|\n      yield(output, *input)\n    end\n    output\n  else\n    to_enum(:filter)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#map_by":{"!":"method","declarations":["instance","public"],"path":"Enumerable#map_by","name":"map_by","namespace":"Enumerable","comment":"Like #group_by, but maps the second value returned from the block.\n\n  a = [1,2,3,4,5]\n  a.map_by{ |e| [e % 2, e + 1] }\n  #=> { 0=>[3,5], 1=>[2,4,6] }\n\nWorks well with a hash too.\n\n  h = {\"A\"=>1, \"B\"=>1, \"C\"=>1, \"D\"=>2, \"E\"=>2}\n  h.map_by{ |k,v| [v, k.downcase] }\n  #=> {1=>[\"a\", \"b\", \"c\"], 2=>[\"d\", \"e\"]}\n\nIf a second value is not returned, #map_by acts like #group_by.\n\n  h = {\"A\"=>1, \"B\"=>1, \"C\"=>1, \"D\"=>2, \"E\"=>2}\n  h.map_by{ |k,v| v }\n  #=> {1=>[[\"A\",1], [\"B\",1], [\"C\",1]], 2=>[[\"D\",2], [\"E\",2]]}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"map_by()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/map_by.rb","line":null,"source":"def map_by #:yield:\n  res = {}\n  each do |a|\n    k,v = yield(*a)\n    if v\n      (res[k] ||= []) << v\n    else\n      (res[k] ||= []) << a\n    end\n  end\n  res\nend","language":"ruby","dynamic":null,"tags":{}},"Array#permutation":{"!":"method","declarations":["instance","public"],"path":"Array#permutation","name":"permutation","namespace":"Array","comment":"Permutation provids the possible orders of an enumerable.\nEach is indexed by a permutation number. The maximum number of\narrangements is the factorial of the size of the array.\n\n   [1,2].permutation(2).to_a #=> [[1,2], [2,1]]\n\nCREDIT: Shin-ichiro Hara","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"permutation(n=size)","arguments":[{"name":"n","default":"size"}]}],"returns":[],"file":"/lib/core/facets/array/permutation.rb","line":null,"source":"def permutation(n=size)\n  if size < n or n < 0\n  elsif n == 0\n    yield([])\n  else\n    self[1..-1].permutation(n - 1) do |x|\n      (0...n).each do |i|\n        yield(x[0...i] + [first] + x[i..-1])\n      end\n    end\n    self[1..-1].permutation(n) do |x|\n      yield(x)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#combination":{"!":"method","declarations":["instance","public"],"path":"Array#combination","name":"combination","namespace":"Array","comment":"Yields the block to each unique combination of _n_ elements.\n\n  a = %w|a b c d|\n  a.combination(3)\n\nproduces\n\n  [[\"a\", \"b\", \"c\"],\n   [\"a\", \"b\", \"d\"],\n   [\"a\", \"c\", \"d\"],\n   [\"b\", \"c\", \"d\"]]\n\nCREDIT: Florian Gross","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"combination(k=2)","arguments":[{"name":"k","default":"2"}]}],"returns":[],"file":"/lib/core/facets/array/combination.rb","line":null,"source":"def combination(k=2)\n  if block_given?\n    s = to_a\n    n = s.size\n    return unless (1..n) === k\n    idx = (0...k).to_a\n    loop do\n      yield s.values_at(*idx)\n      i = k - 1\n      i -= 1 while idx[i] == n - k + i\n      break if i < 0\n      idx[i] += 1\n      (i + 1 ... k).each {|j| idx[j] = idx[i] + j - i}\n    end\n  else\n    to_enum(:combination, k)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#commonality":{"!":"method","declarations":["instance","public"],"path":"Array#commonality","name":"commonality","namespace":"Array","comment":"Returns all items that are equal in terms of the supplied block.\nIf no block is given objects are considered to be equal if they\nreturn the same value for Object#hash and if obj1 == obj2.\n\n  [1, 2, 2, 3, 4, 4].commonality  #=> { 2 => [2, 2], 4 => [4, 4] }\n\n  [\"foo\", \"bar\", \"a\"].commonality { |str| str.length }\n  #=> { 3 => [\"foo\", \"bar\"] }\n\nThis can be useful, for instance, in determining all persons that share\ntheir last name with another person ...\n\n  persons.collisions { |person| person.last_name }\n\nCREDIT: Florian Gross","format":"rdoc","aliases":["Array#collisions"],"singleton":null,"interfaces":[{"signature":"commonality(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/commonality.rb","line":null,"source":"def commonality(&block)\n  had_no_block = !block\n  block ||= lambda { |item| item }\n  result = Hash.new { |hash, key| hash[key] = Array.new }\n  each do |item|\n    key = block.call(item)\n    result[key] << item\n  end\n  result.reject! do |key, values|\n    values.size <= 1\n  end\n  # -- return had_no_block ? result.values.flatten : result\n  return result\nend","language":"ruby","dynamic":null,"tags":{}},"Array#collisions":{"!":"method","declarations":["instance","public"],"path":"Array#collisions","name":"collisions","namespace":"Array","comment":"Returns all items that are equal in terms of the supplied block.\nIf no block is given objects are considered to be equal if they\nreturn the same value for Object#hash and if obj1 == obj2.\n\n  [1, 2, 2, 3, 4, 4].commonality  #=> { 2 => [2, 2], 4 => [4, 4] }\n\n  [\"foo\", \"bar\", \"a\"].commonality { |str| str.length }\n  #=> { 3 => [\"foo\", \"bar\"] }\n\nThis can be useful, for instance, in determining all persons that share\ntheir last name with another person ...\n\n  persons.collisions { |person| person.last_name }\n\nCREDIT: Florian Gross","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"commonality(&block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/commonality.rb","line":null,"source":"def commonality(&block)\n  had_no_block = !block\n  block ||= lambda { |item| item }\n  result = Hash.new { |hash, key| hash[key] = Array.new }\n  each do |item|\n    key = block.call(item)\n    result[key] << item\n  end\n  result.reject! do |key, values|\n    values.size <= 1\n  end\n  # -- return had_no_block ? result.values.flatten : result\n  return result\nend","language":"ruby","dynamic":null,"tags":{}},"Struct#attributes":{"!":"method","declarations":["instance","public"],"path":"Struct#attributes","name":"attributes","namespace":"Struct","comment":"Returns a hash containing the names and values\nfor all instance settings in the Struct.\n\nThis will eventually be deprecated in favor of #to_h.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attributes()","arguments":[]}],"returns":[],"file":"/lib/core/facets/struct/attributes.rb","line":null,"source":"def attributes\n  h = {}\n  each_pair { |k,v| h[k] = v }\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Array#recursively":{"!":"method","declarations":["instance","public"],"path":"Array#recursively","name":"recursively","namespace":"Array","comment":"Apply a method to array, and recursively apply that method\nto each sub-array or +types+.\n\n  arr = [\"a\", [\"b\", \"c\"]]\n  arr.recursively.map{ |v| v.to_sym }\n  #=> [:a, [:b, :c]]\n\nBy default the sub-types are passed thru uneffected. Passing a block\nto #recursively changes this.\n\n  arr = [\"a\", [\"b\", \"c\"]]\n  arr.recursively{ |a| a.reverse }.map{ |v| v.to_sym }\n  #=> [:a, [:c, :b]]\n\nTODO: Return Enumerator if no +yld+ block is given ?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recursively(*types, &block)","arguments":[{"name":"*types"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/recursively.rb","line":null,"source":"def recursively(*types, &block)\n  Recursor.new(self, *types, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"String#start_with?":{"!":"method","declarations":["instance","public"],"path":"String#start_with?","name":"start_with?","namespace":"String","comment":"Does a string start with the given prefix?\n\n  \"hello\".start_with?(\"he\")    #=> true\n  \"hello\".start_with?(\"to\")    #=> false\n\nNote: This definition is better than standard Ruby's\nbecuase it handles regular expressions.\n\nCREDIT: Juris Galang","format":"rdoc","aliases":["String#starts_with?"],"singleton":null,"interfaces":[{"signature":"start_with?(prefix)","arguments":[{"name":"prefix"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/string/start_with.rb","line":null,"source":"def start_with?(prefix)\n  prefix = Regexp.escape(prefix.to_s) unless Regexp===prefix\n  /^#{prefix}/.match(self) ? true : false\nend","language":"ruby","dynamic":null,"tags":{}},"String#end_with?":{"!":"method","declarations":["instance","public"],"path":"String#end_with?","name":"end_with?","namespace":"String","comment":"Does a string end with the given suffix?\n\n  \"hello\".end_with?(\"lo\")    #=> true\n  \"hello\".end_with?(\"to\")    #=> false\n\nNote: This definition is better than standard Ruby's\nbecuase it handles regular expressions.\n\nCREDIT: Juris Galang","format":"rdoc","aliases":["String#ends_with?"],"singleton":null,"interfaces":[{"signature":"end_with?(suffix)","arguments":[{"name":"suffix"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/string/start_with.rb","line":null,"source":"def end_with?(suffix)\n  suffix = Regexp.escape(suffix.to_s) unless Regexp===suffix\n  /#{suffix}$/.match(self) ? true : false\nend","language":"ruby","dynamic":null,"tags":{}},"String#starts_with?":{"!":"method","declarations":["instance","public"],"path":"String#starts_with?","name":"starts_with?","namespace":"String","comment":"Does a string start with the given prefix?\n\n  \"hello\".start_with?(\"he\")    #=> true\n  \"hello\".start_with?(\"to\")    #=> false\n\nNote: This definition is better than standard Ruby's\nbecuase it handles regular expressions.\n\nCREDIT: Juris Galang\nend","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"start_with?(prefix)","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/start_with.rb","line":null,"source":"def start_with?(prefix)\n  prefix = Regexp.escape(prefix.to_s) unless Regexp===prefix\n  /^#{prefix}/.match(self) ? true : false\nend","language":"ruby","dynamic":null,"tags":{}},"String#ends_with?":{"!":"method","declarations":["instance","public"],"path":"String#ends_with?","name":"ends_with?","namespace":"String","comment":"Does a string end with the given suffix?\n\n  \"hello\".end_with?(\"lo\")    #=> true\n  \"hello\".end_with?(\"to\")    #=> false\n\nNote: This definition is better than standard Ruby's\nbecuase it handles regular expressions.\n\nCREDIT: Juris Galang","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"end_with?(suffix)","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/start_with.rb","line":null,"source":"def end_with?(suffix)\n  suffix = Regexp.escape(suffix.to_s) unless Regexp===suffix\n  /#{suffix}$/.match(self) ? true : false\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#expand":{"!":"method","declarations":["instance","public"],"path":"Enumerable#expand","name":"expand","namespace":"Enumerable","comment":"Expand all elements of an Enumerable object.\n\n  [0, 2..3, 5..7].expand  #=> [0,[2, 3],[5,6,7]]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"expand()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/expand.rb","line":null,"source":"def expand\n  map do |x|\n   (Enumerable === x ? x.expand : x)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#factorial":{"!":"method","declarations":["instance","public"],"path":"Integer#factorial","name":"factorial","namespace":"Integer","comment":"Calculate the factorial of an integer.\n\n  2.factorial  #=> 2\n  3.factorial  #=> 6\n  4.factorial  #=> 24\n\nCREDIT: Malte Milatz","format":"rdoc","aliases":["Integer#fac"],"singleton":null,"interfaces":[{"signature":"factorial()","arguments":[]}],"returns":[],"file":"/lib/core/facets/integer/factorial.rb","line":null,"source":"def factorial\n  return 1 if zero?\n  f = 1\n  2.upto(self) { |n| f *= n }\n  f\nend","language":"ruby","dynamic":null,"tags":{}},"Integer#fac":{"!":"method","declarations":["instance","public"],"path":"Integer#fac","name":"fac","namespace":"Integer","comment":"Calculate the factorial of an integer.\n\n  2.factorial  #=> 2\n  3.factorial  #=> 6\n  4.factorial  #=> 24\n\nCREDIT: Malte Milatz","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"factorial()","arguments":[]}],"returns":[],"file":"/lib/core/facets/integer/factorial.rb","line":null,"source":"def factorial\n  return 1 if zero?\n  f = 1\n  2.upto(self) { |n| f *= n }\n  f\nend","language":"ruby","dynamic":null,"tags":{}},"Module#class_def":{"!":"method","declarations":["instance","public"],"path":"Module#class_def","name":"class_def","namespace":"Module","comment":"Defines an instance method within a class/module.\n\nCREDIT: WhyTheLuckyStiff","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_def(name, &blk)","arguments":[{"name":"name"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/module/module_def.rb","line":null,"source":"def class_def name, &blk\n  class_eval { define_method name, &blk }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#module_def":{"!":"method","declarations":["instance","public"],"path":"Module#module_def","name":"module_def","namespace":"Module","comment":"Defines an instance method within a class/module.\n\nCREDIT: WhyTheLuckyStiff","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"module_def(name, &blk)","arguments":[{"name":"name"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/module/module_def.rb","line":null,"source":"def module_def name, &blk\n  module_eval { define_method name, &blk }\nend","language":"ruby","dynamic":null,"tags":{}},"Array#probability":{"!":"method","declarations":["instance","public"],"path":"Array#probability","name":"probability","namespace":"Array","comment":"Generates a hash mapping each unique element in the array to the\nrelative frequency, i.e. the probablity, of it appearence.\n\n  [:a, :b, :c, :c].probability  #=> {:a=> 0.25, :b=>0.25, :c=>0.5}\n\nCREDIT: Brian Schrder","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"probability()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/probability.rb","line":null,"source":"def probability\n  probs = Hash.new(0.0)\n  size = 0.0\n  each do |e|\n    probs[e] += 1.0\n    size += 1.0\n  end\n  probs.keys.each{ |e| probs[e] /= size }\n  probs\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#meta_alias":{"!":"method","declarations":["instance","public"],"path":"Kernel#meta_alias","name":"meta_alias","namespace":"Kernel","comment":"Alias a method defined in the metaclass (ie. singleton class).\n\n  class MetaExample\n    def self.y?; \"y?\" ; end\n  end\n\n  MetaExample.meta_alias \"ynot?\", \"y?\"\n\n  MetaExample.ynot?  #=> \"y?\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"meta_alias(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/kernel/meta_alias.rb","line":null,"source":"def meta_alias(*args)\n  meta_class do\n    alias_method(*args)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Class#descendants":{"!":"method","declarations":["instance","public"],"path":"Class#descendants","name":"descendants","namespace":"Class","comment":"List all descedents of this class.\n\n  class A ; end\n  class B < A; end\n  class C < A; end\n  A.descendants  #=> [B,C]\n\nYou may also limit the generational distance the subclass may be from\nthe parent class.\n\n  class X ; end\n  class Y < X; end\n  class Z < Y; end\n  X.descendants    #=> [Y,Z]\n  X.descendants(1) #=> [Y]\n\nNOTE: This is a intensive operation. Do not expect it to be very fast.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"descendants(generations=-1))","arguments":[{"name":"generations","default":"-1)"}]}],"returns":[],"file":"/lib/core/facets/class/descendants.rb","line":null,"source":"def descendants(generations=-1)\n  descendants = []\n  subclasses.each do |k|\n    descendants << k\n    if generations != 1\n      descendants.concat(k.descendants(generations - 1))\n    end\n  end\n  descendants\nend","language":"ruby","dynamic":null,"tags":{"author":"Roger Pack"}},"Class#preallocate":{"!":"method","declarations":["instance","public"],"path":"Class#preallocate","name":"preallocate","namespace":"Class","comment":"Designate aspect modules to be added to a object at instantiation.\n\n  class Firetruck\n    def put_out_fire(option)\n      \"Put out #{option}\"\n    end\n  end\n\n  module FastFiretruck\n    def put_out_fire(option)\n      super(\"very #{option}!\")\n    end\n  end\n\n  Firetruck.preallocate(FastFiretruck)\n\n  ft = Firetruck.new\n  ft.put_out_fire('fast') #=> \"Put out very fast!\"\n\nThis method is very similar to the idea of #prepend, but it has some\nlimitations in that it works by overriding #new and #allocate and extends\nan object with the aspect modules on instantiation. A true #prepend\nimplementation would not have to do this --but would be a natural part\nof the class heirarchy instead. For this reason, this method has been\nnamed #preallocate, rather than #prepend.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"preallocate(aspect)","arguments":[{"name":"aspect"}]}],"returns":[],"file":"/lib/core/facets/class/preallocate.rb","line":null,"source":"def preallocate(aspect)\n  _new      = method(:new)\n  _allocate = method(:allocate)\n  (class << self; self; end).class_eval do\n    define_method(:new) do |*args|\n      o = _new.call(*args)\n      o.extend aspect\n      o\n    end\n    define_method(:allocate) do |*args|\n      o = _allocate.call(*args)\n      o.extend aspect\n      o\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/class/preallocate'"}},"String#characters":{"!":"method","declarations":["instance","public"],"path":"String#characters","name":"characters","namespace":"String","comment":"Returns an array of characters.\n\n  \"abc\".characters.to_a  #=> [\"a\",\"b\",\"c\"]\n\nTODO: Probably should make this an enumerator. With #scan?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"characters()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/characters.rb","line":null,"source":"def characters\n  split(//)\nend","language":"ruby","dynamic":null,"tags":{}},"FileTest#contains?":{"!":"method","declarations":["instance","public"],"path":"FileTest#contains?","name":"contains?","namespace":"FileTest","comment":"Does the +parent+ contain the +child+?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"contains?(child, parent=Dir.pwd)","arguments":[{"name":"child"},{"name":"parent","default":"Dir.pwd"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/filetest/contains.rb","line":null,"source":"def contains?(child, parent=Dir.pwd)\n  parent = File.expand_path(parent)\n  child = File.expand_path(child)\n  child.sub(parent,'') != child\nend","language":"ruby","dynamic":null,"tags":{}},"FileTest#absolute?":{"!":"method","declarations":["instance","public"],"path":"FileTest#absolute?","name":"absolute?","namespace":"FileTest","comment":"Predicate method for testing whether a path is absolute.\nIt returns +true+ if the pathname begins with a slash.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"absolute?(path)","arguments":[{"name":"path"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/filetest/relative.rb","line":null,"source":"def absolute?(path)\n  !relative?(path)\nend","language":"ruby","dynamic":null,"tags":{}},"FileTest#relative?":{"!":"method","declarations":["instance","public"],"path":"FileTest#relative?","name":"relative?","namespace":"FileTest","comment":"The opposite of #absolute?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"relative?(path)","arguments":[{"name":"path"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/filetest/relative.rb","line":null,"source":"def relative?(path)\n  while r = chop_basename(path.to_s)\n    path, basename = r\n  end\n  path == ''\nend","language":"ruby","dynamic":null,"tags":{}},"FileTest#chop_basename":{"!":"method","declarations":["instance","public"],"path":"FileTest#chop_basename","name":"chop_basename","namespace":"FileTest","comment":"List File.split, but preserves the file separators.\n\n  FileTest.chop_basename('/usr/lib') #=> ['/usr/', 'lib']\n  FileTest.chop_basename('/') #=> nil\n\nReturns Array of `[pre-basename, basename]` or `nil`.\n\nThis method is here simply to support the #relative? and #absolute? methods.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"chop_basename(path)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/filetest/relative.rb","line":null,"source":"def chop_basename(path)\n  base = File.basename(path)\n  if /\\A#{SEPARATOR_PATTERN}?\\z/ =~ base\n    return nil\n  else\n    return path[0, path.rindex(base)], base\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"File.atomic_write":{"!":"method","declarations":["class","public"],"path":"File.atomic_write","name":"atomic_write","namespace":"File","comment":"Write to a file atomically. Useful for situations where you don't\nwant other processes or threads to see half-written files.\n\n  File.atomic_write(\"important.txt\") do |file|\n    file.write(\"hello\")\n  end\n\nIf your temporary directory is not on the same filesystem as the file you're\ntrying to write, you can provide a different temporary directory.\n\n  File.atomic_write(\"important.txt\", \"tmp\") do |file|\n    file.write(\"hello\")\n  end\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: David Heinemeier Hansson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"atomic_write(.)","arguments":[{"name":"file_name"},{"name":"temp_dir","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/file/atomic_write.rb","line":null,"source":"def self.atomic_write(file_name, temp_dir=nil)\n  temp_dir  = temp_dir || Dir.tmpdir\n  temp_file = Tempfile.new(basename(file_name), temp_dir)\n\n  yield temp_file\n  temp_file.close\n\n  begin\n    ## Get original file permissions\n    old_stat = stat(file_name)\n  rescue Errno::ENOENT\n    ## No old permissions, write a temp file to determine the defaults\n    check_name = join(dirname(file_name), \".permissions_check.#{Thread.current.object_id}.#{Process.pid}.#{rand(1000000)}\")\n    open(check_name, \"w\") { }\n    old_stat = stat(check_name)\n    unlink(check_name)\n  end\n\n  ## Overwrite original file with temp file\n  FileUtils.mv(temp_file.path, file_name)\n\n  ## Set correct permissions on new file\n  chown(old_stat.uid, old_stat.gid, file_name)\n  chmod(old_stat.mode, file_name)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/fileutils/atomic_write'","yield":""}},"String#expand_tabs":{"!":"method","declarations":["instance","public"],"path":"String#expand_tabs","name":"expand_tabs","namespace":"String","comment":"Expands tabs to +n+ spaces. Non-destructive. If +n+ is 0,\nthen tabs are simply removed. Raises an exception if +n+\nis negative.\n\n  \"\\t\\tHey\".expand_tabs(2)  #=> \"    Hey\"\n\nThanks to GGaramuno for a more efficient algorithm. Very nice.\n\nCREDIT: Gavin Sinclair, Noah Gibbs, GGaramuno\n\nTODO: Don't much care for the name String#expand_tabs.\nWhat about a more concise name like #detab?","format":"rdoc","aliases":["String#expand_tab"],"singleton":null,"interfaces":[{"signature":"expand_tabs(n=8)","arguments":[{"name":"n","default":"8"}]}],"returns":[],"file":"/lib/core/facets/string/expand_tab.rb","line":null,"source":"def expand_tabs(n=8)\n  n = n.to_int\n  raise ArgumentError, \"n must be >= 0\" if n < 0\n  return gsub(/\\t/, \"\") if n == 0\n  return gsub(/\\t/, \" \") if n == 1\n  str = self.dup\n  while\n    str.gsub!(/^([^\\t\\n]*)(\\t+)/) { |f|\n      val = ( n * $2.size - ($1.size % n) )\n      $1 << (' ' * val)\n    }\n  end\n  str\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"String#expand_tab":{"!":"method","declarations":["instance","public"],"path":"String#expand_tab","name":"expand_tab","namespace":"String","comment":"Expands tabs to +n+ spaces. Non-destructive. If +n+ is 0,\nthen tabs are simply removed. Raises an exception if +n+\nis negative.\n\n  \"\\t\\tHey\".expand_tabs(2)  #=> \"    Hey\"\n\nThanks to GGaramuno for a more efficient algorithm. Very nice.\n\nCREDIT: Gavin Sinclair, Noah Gibbs, GGaramuno\n\nTODO: Don't much care for the name String#expand_tabs.\nWhat about a more concise name like #detab?\nSingular form of #expand_tabs.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"expand_tabs(n=8)","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/expand_tab.rb","line":null,"source":"def expand_tabs(n=8)\n  n = n.to_int\n  raise ArgumentError, \"n must be >= 0\" if n < 0\n  return gsub(/\\t/, \"\") if n == 0\n  return gsub(/\\t/, \" \") if n == 1\n  str = self.dup\n  while\n    str.gsub!(/^([^\\t\\n]*)(\\t+)/) { |f|\n      val = ( n * $2.size - ($1.size % n) )\n      $1 << (' ' * val)\n    }\n  end\n  str\nend","language":"ruby","dynamic":null,"tags":{}},"Symbol#variablize":{"!":"method","declarations":["instance","public"],"path":"Symbol#variablize","name":"variablize","namespace":"Symbol","comment":"Prepend an \"@\" to the beginning of a symbol to make a instance\nvariable name. This also replaces non-valid characters with underscores.\n\n  :a.variablize  #=> :\"@a\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"variablize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/symbol/variablize.rb","line":null,"source":"def variablize\n  name = to_s.gsub(/\\W/, '_')\n  \"@#{name}\".to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"String#variablize":{"!":"method","declarations":["instance","public"],"path":"String#variablize","name":"variablize","namespace":"String","comment":"Prepend an \"@\" to the beginning of a string\nto make a instance variable name. This also replaces\nnon-valid characters with underscores.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"variablize()","arguments":[]}],"returns":[],"file":"/lib/core/facets/string/variablize.rb","line":null,"source":"def variablize\n  v = gsub(/\\W/, '_')\n  \"@#{v}\"\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#__method__":{"!":"method","declarations":["instance","private"],"path":"Kernel#__method__","name":"__method__","namespace":"Kernel","comment":"Retreive the current running method name.\n\n  def method_example\n    __method__\n  end\n\n  method_example  #=> :method_example\n\nTechnically __callee__ should provided alias names,\nwhere __method__ should not. But we'll have to\nleave that distinction to Ruby 1.9+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__method__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/__method__.rb","line":null,"source":"def __method__\n  /\\`([^\\']+)\\'/.match(caller(1).first)[1].to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#__callee__":{"!":"method","declarations":["instance","private"],"path":"Kernel#__callee__","name":"__callee__","namespace":"Kernel","comment":"Retreive the current running method name.\n\n  def callee_example\n    __callee__\n  end\n\n  callee_example  #=> :callee_example\n\nTechnically __callee__ should provided alias names,\nwhere as __method__ should not. But we'll have to\nleave that distinction to Ruby 1.9+.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__callee__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/__method__.rb","line":null,"source":"def __callee__\n  /\\`([^\\']+)\\'/.match(caller(1).first)[1].to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"String#similarity":{"!":"method","declarations":["instance","public"],"path":"String#similarity","name":"similarity","namespace":"String","comment":"A fuzzy matching mechanism. Returns a score from 0-1, based\non the number of shared edges. To be effective, the strings\nmust be of length 2 or greater.\n\n  \"Alexsander\".similarity(\"Aleksander\")  #=> 0.9\n\nThe way it works:\n\n1. Converts each string into a \"graph like\" object, with edges ...\n\n    \"alexsander\" -> [ alexsander, alexsand, alexsan ... lexsand ... san ... an, etc ]\n    \"aleksander\" -> [ aleksander, aleksand ... etc. ]\n\n2. Perform match, then remove any subsets from this matched set (i.e. a hit\non \"san\" is a subset of a hit on \"sander\") ...\n\n    Above example, once reduced -> [ ale, sander ]\n\n3. See's how many of the matches remain, and calculates a score based\non how many matches, their length, and compare to the length of the\nlarger of the two words.\n\nStill a bit rough. Any suggestions for improvement are welcome.\n\nCREDIT: Derek Lewis.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"similarity(str_in)","arguments":[{"name":"str_in"}]}],"returns":[],"file":"/lib/core/facets/string/similarity.rb","line":null,"source":"def similarity(str_in)\n  return 0 if str_in == nil\n  return 1 if self == str_in\n\n  # -- make a graph of each word (okay, its not a true graph, but is similar)\n  graph_A = Array.new\n  graph_B = Array.new\n\n  # -- \"graph\" self\n  last = self.length\n  (0..last).each do |ff|\n    loc  = self.length\n    break if ff == last - 1\n    wordB = (1..(last-1)).to_a.reverse!\n    if (wordB != nil)\n      wordB.each do |ss|\n        break if ss == ff\n        graph_A.push( \"#{self[ff..ss]}\" )\n      end\n    end\n  end\n\n  # -- \"graph\" input string\n  last = str_in.length\n  (0..last).each{ |ff|\n    loc  = str_in.length\n    break if ff == last - 1\n    wordB = (1..(last-1)).to_a.reverse!\n    wordB.each do |ss|\n      break if ss == ff\n      graph_B.push( \"#{str_in[ff..ss]}\" )\n    end\n  }\n\n  # -- count how many of these \"graph edges\" we have that are the same\n  matches = graph_A & graph_B\n\n  #--\n  #matches = Array.new\n  #graph_A.each{ |aa| matches.push(aa) if( graph_B.include?(aa) ) }\n  #++\n\n  # -- for eliminating subsets, we want to start with the smallest hits.\n  matches.sort!{|x,y| x.length <=> y.length}\n\n  # -- eliminate any subsets\n  mclone = matches.dup\n  mclone.each_index do |ii|\n    reg = Regexp.compile( Regexp.escape(mclone[ii]) )\n    count = 0.0\n    matches.each{|xx| count += 1 if xx =~ reg}\n    matches.delete(mclone[ii]) if count > 1\n  end\n\n  score = 0.0\n  matches.each{ |mm| score += mm.length }\n  self.length > str_in.length ? largest = self.length : largest = str_in.length\n  return score/largest\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#trap_chain":{"!":"method","declarations":["instance","public"],"path":"Kernel#trap_chain","name":"trap_chain","namespace":"Kernel","comment":"Calling Kernel#trap() by itself will replace any previously registered\nhandler code. Kernel#trap_chain(), on the other hand, will add the block\nyou supply to the existing \"list\" of registered handler blocks. Similar\nto the way Kernel#at_exit() works, Kernel#trap_chain() will prepend the\ngiven block to the call chain for the given signal_name. When the signal\noccurs, your block will be executed first and then the previously\nregistered handler will be invoked. This can be called repeatedly\nto create a \"chain\" of handlers. \n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Tyler Rick","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"trap_chain(signal_name, *args, &block)","arguments":[{"name":"signal_name"},{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/trap_chain.rb","line":null,"source":"def trap_chain(signal_name, *args, &block)\n  previous_interrupt_handler = trap(signal_name, *args) {}\n  trap(signal_name, *args) do\n    block.call\n    previous_interrupt_handler.call unless previous_interrupt_handler == \"DEFAULT\"\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/kernel/trap_chain'"}},"String#cleanlines":{"!":"method","declarations":["instance","public"],"path":"String#cleanlines","name":"cleanlines","namespace":"String","comment":"Returns an Enumerator for iterating over each\nline of the string, stripped of whitespace on\neither side.\n\n  \"this\\nthat\\nother\\n\".cleanlines.to_a  #=> ['this', 'that', 'other']","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cleanlines(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/string/cleanlines.rb","line":null,"source":"def cleanlines(&block)\n  if block\n    scan(/^.*?$/) do |line|\n      block.call(line.strip)\n    end\n  else\n    str = self\n    Enumerator.new do |output|\n      str.scan(/^.*?$/) do |line|\n        output.yield(line.strip)\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#meta_class":{"!":"method","declarations":["instance","public"],"path":"Kernel#meta_class","name":"meta_class","namespace":"Kernel","comment":"Easy access to an object's \"special\" class, otherwise known as it's\nsingleton class, eigenclass, adhoc class or object-qua-class.","format":"rdoc","aliases":["Kernel#metaclass"],"singleton":null,"interfaces":[{"signature":"meta_class(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/meta_class.rb","line":null,"source":"def meta_class(&block)\n  if block_given?\n    (class << self; self; end).class_eval(&block)\n  else\n    (class << self; self; end)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#metaclass":{"!":"method","declarations":["instance","public"],"path":"Kernel#metaclass","name":"metaclass","namespace":"Kernel","comment":"Easy access to an object's \"special\" class, otherwise known as it's\nsingleton class, eigenclass, adhoc class or object-qua-class.\n\nThe non-underscored form of #meta_class if faily common.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"meta_class(&block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/meta_class.rb","line":null,"source":"def meta_class(&block)\n  if block_given?\n    (class << self; self; end).class_eval(&block)\n  else\n    (class << self; self; end)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#replace_each":{"!":"method","declarations":["instance","public"],"path":"Hash#replace_each","name":"replace_each","namespace":"Hash","comment":"Same as #update_each, but deletes the key element first.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"replace_each()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/replace_each.rb","line":null,"source":"def replace_each  # :yield:\n  dup.each do |k,v|\n    delete(k)\n    update(yield(k,v))\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#eigenclass":{"!":"method","declarations":["instance","public"],"path":"Kernel#eigenclass","name":"eigenclass","namespace":"Kernel","comment":"During this trying time when no one can get their\ntechie catchwords to stick to the refrigerator no\nmatter how hard they slap it with the enchanted\nmagnetic spatula, its good to know that the\ncontrived phrases really do fly, graceful and\nunclasped and bearing north toward chilled shrimp.\nI know what my Halloween pumpkin is going to say.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: WhyTheLuckyStiff","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"eigenclass()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/eigenclass.rb","line":null,"source":"def eigenclass\n  (class << self; self; end)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/kernel/eigenclass'"}},"Kernel#pp_callstack":{"!":"method","declarations":["instance","public"],"path":"Kernel#pp_callstack","name":"pp_callstack","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pp_callstack","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/call_stack.rb","line":null,"source":"alias_method :pp_callstack, :caller","language":"ruby","dynamic":null,"tags":{}},"Kernel#pp_call_stack":{"!":"method","declarations":["instance","public"],"path":"Kernel#pp_call_stack","name":"pp_call_stack","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"pp_call_stack","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/call_stack.rb","line":null,"source":"alias_method :pp_call_stack, :caller","language":"ruby","dynamic":null,"tags":{}},"Kernel#call_stack":{"!":"method","declarations":["instance","public"],"path":"Kernel#call_stack","name":"call_stack","namespace":"Kernel","comment":"Parse a caller string and break it into its components,\nreturning an array composed of:\n\n* file (String)\n* lineno (Integer)\n* method (Symbol)\n\nFor example, from irb\n\n  call_stack(1)\n\n_produces_ ...\n\n  [[\"(irb)\", 2, :irb_binding],\n   [\"/usr/lib/ruby/1.8/irb/workspace.rb\", 52, :irb_binding],\n   [\"/usr/lib/ruby/1.8/irb/workspace.rb\", 52, nil]]\n\nNote: If the user decides to redefine caller() to output data\nin a different format, _prior_ to requiring this, then the\nresults will be indeterminate.\n\nCREDIT: Trans","format":"rdoc","aliases":["Kernel#callstack"],"singleton":null,"interfaces":[{"signature":"call_stack(level = 1)","arguments":[{"name":"level","default":"1"}]}],"returns":[],"file":"/lib/core/facets/kernel/call_stack.rb","line":null,"source":"def call_stack(level = 1)\n  call_str_array = pp_call_stack(level)\n  stack = []\n  call_str_array.each{ |call_str|\n    file, lineno, method = call_str.split(':')\n    if method =~ /in `(.*)'/ then\n      method = $1.intern()\n    end\n    stack << [file, lineno.to_i, method]\n  }\n  stack\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#callstack":{"!":"method","declarations":["instance","public"],"path":"Kernel#callstack","name":"callstack","namespace":"Kernel","comment":"Parse a caller string and break it into its components,\nreturning an array composed of:\n\n* file (String)\n* lineno (Integer)\n* method (Symbol)\n\nFor example, from irb\n\n  call_stack(1)\n\n_produces_ ...\n\n  [[\"(irb)\", 2, :irb_binding],\n   [\"/usr/lib/ruby/1.8/irb/workspace.rb\", 52, :irb_binding],\n   [\"/usr/lib/ruby/1.8/irb/workspace.rb\", 52, nil]]\n\nNote: If the user decides to redefine caller() to output data\nin a different format, _prior_ to requiring this, then the\nresults will be indeterminate.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"call_stack(level = 1)","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/call_stack.rb","line":null,"source":"def call_stack(level = 1)\n  call_str_array = pp_call_stack(level)\n  stack = []\n  call_str_array.each{ |call_str|\n    file, lineno, method = call_str.split(':')\n    if method =~ /in `(.*)'/ then\n      method = $1.intern()\n    end\n    stack << [file, lineno.to_i, method]\n  }\n  stack\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#call_stack":{"!":"method","declarations":["instance","public"],"path":"Binding#call_stack","name":"call_stack","namespace":"Binding","comment":"Returns the call stack, in array format.","format":"rdoc","aliases":["Binding#callstack"],"singleton":null,"interfaces":[{"signature":"call_stack(level=1)","arguments":[{"name":"level","default":"1"}]}],"returns":[],"file":"/lib/core/facets/kernel/call_stack.rb","line":null,"source":"def call_stack(level=1)\n  eval( \"callstack( #{level} )\" )\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#callstack":{"!":"method","declarations":["instance","public"],"path":"Binding#callstack","name":"callstack","namespace":"Binding","comment":"Returns the call stack, in array format.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"call_stack(level=1)","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/call_stack.rb","line":null,"source":"def call_stack(level=1)\n  eval( \"callstack( #{level} )\" )\nend","language":"ruby","dynamic":null,"tags":{}},"Module#attr_tester":{"!":"method","declarations":["instance","public"],"path":"Module#attr_tester","name":"attr_tester","namespace":"Module","comment":"Create an tester attribute. This creates a single method\nused to test the attribute for truth.\n\n  attr_tester :a\n\nis equivalent to\n\n  def a?\n    @a ? true : @a\n  end\n\nNote that this method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_tester(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/attr_tester.rb","line":null,"source":"def attr_tester(*args)\n  code, made = '', []\n  args.each do |a|\n    code << %{\n      def #{a}?(truth=nil)\n        @#{a} ? truth || @#{a} : @#{a}\n      end\n    }\n    made << \"#{a}?\".to_sym\n  end\n  module_eval code\n  made\nend","language":"ruby","dynamic":null,"tags":{"todo":"This method will probably be deprecated.","uncommon":"require 'facets/module/attr_tester'"}},"Module#alias_tester":{"!":"method","declarations":["instance","public"],"path":"Module#alias_tester","name":"alias_tester","namespace":"Module","comment":"Create aliases for flag reader.\n\nNote that this method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_tester(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/attr_tester.rb","line":null,"source":"def alias_tester(*args)\n  orig = args.last\n  args = args - [orig]\n  args.each do |name|\n    alias_method(\"#{name}?\", \"#{orig}?\")\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/attr_tester'"}},"Kernel#require_all":{"!":"method","declarations":["instance","public"],"path":"Kernel#require_all","name":"require_all","namespace":"Kernel","comment":"Require a pattern of files relatvie to the current file.\nThis makes is easy to require an entire directory, for instance:\n\n  require_all 'core_ext/*'\n\nNOTE: This method used to allow glob-based requires from the $LOAD_PATH,\nbut this was deprecated in favor of relative requiring only, as it is\nconsider the typical usecase, and globbing from the $LOAD_PATH is a\nbit dangerous. Better options exist for globbing the $LOAD_PATH such as\nthe +plugins+ gem.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"require_all(pattern)","arguments":[{"name":"pattern"}]}],"returns":[],"file":"/lib/core/facets/kernel/require_all.rb","line":null,"source":"def require_all(pattern)\n  c = caller.first\n  fail \"Can't parse #{c}\" unless c.rindex(/:\\d+(:in `.*')?$/)\n  file = $` # File.dirname(c)\n  if /\\A\\((.*)\\)/ =~ file # eval, etc.\n    raise LoadError, \"require_relative is called in #{$1}\"\n  end\n  glob = File.expand_path(pattern, File.dirname(file))\n  Dir.glob(glob).each do |absolute|\n    require absolute\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#load_all":{"!":"method","declarations":["instance","public"],"path":"Kernel#load_all","name":"load_all","namespace":"Kernel","comment":"Same as #require_all, but for #load.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"load_all(pattern, safe=nil)","arguments":[{"name":"pattern"},{"name":"safe","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/kernel/require_all.rb","line":null,"source":"def load_all(pattern, safe=nil)\n  c = caller.first\n  fail \"Can't parse #{c}\" unless c.rindex(/:\\d+(:in `.*')?$/)\n  file = $` # File.dirname(c)\n  if /\\A\\((.*)\\)/ =~ file # eval, etc.\n    raise LoadError, \"require_relative is called in #{$1}\"\n  end\n  glob = File.expand_path(pattern, File.dirname(file))\n  Dir.glob(glob).each do |absolute|\n    load absolute, safe\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#module_load":{"!":"method","declarations":["instance","public"],"path":"Module#module_load","name":"module_load","namespace":"Module","comment":"Load file directly into module/class namespace.\n\nPlease use this with careful consideration.\nIt is best suited to loading plugin-type scripts,\nand should generally not be used as a substitue for\nRuby's standard load system.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#class_load"],"singleton":null,"interfaces":[{"signature":"module_load(path)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/module/module_load.rb","line":null,"source":"def module_load( path )\n  if path =~ /^[\\/~.]/\n    file = File.expand_path(path)\n  else\n    $LOAD_PATH.each do |lp|\n      file = File.join(lp,path)\n      break if File.exist?(file)\n      file = nil\n    end\n  end\n  raise LoadError, \"no such file to load -- #{path}\" unless file\n  module_eval(File.read(file))\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/module_load'","raise":""}},"Module#module_require":{"!":"method","declarations":["instance","public"],"path":"Module#module_require","name":"module_require","namespace":"Module","comment":"Require file into module/class namespace.\n\nUnlike load this keeps a per-module cache and will\nnot load the same file into the same module more\nthan once despite repeated attempts.\n\nThe cache is kept in a global var called +$module_require+.\n\nPlease use this with careful consideration.\nIt is best suited to loading plugin-type scripts,\nand should generally not be used as a substitue for\nRuby's standard load system.\n\nNOTE: This method is not a common core extension and is not loaded\nautomatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#class_require"],"singleton":null,"interfaces":[{"signature":"module_require(path)","arguments":[{"name":"path"}]}],"returns":[],"file":"/lib/core/facets/module/module_load.rb","line":null,"source":"def module_require( path )\n  if path =~ /^[\\/~.]/\n    file = File.expand_path(path)\n  else\n    $LOAD_PATH.each do |lp|\n      file = File.join(lp,path)\n      break if File.exist?(file)\n      file += '.rb'\n      break if File.exist?(file)\n      file = nil\n    end\n  end\n  raise LoadError, \"no such file to load -- #{path}\" unless file\n  # per-module load cache\n  $module_require ||= {}\n  $module_require[self] ||= {}\n  loaded = $module_require[self]\n  if loaded.key?(file)\n    false\n  else\n    loaded[file] = true\n    script = File.read(file)\n    module_eval(script)\n    true\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/module_load'","raise":""}},"Module#class_require":{"!":"method","declarations":["instance","public"],"path":"Module#class_require","name":"class_require","namespace":"Module","comment":"Require file into module/class namespace.\n\nUnlike load this keeps a per-module cache and will\nnot load the same file into the same module more\nthan once despite repeated attempts.\n\nThe cache is kept in a global var called +$module_require+.\n\nPlease use this with careful consideration.\nIt is best suited to loading plugin-type scripts,\nand should generally not be used as a substitue for\nRuby's standard load system.\n\nNOTE: This method is not a common core extension and is not loaded\nautomatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"module_require(path)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/module_load.rb","line":null,"source":"def module_require( path )\n  if path =~ /^[\\/~.]/\n    file = File.expand_path(path)\n  else\n    $LOAD_PATH.each do |lp|\n      file = File.join(lp,path)\n      break if File.exist?(file)\n      file += '.rb'\n      break if File.exist?(file)\n      file = nil\n    end\n  end\n  raise LoadError, \"no such file to load -- #{path}\" unless file\n  # per-module load cache\n  $module_require ||= {}\n  $module_require[self] ||= {}\n  loaded = $module_require[self]\n  if loaded.key?(file)\n    false\n  else\n    loaded[file] = true\n    script = File.read(file)\n    module_eval(script)\n    true\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/module_load'"}},"Module#class_load":{"!":"method","declarations":["instance","public"],"path":"Module#class_load","name":"class_load","namespace":"Module","comment":"Load file directly into module/class namespace.\n\nPlease use this with careful consideration.\nIt is best suited to loading plugin-type scripts,\nand should generally not be used as a substitue for\nRuby's standard load system.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"module_load(path)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/module_load.rb","line":null,"source":"def module_load( path )\n  if path =~ /^[\\/~.]/\n    file = File.expand_path(path)\n  else\n    $LOAD_PATH.each do |lp|\n      file = File.join(lp,path)\n      break if File.exist?(file)\n      file = nil\n    end\n  end\n  raise LoadError, \"no such file to load -- #{path}\" unless file\n  module_eval(File.read(file))\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/module_load'"}},"Kernel#temporarily":{"!":"method","declarations":["instance","public"],"path":"Kernel#temporarily","name":"temporarily","namespace":"Kernel","comment":"Temporarily set variables while yielding a block, then return the\nvariables to their original settings when complete.\n\n  temporarily('$VERBOSE'=>false) do\n    $VERBOSE.assert == false\n  end","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"temporarily(settings)","arguments":[{"name":"settings"}]}],"returns":[],"file":"/lib/core/facets/kernel/temporarily.rb","line":null,"source":"def temporarily(settings) #:yield:\n  cache = {}\n  settings.each do |var, val|\n    cache[var] = eval(\"#{var}\")\n    eval(\"proc{ |v| #{var} = v }\").call(val)\n  end\n  yield\nensure\n  cache.each do |var, val|\n    eval(\"proc{ |v| #{var} = v }\").call(val)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String.interpolate":{"!":"method","declarations":["class","public"],"path":"String.interpolate","name":"interpolate","namespace":"String","comment":"Interpolate. Provides a means of extenally using Ruby string\ninterpolation mechinism.\n\n  try = \"hello\"\n  str = \"\\#{try}!!!\"\n  String.interpolate{ str }    #=> \"hello!!!\"\n\nNOTE: The block neccessary in order to get then binding of the caller.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"interpolate(.)","arguments":[],"block":{"name":"&str"}}],"returns":[],"file":"/lib/core/facets/string/interpolate.rb","line":null,"source":"def self.interpolate(&str)\n  eval \"%{#{str.call}}\", str.binding\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition":{"!":"class","superclass":"Object","path":"Method::Composition","name":"Composition","namespace":"Method","comment":"Method Composition class acts a proxy for composed methods.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Method::Composition#initialize","Method::Composition#*","Method::Composition#^","Method::Composition#owner","Method::Composition#receiver","Method::Composition#inspect","Method::Composition#arity","Method::Composition#to_proc","Method::Composition#call","Method::Composition#[]"],"accessors":[],"files":["/lib/core/facets/method/composition.rb"],"tags":{"author":"Mike Burns"}},"Method::Composition#initialize":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#initialize","name":"initialize","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(f,g)","arguments":[{"name":"f"},{"name":"g"}]}],"returns":[{"type":"Composition","comment":"a new instance of Composition"}],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def initialize(f,g)\n  @f = f\n  @g = g\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#*":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#*","name":"*","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"*(h)","arguments":[{"name":"h"}]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def *(h)\n  Composition.new(self, h)\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#^":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#^","name":"^","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"^(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def ^(n)\n  return self if n < 2\n  Composition.new(self, self ^ (n-1))\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#owner":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#owner","name":"owner","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"owner()","arguments":[]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def owner\n  @g.owner\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#receiver":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#receiver","name":"receiver","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"receiver()","arguments":[]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def receiver\n  @g.receiver\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#inspect":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#inspect","name":"inspect","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def inspect\n  \"#<Method::Composition: #{@f.inspect} * #{@g.inspect}>\"\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#arity":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#arity","name":"arity","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"arity()","arguments":[]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def arity\n  @g.arity\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#to_proc":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#to_proc","name":"to_proc","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"to_proc()","arguments":[]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def to_proc\n  Proc.new {|x| @f.call(*@g.call(*x)) }\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#call":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#call","name":"call","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"call(x)","arguments":[{"name":"x"}]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def call(x)\n  @f.call(*@g.call(*x))\nend","language":"ruby","dynamic":null,"tags":{}},"Method::Composition#[]":{"!":"method","declarations":["instance","public"],"path":"Method::Composition#[]","name":"[]","namespace":"Method::Composition","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[](*x)","arguments":[{"name":"*x"}]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def [](*x)\n  call(*x)\nend","language":"ruby","dynamic":null,"tags":{}},"Method#*":{"!":"method","declarations":["instance","public"],"path":"Method#*","name":"*","namespace":"Method","comment":"Method composition.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"*(g)","arguments":[{"name":"g"}]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def *(g)\n  Composition.new(self, g)\nend","language":"ruby","dynamic":null,"tags":{"author":"Mike Burns"}},"Method#^":{"!":"method","declarations":["instance","public"],"path":"Method#^","name":"^","namespace":"Method","comment":"Method repetition.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"^(n)","arguments":[{"name":"n"}]}],"returns":[],"file":"/lib/core/facets/method/composition.rb","line":null,"source":"def ^(n)\n  if n < 2\n    self\n  else\n    Composistion.new(self, self ^ (n-1))\n  end\nend","language":"ruby","dynamic":null,"tags":{"author":"Mike Burns"}},"Hash#delete_values":{"!":"method","declarations":["instance","public"],"path":"Hash#delete_values","name":"delete_values","namespace":"Hash","comment":"Minor modification to Ruby's Hash#delete method\nallowing it to take multiple keys.\n\n  hsh = { :a => 1, :b => 2 }\n  hsh.delete_values(1)\n  hsh  #=> { :b => 2 }\n\nReturns a list of keys of the deleted entries.\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_values(*values)","arguments":[{"name":"*values"}]}],"returns":[],"file":"/lib/core/facets/hash/delete_values.rb","line":null,"source":"def delete_values(*values)\n  deleted_keys = []\n  keys.each do |key|\n    if values.include?(fetch(key))\n      deleted_keys << key\n      delete(key)\n    end\n  end\n  deleted_keys\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#delete_values_at":{"!":"method","declarations":["instance","public"],"path":"Hash#delete_values_at","name":"delete_values_at","namespace":"Hash","comment":"Minor modification to Ruby's Hash#delete method\nallowing it to take multiple keys.\n\n   hsh = {:a=>1, :b=>2, :c=>3}\n\n   a, b, c = hsh.delete_values_at(:a, :b, :c)\n\n   [a, b, c]  #=> [1, 2, 3]\n   hsh        #=> {}\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_values_at(*keys, &yld)","arguments":[{"name":"*keys"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/hash/delete_values.rb","line":null,"source":"def delete_values_at(*keys, &yld)\n  keys.map{|key| delete(key, &yld) }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#object_send":{"!":"method","declarations":["instance","public"],"path":"Kernel#object_send","name":"object_send","namespace":"Kernel","comment":"Send only to public methods.\n\n  class SendExample\n    private\n    def foo; end\n  end\n\n  obj = SendExample.new\n\n  expect NoMethodError do\n    obj.object_send(:foo)\n  end\n\nTODO: object_send needs to change for 1.9. Is it #public_send ?\n\nCREDIT: Trans\n--\nWhich implementation is faster?\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_send(name, *args, &blk)","arguments":[{"name":"name"},{"name":"*args"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/kernel/object_send.rb","line":null,"source":"def object_send(name, *args, &blk)\n  #instance_eval \"self.#{name}(*args)\"\n  if respond_to?(name)\n    __send__(name, *args, &blk)\n  else\n    __send__(:method_missing, name, *args, &blk)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#attr_setter":{"!":"method","declarations":["instance","public"],"path":"Module#attr_setter","name":"attr_setter","namespace":"Module","comment":"Create an attribute method for both getting\nand setting an instance variable:\n\n  attr_setter :a\n\nis equivalent to:\n\n  def a(*args)\n    if args.size > 0\n      @a = args[0]\n      self\n    else\n      @a\n    end\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_setter(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/attr_setter.rb","line":null,"source":"def attr_setter(*args)\n  code, made = '', []\n  args.each do |a|\n    code << %{\n      def #{a}(*args)\n        args.size > 0 ? ( @#{a}=args[0] ; self ) : @#{a}\n      end\n    }\n    made << \"#{a}\".to_sym\n  end\n  module_eval code\n  made\nend","language":"ruby","dynamic":null,"tags":{}},"Module#alias_setter":{"!":"method","declarations":["instance","public"],"path":"Module#alias_setter","name":"alias_setter","namespace":"Module","comment":"Alias an accessor. This create an alias for\nboth a reader and a writer.\n\n  class AttrSetterExample\n    attr_setter :a\n    alias_setter :b, :a\n  end\n\n  x = AttrSetterExample.new\n  x.b(1)\n  x.a        #=> 1\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_setter","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/attr_setter.rb","line":null,"source":"alias_method :alias_setter, :alias_method","language":"ruby","dynamic":null,"tags":{}},"Hash#reverse_merge":{"!":"method","declarations":["instance","public"],"path":"Hash#reverse_merge","name":"reverse_merge","namespace":"Hash","comment":"Allows for reverse merging where its the keys in the\ncalling hash that wins over those in the <tt>other_hash</tt>.\nThis is particularly useful for initializing an incoming\noption hash with default values:\n\n  def setup(options = {})\n    options.reverse_merge! :size => 25, :velocity => 10\n  end\n\nThe default :size and :velocity is only set if the +options+\npassed in doesn't already have those keys set.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reverse_merge(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/reverse_merge.rb","line":null,"source":"def reverse_merge(other)\n  other.merge(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#reverse_merge!":{"!":"method","declarations":["instance","public"],"path":"Hash#reverse_merge!","name":"reverse_merge!","namespace":"Hash","comment":"Inplace form of #reverse_merge.","format":"rdoc","aliases":["Hash#reverse_update"],"singleton":null,"interfaces":[{"signature":"reverse_merge!(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/hash/reverse_merge.rb","line":null,"source":"def reverse_merge!(other)\n  replace(reverse_merge(other))\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#reverse_update":{"!":"method","declarations":["instance","public"],"path":"Hash#reverse_update","name":"reverse_update","namespace":"Hash","comment":"Inplace form of #reverse_merge.\nObvious alias for reverse_merge!","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reverse_merge!(other)","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/reverse_merge.rb","line":null,"source":"def reverse_merge!(other)\n  replace(reverse_merge(other))\nend","language":"ruby","dynamic":null,"tags":{}},"Module#wrap_method":{"!":"method","declarations":["instance","public"],"path":"Module#wrap_method","name":"wrap_method","namespace":"Module","comment":"Creates a new method wrapping the previous of the same name.\nReference to the old method is passed into the new definition\nblock as the first parameter.\n\n  class WrapExample\n    def foo\n      \"foo\"\n    end\n\n    wrap_method(:foo) do |old_meth, *args|\n      old_meth.call + '!'\n    end\n  end\n\n  example = WrapExample.new\n  example.foo #=> 'foo!'\n\nKeep in mind that this cannot be used to wrap methods\nthat take a block.\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#wrap"],"singleton":null,"interfaces":[{"signature":"wrap_method(sym, &blk)","arguments":[{"name":"sym"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/module/wrap_method.rb","line":null,"source":"def wrap_method( sym, &blk )\n  old = instance_method(sym)\n  define_method(sym) { |*args| blk.call(old.bind(self), *args) }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#wrap":{"!":"method","declarations":["instance","public"],"path":"Module#wrap","name":"wrap","namespace":"Module","comment":"Creates a new method wrapping the previous of the same name.\nReference to the old method is passed into the new definition\nblock as the first parameter.\n\n  class WrapExample\n    def foo\n      \"foo\"\n    end\n\n    wrap_method(:foo) do |old_meth, *args|\n      old_meth.call + '!'\n    end\n  end\n\n  example = WrapExample.new\n  example.foo #=> 'foo!'\n\nKeep in mind that this cannot be used to wrap methods\nthat take a block.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"wrap_method(sym, &blk)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/wrap_method.rb","line":null,"source":"def wrap_method( sym, &blk )\n  old = instance_method(sym)\n  define_method(sym) { |*args| blk.call(old.bind(self), *args) }\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#each_by":{"!":"method","declarations":["instance","public"],"path":"Enumerable#each_by","name":"each_by","namespace":"Enumerable","comment":"Iterate through slices. If slice +steps+ is not\ngiven, the arity of the block is used.\n\n  x = []\n  [1,2,3,4].each_by{ |a,b| x << [a,b] }\n  x  #=> [ [1,2], [3,4] ]\n\n  x = []\n  [1,2,3,4,5,6].each_by(3){ |a| x << a }\n  x  #=> [ [1,2,3], [4,5,6] ]\n\nThis is just like each_slice, except that it will check\nthe arity of the block. If each_slice ever suppots this\nthis method can be deprecated.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_by(steps=nil, &block)","arguments":[{"name":"steps","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/each_by.rb","line":null,"source":"def each_by(steps=nil, &block)\n  if steps\n    each_slice(steps, &block)\n  else\n    steps = block.arity.abs\n    each_slice(steps, &block)\n    #each_slice(steps) {|i| block.call(*i)}\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#delete_unless":{"!":"method","declarations":["instance","public"],"path":"Hash#delete_unless","name":"delete_unless","namespace":"Hash","comment":"Inverse of #delete_if.\n\n  h = { :a => 1, :b => 2, :c => 3 }\n  r = h.delete_unless{|k,v| v == 1}\n  r  #=> { :a => 1 }\n  h  #=> { :a => 1 }\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_unless()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/delete_unless.rb","line":null,"source":"def delete_unless #:yield:\n  delete_if{ |key, value| ! yield(key, value) }\nend","language":"ruby","dynamic":null,"tags":{}},"UnboundMethod":{"!":"class","superclass":"Object","path":"UnboundMethod","name":"UnboundMethod","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["UnboundMethod#name","UnboundMethod#arguments"],"accessors":[],"files":["/lib/core/facets/unboundmethod/name.rb","/lib/core/facets/unboundmethod/arguments.rb"],"tags":{}},"UnboundMethod#name":{"!":"method","declarations":["instance","public"],"path":"UnboundMethod#name","name":"name","namespace":"UnboundMethod","comment":"Return the name of the method.\n\nBe aware that in ruby 1.9 UnboundMethod#name is defined already,\nbut it returns a Symbol not a String.\n\n  class NameExample\n    def foo; end\n  end\n\n  meth = NameExample.instance_method(:foo)\n\n  meth.name.to_sym  #=> :foo\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"name()","arguments":[]}],"returns":[],"file":"/lib/core/facets/unboundmethod/name.rb","line":null,"source":"def name\n  i = to_s.rindex('#')\n  to_s.slice(i+1...-1).to_sym\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#update_values":{"!":"method","declarations":["instance","public"],"path":"Hash#update_values","name":"update_values","namespace":"Hash","comment":"Iterate over hash updating just the values.\n\n  h = {:a=>1, :b=>2}\n  h.update_values{ |v| v + 1 }\n  h  #=> { :a=>2, :b=>3 }\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"update_values()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/update_values.rb","line":null,"source":"def update_values #:yield:\n  if block_given?\n    each{ |k,v| store(k, yield(v)) }\n  else\n    to_enum(:update_values)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"MatchData#matchset":{"!":"method","declarations":["instance","public"],"path":"MatchData#matchset","name":"matchset","namespace":"MatchData","comment":"Returns [ pre_match, matchtree, post_match ]. (see matchtree)\n\n  md = /(bb)(cc(dd))(ee)/.match \"XXaabbccddeeffXX\"\n  md.to_a      #=> [\"bbccddee\", \"bb\", \"ccdd\", \"dd\", \"ee\"]\n  md.matchset  #=> [\"XXaa\", [[\"bb\"], [\"cc\", [\"dd\"]], [\"ee\"]], \"ffXX\"]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"matchset()","arguments":[]}],"returns":[],"file":"/lib/core/facets/matchdata/matchset.rb","line":null,"source":"def matchset\n   [pre_match, matchtree, post_match]\nend","language":"ruby","dynamic":null,"tags":{}},"MatchData#matchtree":{"!":"method","declarations":["instance","public"],"path":"MatchData#matchtree","name":"matchtree","namespace":"MatchData","comment":"An alternate to #to_a which returns the matches in\norder corresponding with the regular expression.\n\n  md = /(bb)(cc(dd))(ee)/.match \"XXaabbccddeeffXX\"\n  md.to_a       #=> [\"bbccddee\", \"bb\", \"ccdd\", \"dd\", \"ee\"]\n  md.matchtree  #=> [[\"bb\"], [\"cc\", [\"dd\"]], [\"ee\"]]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"matchtree(index=0)","arguments":[{"name":"index","default":"0"}]}],"returns":[],"file":"/lib/core/facets/matchdata/matchset.rb","line":null,"source":"def matchtree(index=0)\n  ret=[]\n  b, e=self.begin(index), self.end(index)\n  while (index+=1)<=length\n    if index==length || (bi=self.begin(index))>=e\n      # we are finished, if something is left, then add it\n      ret << string[b, e-b] if e>b\n      break\n    else\n      if bi>=b\n        ret << string[b, bi-b] if bi>b\n        ret << matchtree(index)\n        b=self.end(index)\n      end\n    end\n  end\n  return ret\nend","language":"ruby","dynamic":null,"tags":{}},"String#capitalized?":{"!":"method","declarations":["instance","public"],"path":"String#capitalized?","name":"capitalized?","namespace":"String","comment":"Return true if the string is capitalized, otherwise false.\n\n  \"This\".capitalized?  #=> true\n  \"THIS\".capitalized?  #=> false\n  \"this\".capitalized?  #=> false\n\nNote Ruby's strange concept of capitalized. See capitalcase\nfor the more command conception.\n\nCREDIT: Phil Tomson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"capitalized?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/string/capitalized.rb","line":null,"source":"def capitalized?\n  capitalize == self\nend","language":"ruby","dynamic":null,"tags":{}},"String#downcase?":{"!":"method","declarations":["instance","public"],"path":"String#downcase?","name":"downcase?","namespace":"String","comment":"Return true if the string is lowercase (downcase), otherwise false.\n\n  \"THIS\".downcase?  #=> false\n  \"This\".downcase?  #=> false\n  \"this\".downcase?  #=> true\n\nCREDIT: Phil Tomson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"downcase?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/string/capitalized.rb","line":null,"source":"def downcase?\n  downcase == self\nend","language":"ruby","dynamic":null,"tags":{}},"String#upcase?":{"!":"method","declarations":["instance","public"],"path":"String#upcase?","name":"upcase?","namespace":"String","comment":"Is the string upcase/uppercase?\n\n  \"THIS\".upcase?  #=> true\n  \"This\".upcase?  #=> false\n  \"this\".upcase?  #=> false\n\nCREDIT: Phil Tomson","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"upcase?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/string/capitalized.rb","line":null,"source":"def upcase?\n  upcase == self\nend","language":"ruby","dynamic":null,"tags":{}},"Exception.suppress":{"!":"method","declarations":["class","public"],"path":"Exception.suppress","name":"suppress","namespace":"Exception","comment":"Supress errors while executing a block, with execptions.\n\nCREDIT: David Heinemeier Hansson, Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"suppress(.)","arguments":[{"name":"*exception_classes"}]}],"returns":[],"file":"/lib/core/facets/exception/suppress.rb","line":null,"source":"def self.suppress(*exception_classes)\n  exception_classes.each do |e|\n    unless e < self\n      raise ArgumentError, \"exception #{e} not a subclass of #{self}\"\n    end\n  end\n  exception_classes = [self] | exception_classes\n  begin\n    yield\n  rescue Exception => e\n    raise unless exception_classes.any? { |cls| e.kind_of?(cls) }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#uniq_by":{"!":"method","declarations":["instance","public"],"path":"Enumerable#uniq_by","name":"uniq_by","namespace":"Enumerable","comment":"Like #uniq, but determines uniqueness based on a given block.\n\n  (-5..5).to_a.uniq_by {|i| i*i }\n  #=> [-5, -4, -3, -2, -1, 0]","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"uniq_by()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/uniq_by.rb","line":null,"source":"def uniq_by #:yield:\n  h = {}; inject([]) {|a,x| h[yield(x)] ||= a << x}\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#exclude?":{"!":"method","declarations":["instance","public"],"path":"Enumerable#exclude?","name":"exclude?","namespace":"Enumerable","comment":"The inverse of #include?.\n\n [:a, :b].exclude?(:c)  #=> true\n [:a, :b].exclude?(:a)  #=> false","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"exclude?(object)","arguments":[{"name":"object"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/enumerable/exclude.rb","line":null,"source":"def exclude?(object)\n  !include?(object)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#hashify":{"!":"method","declarations":["instance","public"],"path":"Enumerable#hashify","name":"hashify","namespace":"Enumerable","comment":"Create a hash whose keys are the enumerable's elements, with specified\nvalues.\n\nIf no block is given, the given parameter (default true) is used for\nall values, e.g.:\n\n    [1,2,3,4].hashify               #=> {1=>true, 2=>true, 3=>true, 4=>true}\n    [1,2,3,4].hashify(\"a\")          #=> {1=>\"a\", 2=>\"a\", 3=>\"a\", 4=>\"a\"}\n\nIf a block is given, each key's value is the result of running the\nblock for that key, e.g.:\n\n    [1,2,3,4].hashify{|n| \"a\" * n}  #=> {1=>\"a\", 2=>\"aa\", 3=>\"aaa\", 4=>\"aaaa\"}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hashify(val=true)","arguments":[{"name":"val","default":"true"}]}],"returns":[],"file":"/lib/core/facets/enumerable/hashify.rb","line":null,"source":"def hashify(val=true)\n  h = {}\n  if block_given?\n    each { |item| h[item] = yield(item) }\n  else\n    each { |item| h[item] = val }\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{"author":"Ronen Barzel","uncommon":"require 'facets/enumerable/hashify'"}},"Module#method_clash":{"!":"method","declarations":["instance","public"],"path":"Module#method_clash","name":"method_clash","namespace":"Module","comment":"Detect method name clash between modules and/or classes, regardless of\nmethod visibility:\n\n  module MethodClashExample\n\n    module A\n      def c; end\n    end\n\n    module B\n      private\n      def c; end\n    end\n\n    A.method_clash(B)  #=> [:c]\n\n  end\n\nCREDIT: Thomas Sawyer, Robert Dober","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_clash(other)","arguments":[{"name":"other"}]}],"returns":[],"file":"/lib/core/facets/module/method_clash.rb","line":null,"source":"def method_clash(other)\n  common_ancestor = (ancestors & other.ancestors).first\n\n  s = []\n  s += public_instance_methods(true)\n  s += private_instance_methods(true)\n  s += protected_instance_methods(true)\n\n  o = []\n  o += other.public_instance_methods(true)\n  o += other.private_instance_methods(true)\n  o += other.protected_instance_methods(true)\n\n  c = s & o\n\n  if common_ancestor\n    c -= common_ancestor.public_instance_methods(true)\n    c -= common_ancestor.private_instance_methods(true)\n    c -= common_ancestor.protected_instance_methods(true)\n  end\n\n  return c\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/method_clash'"}},"Module#method_clash?":{"!":"method","declarations":["instance","public"],"path":"Module#method_clash?","name":"method_clash?","namespace":"Module","comment":"Uses #method_clash to return +true+ or +false+ if there\nare method name clashes.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_clash?(other)","arguments":[{"name":"other"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/module/method_clash.rb","line":null,"source":"def method_clash?(other) \n  c = method_clash(other) \n  !c.empty?\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/method_clash'"}},"Object#object_state":{"!":"method","declarations":["instance","public"],"path":"Object#object_state","name":"object_state","namespace":"Object","comment":"Get or set state of object. You can think of #object_state as an in-code\nform of marshalling.\n\n  class StateExample\n    attr_reader :a, :b\n    def initialize(a,b)\n      @a, @b = a, b\n    end\n  end\n\n  obj = StateExample.new(1,2)\n  obj.a  #=> 1\n  obj.b  #=> 2\n\n  obj.object_state  #=> {:a=>1, :b=>2}\n\n  obj.object_state(:a=>3, :b=>4)\n  obj.a  #=> 3\n  obj.b  #=> 4\n\nFor most object's this is essentially the same as <code>instance.to_h</code>.\nBut for data structures like Array and Hash it returns a snapshot of their\ncontents, not the state of their instance variables.\n--\nTODO: Should this be in module Kernel ?\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_state(data=nil)","arguments":[{"name":"data","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/object/object_state.rb","line":null,"source":"def object_state(data=nil)\n  if data\n    instance_variables.each do |iv|\n      name = iv.to_s.sub(/^[@]/, '').to_sym\n      instance_variable_set(iv, data[name])\n    end\n  else\n    data = {}\n    instance_variables.each do |iv|\n      name = iv.to_s.sub(/^[@]/, '').to_sym\n      data[name] = instance_variable_get(iv)\n    end\n    data\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Array#object_state":{"!":"method","declarations":["instance","public"],"path":"Array#object_state","name":"object_state","namespace":"Array","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_state(data=nil)","arguments":[{"name":"data","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/object/object_state.rb","line":null,"source":"def object_state(data=nil)\n  data ? replace(data) : dup\nend","language":"ruby","dynamic":null,"tags":{}},"String#object_state":{"!":"method","declarations":["instance","public"],"path":"String#object_state","name":"object_state","namespace":"String","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_state(data=nil)","arguments":[{"name":"data","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/object/object_state.rb","line":null,"source":"def object_state(data=nil)\n  data ? replace(data) : dup\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#object_state":{"!":"method","declarations":["instance","public"],"path":"Hash#object_state","name":"object_state","namespace":"Hash","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_state(data=nil)","arguments":[{"name":"data","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/object/object_state.rb","line":null,"source":"def object_state(data=nil)\n  data ? replace(data) : dup\nend","language":"ruby","dynamic":null,"tags":{}},"Struct#object_state":{"!":"method","declarations":["instance","public"],"path":"Struct#object_state","name":"object_state","namespace":"Struct","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_state(data=nil)","arguments":[{"name":"data","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/object/object_state.rb","line":null,"source":"def object_state(data=nil)\n  if data\n    data.each_pair {|k,v| send(k.to_s + \"=\", v)}\n  else\n    data = {}\n    each_pair{|k,v| data[k] = v}\n    data\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"ObjectSpace":{"!":"module","path":"ObjectSpace","name":"ObjectSpace","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":["ObjectSpace::Reflector"],"methods":["ObjectSpace.reflect","ObjectSpace.classes","ObjectSpace.[]"],"accessors":[],"files":["/lib/core/facets/objectspace/reflect.rb","/lib/core/facets/objectspace/classes.rb"],"tags":{}},"ObjectSpace.reflect":{"!":"method","declarations":["class","public"],"path":"ObjectSpace.reflect","name":"reflect","namespace":"ObjectSpace","comment":"Reflection ensures that information about an object\nis actual according to Ruby's Kernel definitions, just\nin case such methods have been overridden.\n\n ObjectSpace.reflect(\"object\").object_id\n\nThere is also a global short-cut for this method to ease\nmeta-programming with it.\n\n  $ref[\"object\"].class\n\nTypically theis method will be used to gather the object's\nid, as in the example given, or it's class, but any Kernel\nmethod can be used.\n\nCare should be taken in utilizing this technique. In most\ncases it is not needed, but in certain cases is useful\nfor improving the robustness of meta-programming solutions.\n\nNote that this is also equivalent to using +as(Kernel)+ ...\n\n  \"object\".as(Kernel).object_id\n\nBut obviously, in this case there is the risk that #as has\nbe overridden too.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"reflect(.)","arguments":[{"name":"obj"}]}],"returns":[],"file":"/lib/core/facets/objectspace/reflect.rb","line":null,"source":"def self.reflect(obj)\n  ## TODO: use this after 1.8.6 support discontinued\n  ## Functor.new do |op, *a, &b|\n  ##   Kernel.instance_method(op).bind(obj).call(*a, &b)\n  ## end\n  Reflector.new(obj)\nend","language":"ruby","dynamic":null,"tags":{}},"ObjectSpace::Reflector":{"!":"class","superclass":"Object","path":"ObjectSpace::Reflector","name":"Reflector","namespace":"ObjectSpace","comment":":nodoc:","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["ObjectSpace::Reflector#initialize","ObjectSpace::Reflector#method_missing"],"accessors":[],"files":["/lib/core/facets/objectspace/reflect.rb"],"tags":{}},"ObjectSpace::Reflector#initialize":{"!":"method","declarations":["instance","public"],"path":"ObjectSpace::Reflector#initialize","name":"initialize","namespace":"ObjectSpace::Reflector","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(obj)","arguments":[{"name":"obj"}]}],"returns":[{"type":"Reflector","comment":"a new instance of Reflector"}],"file":"/lib/core/facets/objectspace/reflect.rb","line":null,"source":"def initialize(obj)\n  @obj = obj\nend","language":"ruby","dynamic":null,"tags":{}},"ObjectSpace::Reflector#method_missing":{"!":"method","declarations":["instance","public"],"path":"ObjectSpace::Reflector#method_missing","name":"method_missing","namespace":"ObjectSpace::Reflector","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(op, *args, &yld)","arguments":[{"name":"op"},{"name":"*args"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/objectspace/reflect.rb","line":null,"source":"def method_missing(op, *args, &yld)\n  Kernel.instance_method(op).bind(@obj).call(*args, &yld)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#group_by":{"!":"method","declarations":["instance","public"],"path":"Enumerable#group_by","name":"group_by","namespace":"Enumerable","comment":"Enumerable#group_by is used to group items in a collection by something\nthey have in common.  The common factor is the key in the resulting hash,\nthe array of like elements is the value.\n\n  (1..5).group_by { |n| n % 3 }\n  #=> { 0 => [3], 1 => [1, 4], 2 => [2,5] }\n\nApplied to an array.\n\n  [\"I had\", 1, \"dollar and\", 50, \"cents\"].group_by { |e| e.class }\n  #=> { String => [\"I had\",\"dollar and\",\"cents\"], Fixnum => [1,50] }\n\nApplied to a hash:\n\n  {:a=>1, :b=>2, :c=>1}.group_by{ |k,v| v }\n  #=> { 1=>[[:c,1], [:a,1]], 2=>[[:b,2]] }\n\nCREDIT: Erik Veenstra","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"group_by()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/group_by.rb","line":null,"source":"def group_by #:yield:\n  r = Hash.new\n  each{ |e| (r[yield(e)] ||= []) << e }\n  r\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#dearray_values":{"!":"method","declarations":["instance","public"],"path":"Hash#dearray_values","name":"dearray_values","namespace":"Hash","comment":"Any array values with be replaced with the first element of the array.\nArrays with no elements will be set to nil.\n\n  h = { :a=>[1], :b=>[1,2], :c=>3, :d=>[] }\n  h.dearray_values  #=> { :a=>1, :b=>1, :c=>3, :d=>nil }\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dearray_values(index=0)","arguments":[{"name":"index","default":"0"}]}],"returns":[],"file":"/lib/core/facets/hash/dearray_values.rb","line":null,"source":"def dearray_values(index=0)\n  h = {}\n  each do |k,v|\n    case v\n    when Array\n      h[k] = v[index] || v[-1]\n    else\n      h[k] = v\n    end\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#dearray_singular_values":{"!":"method","declarations":["instance","public"],"path":"Hash#dearray_singular_values","name":"dearray_singular_values","namespace":"Hash","comment":"Any array values with one or no elements will be set to the element\nor nil.\n\n  h = { :a=>[1], :b=>[1,2], :c=>3, :d=>[] }\n  h.dearray_singular_values  #=> { :a=>1, :b=>[1,2], :c=>3, :d=>nil }\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dearray_singular_values()","arguments":[]}],"returns":[],"file":"/lib/core/facets/hash/dearray_values.rb","line":null,"source":"def dearray_singular_values\n  h = {}\n  each do |k,v|\n    case v\n    when Array\n      h[k] = (v.size < 2) ? v[0] : v\n    else\n      h[k] = v\n    end\n  end\n  h\nend","language":"ruby","dynamic":null,"tags":{}},"ObjectSpace.classes":{"!":"method","declarations":["class","public"],"path":"ObjectSpace.classes","name":"classes","namespace":"ObjectSpace","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"classes(.)","arguments":[]}],"returns":[{"type":"Array[Class]","comment":"All the classes in the object space."}],"file":"/lib/core/facets/objectspace/classes.rb","line":null,"source":"def self.classes\n  klasses = []\n  each_object(Class){|o| klasses << o}\n  klasses\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#super_method":{"!":"method","declarations":["instance","public"],"path":"Kernel#super_method","name":"super_method","namespace":"Kernel","comment":"Returns method of a parent class bound to self.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"super_method(klass, meth)","arguments":[{"name":"klass"},{"name":"meth"}]}],"returns":[],"file":"/lib/core/facets/kernel/super_method.rb","line":null,"source":"def super_method(klass, meth)\n  unless self.class.ancestors.include?(klass)\n    raise ArgumentError, \"Not an ancestor for super_method-- #{klass}\"\n  end\n  klass.instance_method(meth).bind(self)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#delete_values":{"!":"method","declarations":["instance","public"],"path":"Array#delete_values","name":"delete_values","namespace":"Array","comment":"Delete multiple values from array.\n\n  a = [1,2,3,4]\n  a.delete_values(1,2)   #=> [1,2]\n  a                      #=> [3,4]\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_values(*values)","arguments":[{"name":"*values"}]}],"returns":[],"file":"/lib/core/facets/array/delete_values.rb","line":null,"source":"def delete_values(*values)\n  d = []\n  values.each{ |v| d << delete(v) }\n  d\nend","language":"ruby","dynamic":null,"tags":{}},"Array#delete_values_at":{"!":"method","declarations":["instance","public"],"path":"Array#delete_values_at","name":"delete_values_at","namespace":"Array","comment":"Delete multiple values from array given\nindexes or index range.\n\n  a = [1,2,3,4]\n  a.delete_values_at(1,2)   #=> [2,3]\n  a                         #=> [1,4]\n  a = [1,2,3,4]\n  a.delete_values_at(0..2)  #=> [1,2,3]\n  a                         #=> [4]\n\nNOTE: It would be nice to see #delete_at incorporate this\nfuncitonaility.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_values_at(*selectors)","arguments":[{"name":"*selectors"}]}],"returns":[],"file":"/lib/core/facets/array/delete_values.rb","line":null,"source":"def delete_values_at(*selectors)\n  idx = []\n  selectors.each{ |i|\n    case i\n    when Range\n      idx.concat( i.to_a )\n    else\n      idx << i.to_i\n    end\n  }\n  idx.uniq!\n  dvals = values_at(*idx)\n  idx = (0...size).to_a - idx\n  self.replace( values_at(*idx) )\n  return dvals\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#map_send":{"!":"method","declarations":["instance","public"],"path":"Enumerable#map_send","name":"map_send","namespace":"Enumerable","comment":"Send a message to each element and collect the result.\n\n  [1,2,3].map_send(:+, 3)  #=> [4,5,6]\n\nCREDIT: Sean O'Halpin","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"map_send(meth, *args, &block)","arguments":[{"name":"meth"},{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/map_send.rb","line":null,"source":"def map_send(meth, *args, &block)\n  map{|e| e.send(meth, *args, &block)}\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#symbolize_keys":{"!":"method","declarations":["instance","public"],"path":"Hash#symbolize_keys","name":"symbolize_keys","namespace":"Hash","comment":"Return a new hash with all keys converted to symbols. With a +select+ block,\nlimits conversion to only a certain selection of keys.\n\n  foo = { :name=>'Gavin', 'wife'=>:Lisa }\n  foo.symbolize_keys    #=>  { :name=>\"Gavin\", :wife=>:Lisa }\n  foo                   #=>  { :name =>\"Gavin\", \"wife\"=>:Lisa }\n\nIf the key does not respond to #to_sym, then #to_s will be used first.\n\nFor a more versatile method, see #rekey instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"symbolize_keys(&select)","arguments":[],"block":{"name":"&select"}}],"returns":[],"file":"/lib/core/facets/hash/symbolize_keys.rb","line":null,"source":"def symbolize_keys(&select)\n  dup.symbolize_keys!(&select)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#symbolize_keys!":{"!":"method","declarations":["instance","public"],"path":"Hash#symbolize_keys!","name":"symbolize_keys!","namespace":"Hash","comment":"Destructively convert all keys to symbols. This is the same as\nHash#symbolize_keys, but modifies the receiver in place and returns it.\nWith a +select+ block, limits conversion to only selected keys.\n\n  foo = { 'name'=>'Gavin', 'wife'=>:Lisa }\n  foo.symbolize_keys!    #=>  { :name=>\"Gavin\", :wife=>:Lisa }\n  foo                    #=>  { :name=>\"Gavin\", :wife=>:Lisa }\n\nIf the key does not respond to #to_sym, then #to_s will be used first.\n\nFor a more versatile method, see #rekey instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"symbolize_keys!(&select)","arguments":[],"block":{"name":"&select"}}],"returns":[],"file":"/lib/core/facets/hash/symbolize_keys.rb","line":null,"source":"def symbolize_keys!(&select)\n  if select\n    keys.each do |key|\n      if select[key]\n        new_key = (key.to_sym rescue key.to_s.to_sym)\n        self[new_key] = delete(key)\n      end\n    end       \n  else\n    keys.each do |key|\n      new_key = (key.to_sym rescue key.to_s.to_sym)\n      self[new_key] = delete(key)\n    end\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#stringify_keys":{"!":"method","declarations":["instance","public"],"path":"Hash#stringify_keys","name":"stringify_keys","namespace":"Hash","comment":"Return a new hash with all keys converted to strings. Converts all keys\nin the Hash to Strings, returning a new Hash. With a +select+ block,\nlimits conversion to only a certain selection of keys.\n\n  foo = { :name=>'Gavin', :wife=>:Lisa }\n  foo.stringify_keys    #=>  { \"name\"=>\"Gavin\", \"wife\"=>:Lisa }\n  foo                   #=>  { :name =>\"Gavin\", :wife=>:Lisa }\n\nThis method is considered archaic. Use #rekey instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stringify_keys(&select)","arguments":[],"block":{"name":"&select"}}],"returns":[],"file":"/lib/core/facets/hash/symbolize_keys.rb","line":null,"source":"def stringify_keys(&select)\n  dup.stringify_keys!(&select)\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#stringify_keys!":{"!":"method","declarations":["instance","public"],"path":"Hash#stringify_keys!","name":"stringify_keys!","namespace":"Hash","comment":"Destructively convert all keys to strings. This is the same as\nHash#stringify_keys, but modifies the receiver in place and\nreturns it. With a +select+ block, limits conversion to only\ncertain keys.\n\n  foo = { :name=>'Gavin', :wife=>:Lisa }\n  foo.stringify_keys!    #=>  { \"name\"=>\"Gavin\", \"wife\"=>:Lisa }\n  foo                    #=>  { \"name\"=>\"Gavin\", \"wife\"=>:Lisa }\n\nThis method is considered archaic. Use #rekey instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"stringify_keys!(&select)","arguments":[],"block":{"name":"&select"}}],"returns":[],"file":"/lib/core/facets/hash/symbolize_keys.rb","line":null,"source":"def stringify_keys!(&select)\n  if select\n    keys.each do |key|\n      if select[key]\n        self[key.to_s] = delete(key)\n      end\n    end\n  else\n    keys.each do |key|\n      self[key.to_s] = delete(key)\n    end\n  end\n  self\nend","language":"ruby","dynamic":null,"tags":{}},"Module#class_extend":{"!":"method","declarations":["instance","public"],"path":"Module#class_extend","name":"class_extend","namespace":"Module","comment":"Normally when including modules, class/module methods are not\nextended. To achieve this behavior requires some clever\nRuby Karate. Instead #class_extend provides an easy to use\nand clean solution. Simply place the extending class methods\nin a block of the special module method #class_extend.\n\n  module Mix\n    def inst_meth\n      puts 'inst_meth'\n    end\n\n    class_extend do\n      def class_meth\n        \"Class Method!\"\n      end\n    end\n  end\n\n  class X\n    include Mix\n  end\n\n  X.class_meth  #=> \"Class Method!\"\n\nNOTE: This old #class_extension version of this method\ndid not extend the containing class automatically --it had\nto be done by hand. With #class_extend, that is no longer\nthe case.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Daniel Schierbeck, Thomas Sawyer\n\nTHANKS: Nobu Nakada, Ulysses","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_extend(*mods, &block)","arguments":[{"name":"*mods"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/module/class_extend.rb","line":null,"source":"def class_extend(*mods, &block)\n  class_extension = Module.new\n\n  class_extension.__send__(:include, *mods)\n  class_extension.module_eval(&block) if block_given?\n\n  extend(class_extension)  # extend this module too\n\n  append_method = method(:append_features)\n\n  (class << self; self; end).class_eval do\n    define_method(:append_features) do |mod|\n      append_method.call(mod)\n      mod.extend(class_extension)\n      if mod.instance_of?(Module)\n        mod.__send__(:class_extend, class_extension)\n      end\n    end\n  end\n\n  class_extensions << class_extension\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/class_extend'"}},"Module#class_extensions":{"!":"method","declarations":["instance","public"],"path":"Module#class_extensions","name":"class_extensions","namespace":"Module","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_extensions()","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/class_extend.rb","line":null,"source":"def class_extensions\n  @class_extensions ||= []\nend","language":"ruby","dynamic":null,"tags":{}},"Class#class_extend":{"!":"method","declarations":["instance","public"],"path":"Class#class_extend","name":"class_extend","namespace":"Class","comment":"For Class, Module#class_extend is similar to class_eval.\n\nThe alternative is to \"undef_method :class_extend\",\nbut this seems uneccessarily limited.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_extend(*mods, &block)","arguments":[{"name":"*mods"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/module/class_extend.rb","line":null,"source":"def class_extend(*mods, &block)\n  class_extension = Module.new\n  class_extension.__send__(:include, *mods)\n  class_extension.module_eval(&block) if block\n  extend(class_extension)\n  class_extensions << class_extension\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/class_extend'"}},"Module#method_space":{"!":"method","declarations":["instance","public"],"path":"Module#method_space","name":"method_space","namespace":"Module","comment":"Create method namespaces, allowing for method\nchains but still accessing the object's instance.\n\n  class A\n    attr_writer :x\n    method_space :inside do\n      def x; @x; end\n    end\n  end\n\n  a = A.new\n  a.x = 10\n  a.inside.x  #=> 10\n\n  expect NoMethodError do\n    a.x\n  end\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Pit Captain","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_space(name, mod=nil, &blk)","arguments":[{"name":"name"},{"name":"mod","default":"nil"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/module/method_space.rb","line":null,"source":"def method_space(name, mod=nil, &blk)\n\n  ## If block is given then create a module, otherwise\n  ## get the name of the module.\n  if block_given?\n    name = name.to_s\n    raise ArgumentError if mod\n    mod  = Module.new(&blk)\n  else\n    if Module === name\n      mod = name\n      name = mod.basename.downcase\n    end\n    mod  = mod.dup\n  end\n\n  ## Include the module. This is neccessary, otherwise\n  ## Ruby won't let us bind the instance methods.\n  include mod\n\n  ## Save the instance methods of the module and\n  ## replace them with a \"transparent\" version.\n  methods = {}\n  mod.instance_methods(false).each do |m|\n    methods[m.to_sym] = mod.instance_method(m)\n    mod.module_eval %{\n      def #{m}(*a,&b)\n        super(*a,&b)\n      end\n    }\n    ##mod.instance_eval do\n    ##  define_method(m)\n    ##    super\n    ##  end\n    ##end\n  end\n\n  ## Add a method for the namespace that delegates\n  ## via the Functor to the saved instance methods.\n  define_method(name) do\n    mtab = methods\n    Functor.new do |op, *args|\n      if meth = mtab[op.to_sym]\n        meth.bind(self).call(*args)\n      else\n        #self.__send__(op, *args)\n        raise NoMethodError, \"undefined method `#{m}'\"\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/method_space'"}},"Module#include_as":{"!":"method","declarations":["instance","public"],"path":"Module#include_as","name":"include_as","namespace":"Module","comment":"Include a module via a specified space.\n\n  module T\n    def t ; \"HERE\" ; end\n  end\n\n  class X\n    include_as :test => T\n    def t ; test.t ; end\n  end\n\n  X.new.t  #=> \"HERE\"\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"include_as(h)","arguments":[{"name":"h"}]}],"returns":[],"file":"/lib/core/facets/module/method_space.rb","line":null,"source":"def include_as(h)\n  h.each{ |name, mod| method_space(name, mod) }\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/method_space'"}},"Kernel#object_class":{"!":"method","declarations":["instance","public"],"path":"Kernel#object_class","name":"object_class","namespace":"Kernel","comment":"Defines object_classas an alias of class.\nThis is an alternative to __class__, akin to\n#object_id.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_class","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/object_class.rb","line":null,"source":"alias_method :object_class, :class","language":"ruby","dynamic":null,"tags":{}},"Enumerable#modulate":{"!":"method","declarations":["instance","public"],"path":"Enumerable#modulate","name":"modulate","namespace":"Enumerable","comment":"Divide an array into groups by modulo of the index.\n\n  [2,4,6,8].modulate(2)  #=> [[2,6],[4,8]]\n\nCREDIT: Trans\n\nNOTE: Would the better name for this be 'collate'?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"modulate(modulo)","arguments":[{"name":"modulo"}]}],"returns":[],"file":"/lib/core/facets/enumerable/modulate.rb","line":null,"source":"def modulate(modulo)\n  return to_a if modulo == 1\n  raise ArgumentError, 'bad modulo' if size % modulo != 0\n  r = Array.new(modulo, [])\n  (0...size).each do |i|\n    r[i % modulo] += [self[i]]\n  end\n  r\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Array#delete_unless":{"!":"method","declarations":["instance","public"],"path":"Array#delete_unless","name":"delete_unless","namespace":"Array","comment":"Inverse of #delete_if.\n\n  [1,2,3].delete_unless{ |x| x < 2 }\n  #=> [1]\n\nCREDIT: Daniel Schierbeck","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"delete_unless(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/array/delete_unless.rb","line":null,"source":"def delete_unless(&block)\n  delete_if { |element| not block.call(element) }\nend","language":"ruby","dynamic":null,"tags":{}},"Time#dst_adjustment":{"!":"method","declarations":["instance","public"],"path":"Time#dst_adjustment","name":"dst_adjustment","namespace":"Time","comment":"Adjust DST\n\nTODO: Can't seem to get this to pass ActiveSupport tests,\neven though it is essentially identical to the ActiveSupport\ncode (see Time#since in time/calculations.rb). It handles\nall but 4 tests.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"dst_adjustment(time)","arguments":[{"name":"time"}]}],"returns":[],"file":"/lib/core/facets/time/dst_adjustment.rb","line":null,"source":"def dst_adjustment(time)\n  self_dst = self.dst? ? 1 : 0\n  time_dst = time.dst? ? 1 : 0\n  seconds  = (self - time).abs\n  if (seconds >= 86400 && self_dst != time_dst)\n    time + ((self_dst - time_dst) * 60 * 60)\n  else\n    time\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#object_hexid":{"!":"method","declarations":["instance","public"],"path":"Kernel#object_hexid","name":"object_hexid","namespace":"Kernel","comment":"Returns the object id as a string in hexideciaml,\nwhich is how Ruby reports them with inspect...\n\n  \"ABC\".object_hexid  #=> \"0x402d359c\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"object_hexid()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/object_hexid.rb","line":null,"source":"def object_hexid\n  HEXID_TEMPLATE % (__id__ << 1)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#map_with":{"!":"method","declarations":["instance","public"],"path":"Enumerable#map_with","name":"map_with","namespace":"Enumerable","comment":"Combines #zip and #map in a single efficient operation.\n\n  h = {}\n  [1,2,3].map_with [:x,:y,:z] do |n,k|\n    h[k] = n\n  end\n  h  #=> {:x=>1, :y=>2, :z=>3}","format":"rdoc","aliases":["Enumerable#zip_map"],"singleton":null,"interfaces":[{"signature":"map_with(*arrays, &block)","arguments":[{"name":"*arrays"}],"block":{"name":"&block"}}],"returns":[{"type":"Hash","comment":""}],"file":"/lib/core/facets/enumerable/map_with.rb","line":null,"source":"def map_with(*arrays, &block)\n  enum_for(:zip, *arrays).map(&block)\nend","language":"ruby","dynamic":null,"tags":{"author":"Michael Kohl"}},"Enumerable#zip_map":{"!":"method","declarations":["instance","public"],"path":"Enumerable#zip_map","name":"zip_map","namespace":"Enumerable","comment":"Combines #zip and #map in a single efficient operation.\n\n  h = {}\n  [1,2,3].map_with [:x,:y,:z] do |n,k|\n    h[k] = n\n  end\n  h  #=> {:x=>1, :y=>2, :z=>3}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"map_with(*arrays, &block)","arguments":[]}],"returns":[{"type":"Hash","comment":""}],"file":"/lib/core/facets/enumerable/map_with.rb","line":null,"source":"def map_with(*arrays, &block)\n  enum_for(:zip, *arrays).map(&block)\nend","language":"ruby","dynamic":null,"tags":{"author":"Michael Kohl"}},"Enumerable#frequency":{"!":"method","declarations":["instance","public"],"path":"Enumerable#frequency","name":"frequency","namespace":"Enumerable","comment":"Generates a hash mapping each unique symbol in the array\nto the absolute frequency it appears.\n\n  [:a,:a,:b,:c,:c,:c].frequency  #=> {:a=>2,:b=>1,:c=>3}\n\nCREDIT: Brian Schrder\n\n--\nNOTE: So why not use #inject here? e.g. ...\n\n  inject(Hash.new(0)){|p,v| p[v]+=1; p}\n\nBecause it is a fair bit slower than the traditional definition.\n++","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"frequency()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/frequency.rb","line":null,"source":"def frequency\n  p = Hash.new(0); each{ |v| p[v] += 1 }; p\n\nend","language":"ruby","dynamic":null,"tags":{}},"ObjectSpace.[]":{"!":"method","declarations":["class","public"],"path":"ObjectSpace.[]","name":"[]","namespace":"ObjectSpace","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"[]","arguments":[]}],"returns":[],"file":"/lib/core/facets/objectspace/op_fetch.rb","line":null,"source":"alias_method :[], :_id2ref","language":"ruby","dynamic":null,"tags":{}},"String#edit_distance":{"!":"method","declarations":["instance","public"],"path":"String#edit_distance","name":"edit_distance","namespace":"String","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"edit_distance(str2)","arguments":[{"name":"str2"}]}],"returns":[],"file":"/lib/core/facets/string/edit_distance.rb","line":null,"source":"def edit_distance(str2)\n  str1 = self\n\n  if str2.encoding != str1.encoding\n    str2 = str2.encode(str1.encoding.name)\n  end\n\n  s = str1.codepoints.to_a\n  t = str2.codepoints.to_a\n\n  n = s.length\n  m = t.length\n\n  return m if (0 == n)\n  return n if (0 == m)\n\n  d = (0..m).to_a\n  x = nil\n\n  (0...n).each do |i|\n    e = i+1\n    (0...m).each do |j|\n      cost = (s[i] == t[j]) ? 0 : 1\n      x = [\n        d[j+1] + 1, # insertion\n        e + 1,      # deletion\n        d[j] + cost # substitution\n      ].min\n      d[j] = e\n      e = x\n    end\n    d[m] = x\n  end\n\n  return x\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#instance_send":{"!":"method","declarations":["instance","public"],"path":"Kernel#instance_send","name":"instance_send","namespace":"Kernel","comment":"Private send.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_send","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/instance_send.rb","line":null,"source":"alias_method :instance_send, :__send__","language":"ruby","dynamic":null,"tags":{}},"String.random_binary":{"!":"method","declarations":["class","public"],"path":"String.random_binary","name":"random_binary","namespace":"String","comment":"Generate a random binary string of +n_bytes+ size.\n\nCREDIT: Guido De Rosa","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"random_binary(.)","arguments":[{"name":"n_bytes"}]}],"returns":[],"file":"/lib/core/facets/string/random_binary.rb","line":null,"source":"def self.random_binary(n_bytes)\n  ( Array.new(n_bytes){ rand(0x100) } ).pack('c*') \nend","language":"ruby","dynamic":null,"tags":{}},"Module#rename_method":{"!":"method","declarations":["instance","private"],"path":"Module#rename_method","name":"rename_method","namespace":"Module","comment":"Aliases a method and undefines the original.\n\n  class RenameExample\n    def foo; \"foo\"; end\n    rename_method(:bar, :foo)\n  end\n\n  example = RenameExample.new\n  example.bar  #=> 'foo'\n\n  expect NoMethodError do\n    example.foo\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#rename"],"singleton":null,"interfaces":[{"signature":"rename_method(to_sym, from_sym)","arguments":[{"name":"to_sym"},{"name":"from_sym"}]}],"returns":[],"file":"/lib/core/facets/module/rename_method.rb","line":null,"source":"def rename_method( to_sym, from_sym )\n  raise ArgumentError, \"method #{from_sym} does not exist\" unless method_defined?( from_sym )\n  alias_method( to_sym, from_sym )\n  undef_method( from_sym )\nend","language":"ruby","dynamic":null,"tags":{"raise":""}},"Module#rename":{"!":"method","declarations":["instance","private"],"path":"Module#rename","name":"rename","namespace":"Module","comment":"Aliases a method and undefines the original.\n\n  class RenameExample\n    def foo; \"foo\"; end\n    rename_method(:bar, :foo)\n  end\n\n  example = RenameExample.new\n  example.bar  #=> 'foo'\n\n  expect NoMethodError do\n    example.foo\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"rename_method(to_sym, from_sym)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/rename_method.rb","line":null,"source":"def rename_method( to_sym, from_sym )\n  raise ArgumentError, \"method #{from_sym} does not exist\" unless method_defined?( from_sym )\n  alias_method( to_sym, from_sym )\n  undef_method( from_sym )\nend","language":"ruby","dynamic":null,"tags":{}},"Object::InstanceExecMethods":{"!":"module","path":"Object::InstanceExecMethods","name":"InstanceExecMethods","namespace":"Object","comment":":nodoc:","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/core/facets/kernel/instance_exec.rb"],"tags":{}},"Object#instance_exec":{"!":"method","declarations":["instance","public"],"path":"Object#instance_exec","name":"instance_exec","namespace":"Object","comment":"Evaluate the block with the given arguments within the context of\nthis object, so self is set to the method receiver.\n\nFrom Mauricio's http://eigenclass.org/hiki/bounded+space+instance_exec\n\nThis version has been borrowed from Rails for compatibility sake.\n\nNOTE: This is not a common core extension (due to the use of thread.rb)\nand is not loaded automatically when using <code>require 'facets'</code>.\nHowever it is a core method in Ruby 1.9, so this only matters for users\nof Ruby 1.8.x or below.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_exec(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/instance_exec.rb","line":null,"source":"def instance_exec(*args, &block)\n  begin\n    old_critical, Thread.critical = Thread.critical, true\n    n = 0\n    n += 1 while respond_to?(method_name = \"__instance_exec#{n}\")\n    InstanceExecMethods.module_eval { define_method(method_name, &block) }\n  ensure\n    Thread.critical = old_critical\n  end\n\n  begin\n    __send__(method_name, *args)\n  ensure\n    InstanceExecMethods.module_eval { remove_method(method_name) } rescue nil\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/kernel/instance_exec'"}},"Kernel#hierarchically":{"!":"method","declarations":["instance","public"],"path":"Kernel#hierarchically","name":"hierarchically","namespace":"Kernel","comment":"Hierarchically apply a block, passing each ancestor to the block\nstarting at the root ancestor and working toward the current object.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hierarchically(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/class/hierarchically.rb","line":null,"source":"def hierarchically(&block)\n  ancestors.reverse_each do |m|\n    block.call(m)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"String#compress_lines":{"!":"method","declarations":["instance","public"],"path":"String#compress_lines","name":"compress_lines","namespace":"String","comment":"Matches any whitespace (including newline) and replaces with a single space\n\n  string = <<-QUERY.compress_lines\n    SELECT name\n    FROM users\n  QUERY\n\n  string  #=> \"SELECT name FROM users\"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"compress_lines(spaced = true)","arguments":[{"name":"spaced","default":"true"}]}],"returns":[],"file":"/lib/core/facets/string/compress_lines.rb","line":null,"source":"def compress_lines(spaced = true)\n  split($/).map{ |line| line.strip }.join(spaced ? ' ' : '')\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#find_yield":{"!":"method","declarations":["instance","public"],"path":"Enumerable#find_yield","name":"find_yield","namespace":"Enumerable","comment":"Yield each element to the block and return the result\nof the block when that result evaluates as true,\nterminating early like #detect and #find.\n\n  obj1 = Object.new\n  obj2 = Object.new\n\n  def obj1.foo?; false; end\n  def obj2.foo?; true ; end\n\n  def obj1.foo ; \"foo1\"; end\n  def obj2.foo ; \"foo2\"; end\n\n  [obj1, obj2].find_yield{ |obj| obj.foo if obj.foo? }  #=> \"foo2\"\n\nAnother example.\n\n  [1,2,3,4,5].find_yield{ |i| j = i+1; j if j % 4 == 0 }  #=> 4\n\nIf the block is never true, return the object given in the first parameter,\nor nil if none specified.\n\n  [1,2,3].find_yield{ |_| false }    #=> nil\n  [false].find_yield(1){ |_| false } #=> 1","format":"rdoc","aliases":["Enumerable#map_detect"],"singleton":null,"interfaces":[{"signature":"find_yield(fallback=nil)","arguments":[{"name":"fallback","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/enumerable/find_yield.rb","line":null,"source":"def find_yield(fallback=nil) #:yield:\n  each do |member|\n    result = yield(member)\n    return result if result \n  end\n  fallback\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#map_detect":{"!":"method","declarations":["instance","public"],"path":"Enumerable#map_detect","name":"map_detect","namespace":"Enumerable","comment":"Yield each element to the block and return the result\nof the block when that result evaluates as true,\nterminating early like #detect and #find.\n\n  obj1 = Object.new\n  obj2 = Object.new\n\n  def obj1.foo?; false; end\n  def obj2.foo?; true ; end\n\n  def obj1.foo ; \"foo1\"; end\n  def obj2.foo ; \"foo2\"; end\n\n  [obj1, obj2].find_yield{ |obj| obj.foo if obj.foo? }  #=> \"foo2\"\n\nAnother example.\n\n  [1,2,3,4,5].find_yield{ |i| j = i+1; j if j % 4 == 0 }  #=> 4\n\nIf the block is never true, return the object given in the first parameter,\nor nil if none specified.\n\n  [1,2,3].find_yield{ |_| false }    #=> nil\n  [false].find_yield(1){ |_| false } #=> 1\n\nAlias for #find_yield.\n\nDEPRECATE: This has been renamed to #find_yield.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"find_yield(fallback=nil)","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/find_yield.rb","line":null,"source":"def find_yield(fallback=nil) #:yield:\n  each do |member|\n    result = yield(member)\n    return result if result \n  end\n  fallback\nend","language":"ruby","dynamic":null,"tags":{}},"#temporary_directory":{"!":"method","declarations":["instance","public"],"path":"#temporary_directory","name":"temporary_directory","namespace":"","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"temporary_directory()","arguments":[]}],"returns":[],"file":"/lib/core/facets/applique/file_helpers.rb","line":null,"source":"def temporary_directory\n  @temporary_directory ||= 'tmp'\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#cluster_by":{"!":"method","declarations":["instance","public"],"path":"Enumerable#cluster_by","name":"cluster_by","namespace":"Enumerable","comment":"Similar to #group_by but returns an array of the groups.\nReturned elements are sorted by block.\n\n   %w{this is a test}.cluster_by {|x| x[0]}\n   #=> [ ['a'], ['is'], ['this', 'test'] ]\n\nCREDIT: Erik Veenstra","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"cluster_by(&b)","arguments":[],"block":{"name":"&b"}}],"returns":[],"file":"/lib/core/facets/enumerable/cluster_by.rb","line":null,"source":"def cluster_by(&b)\n  group_by(&b).sort.transpose.pop || []   # group_by(&b).values ?\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#instance_class":{"!":"method","declarations":["instance","public"],"path":"Kernel#instance_class","name":"instance_class","namespace":"Kernel","comment":"Easy access to an object qua class, otherwise known\nas the object's metaclass or singleton class. This\nimplemnetation alwasy returns the class, even if a\nblock is provided to eval against it...\n\n    It is what it is.\n    But I think I like this one best.\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_class(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/instance_class.rb","line":null,"source":"def instance_class(&block)\n  (class << self; self; end).module_eval(&block) if block\n  (class << self; self; end)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#copy_inheritor":{"!":"method","declarations":["instance","public"],"path":"Module#copy_inheritor","name":"copy_inheritor","namespace":"Module","comment":"Like #class_inheritor but non-dynamic. The value of the inheritor\nis copied from the ancestor on first read.\n\n  c = Class.new do\n    def self.x; ['x']; end\n  end\n\n  d = Class.new(c) do\n    copy_inheritor :x\n  end\n\n  d.x  #=> ['x']\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"copy_inheritor(name, default={})","arguments":[{"name":"name"},{"name":"default","default":"{}"}]}],"returns":[],"file":"/lib/core/facets/module/copy_inheritor.rb","line":null,"source":"def copy_inheritor(name, default={})\n  class_extend do\n    define_method(name) do\n      if instance_variable_defined?(\"@#{name}\")\n        instance_variable_get(\"@#{name}\")\n      else\n        if anc = ancestors[1..-1].find{ |a| a.respond_to?(name) }\n          value = anc.__send__(name)\n          value = value.dup rescue value\n          instance_variable_set(\"@#{name}\", value)\n        else\n          instance_variable_set(\"@#{name}\", default)\n        end\n      end\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/copy_inheritor'"}},"Exception.error_print":{"!":"method","declarations":["class","public"],"path":"Exception.error_print","name":"error_print","namespace":"Exception","comment":"Formats the Exception so that it looks *familiar*,\ni.e. exactly like your interpreter does it.\n\nPort of MRI native `error_print` function.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"error_print(.)","arguments":[{"name":"e"}]}],"returns":[],"file":"/lib/core/facets/exception/error_print.rb","line":null,"source":"def self.error_print(e)\n  warn_print = \"\"\n  backtrace = e.backtrace\n  backtrace = [ backtrace ] if backtrace.is_a?(String) # 1.9 returns single String for SystemStackError\n\n  warn_print << backtrace[0]\n  if e.is_a?(RuntimeError) && e.message.empty?\n    warn_print << \": unhandled exception\\n\"\n  else\n    if e.message.empty?\n      warn_print << \": #{ e.class.name }\\n\"\n    else\n      split_message = e.message.split(\"\\n\")\n      warn_print << \": \"\n      if split_message.size == 1\n        warn_print << \"#{ e.message } (#{ e.class.name })\\n\"\n      else\n        warn_print << split_message[0]\n        warn_print << \" (#{ e.class.name })\\n\"\n        warn_print << split_message[1..-1].join(\"\\n\").chomp << \"\\n\"\n      end\n    end\n  end\n\n  len = backtrace.size\n\n  ## int skip = eclass == rb_eSysStackError;\n  skip = e.is_a?(SystemStackError)\n\n  ## #define TRACE_MAX (TRACE_HEAD+TRACE_TAIL+5)\n  ## #define TRACE_HEAD 8\n  ## #define TRACE_TAIL 5\n  trace_head = 8\n  trace_tail = 5\n  trace_max = (trace_head + trace_tail + 5)\n  ##\n  ##\tfor (i = 1; i < len; i++) {\n  i = 1\n  while i < len\n    ##\t    if (TYPE(ptr[i]) == T_STRING) {\n    ##\t\twarn_printf(\"\\tfrom %s\\n\", RSTRING_PTR(ptr[i]));\n    ##\t    }\n    warn_print << \"\\tfrom %s\\n\" % e.backtrace[i]\n\n    ##\t    if (skip && i == TRACE_HEAD && len > TRACE_MAX) {\n    if skip && i == trace_head && len > trace_max\n    ##\t\twarn_printf(\"\\t ... %ld levels...\\n\",\n    ##\t\t\t    len - TRACE_HEAD - TRACE_TAIL);\n      warn_print << \"\\t ... %d levels...\\n\" % (len - trace_head - trace_tail)\n    ##\t\ti = len - TRACE_TAIL;\n      i = len - trace_tail\n    ##\t    }\n    end\n    ##\t}\n    i += 1\n  end\n  warn_print\nend","language":"ruby","dynamic":null,"tags":{"author":"Evgeniy Dolzhenko"}},"Exception#error_print":{"!":"method","declarations":["instance","public"],"path":"Exception#error_print","name":"error_print","namespace":"Exception","comment":"Formats the Exception so that it looks *familiar*,\ni.e. exactly like your interpreter does it.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"error_print()","arguments":[]}],"returns":[],"file":"/lib/core/facets/exception/error_print.rb","line":null,"source":"def error_print\n  Exception.error_print(self)\nend","language":"ruby","dynamic":null,"tags":{"author":"Evgeniy Dolzhenko","todo":"Anyone have a better name for this method?"}},"Module#class_accessor":{"!":"method","declarations":["instance","public"],"path":"Module#class_accessor","name":"class_accessor","namespace":"Module","comment":"NOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_accessor(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/module/class_accessor.rb","line":null,"source":"def class_accessor(name)\n  class_reader(name)\n  class_writer(name)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/class_accessor'"}},"Module#class_reader":{"!":"method","declarations":["instance","public"],"path":"Module#class_reader","name":"class_reader","namespace":"Module","comment":"NOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_reader(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/module/class_accessor.rb","line":null,"source":"def class_reader(name)\n  module_eval(<<-EOS, __FILE__, __LINE__)\n    def self.#{name}\n      @#{name}\n    end\n  EOS\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/class_reader'"}},"Module#class_writer":{"!":"method","declarations":["instance","public"],"path":"Module#class_writer","name":"class_writer","namespace":"Module","comment":"NOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_writer(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/module/class_accessor.rb","line":null,"source":"def class_writer(name)\n  module_eval(<<-EOS, __FILE__, __LINE__)\n    def self.#{name}=(x)\n      @#{name} = x\n    end\n  EOS\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/class_writer'"}},"Module#alias_accessor":{"!":"method","declarations":["instance","private"],"path":"Module#alias_accessor","name":"alias_accessor","namespace":"Module","comment":"As with alias_method, but alias both reader and writer.\n\n  attr_accessor :x\n  self.x = 1\n  alias_accessor :y, :x\n  y #=> 1\n  self.y = 2\n  x #=> 2","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_accessor(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/alias_accessor.rb","line":null,"source":"def alias_accessor(*args)\n  orig = args.last\n  args = args - [orig]\n  args.each do |name|\n    alias_method(name, orig)\n    alias_method(\"#{name}=\", \"#{orig}=\")\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#alias_reader":{"!":"method","declarations":["instance","private"],"path":"Module#alias_reader","name":"alias_reader","namespace":"Module","comment":"As with alias_accessor, but just for the reader.\nThis is basically the same as alias_method.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_reader(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/alias_accessor.rb","line":null,"source":"def alias_reader(*args)\n  orig = args.last\n  args = args - [orig]\n  args.each do |name|\n    alias_method(name, orig)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#alias_writer":{"!":"method","declarations":["instance","private"],"path":"Module#alias_writer","name":"alias_writer","namespace":"Module","comment":"As with alias_method but does the writer instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_writer(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/alias_accessor.rb","line":null,"source":"def alias_writer(*args)\n  orig = args.last\n  args = args - [orig]\n  args.each do |name|\n    alias_method(\"#{name}=\", \"#{orig}=\")\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Hash#extractable_options?":{"!":"method","declarations":["instance","public"],"path":"Hash#extractable_options?","name":"extractable_options?","namespace":"Hash","comment":"By default, only instances of Hash itself are extractable.\nSubclasses of Hash may implement this method and return\ntrue to declare themselves as extractable. If a Hash\nis extractable, Array#extract_options! pops it from\nthe Array when it is the last element of the Array.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"extractable_options?()","arguments":[]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/array/extract_options.rb","line":null,"source":"def extractable_options?\n  instance_of?(Hash)\nend","language":"ruby","dynamic":null,"tags":{}},"Array#extract_options!":{"!":"method","declarations":["instance","public"],"path":"Array#extract_options!","name":"extract_options!","namespace":"Array","comment":"Extracts options from a set of arguments. Removes and returns the last\nelement in the array if it's a hash, otherwise returns a blank hash.\n\n  def options(*args)\n    args.extract_options!\n  end\n\n  options(1, 2)           # => {}\n  options(1, 2, :a => :b) # => {:a=>:b}","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"extract_options!()","arguments":[]}],"returns":[],"file":"/lib/core/facets/array/extract_options.rb","line":null,"source":"def extract_options!\n  if Hash === last && last.extractable_options?\n    pop\n  else\n    {}\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#attr_validator":{"!":"method","declarations":["instance","public"],"path":"Module#attr_validator","name":"attr_validator","namespace":"Module","comment":"Like attr_writer, but the writer method validates the\nsetting against the given block.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: ?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_validator(*symbols, &validator)","arguments":[{"name":"*symbols"}],"block":{"name":"&validator"}}],"returns":[],"file":"/lib/core/facets/module/attr_validator.rb","line":null,"source":"def attr_validator(*symbols, &validator)\n  made = []\n  symbols.each do |symbol|\n    define_method \"#{symbol}=\" do |val|\n      unless validator.call(val)\n        raise ArgumentError, \"Invalid value provided for #{symbol}\"\n      end\n      instance_variable_set(\"@#{symbol}\", val)\n    end\n    made << \"#{symbol}=\".to_sym\n  end\n  made\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/attr_validator'"}},"Module#alias_validator":{"!":"method","declarations":["instance","public"],"path":"Module#alias_validator","name":"alias_validator","namespace":"Module","comment":"Create aliases for validator attribute methods.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_validator(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/module/attr_validator.rb","line":null,"source":"def alias_validator(*args)\n  orig = args.last\n  args = args - [orig]\n  args.each do |name|\n    #alias_method(name, orig)\n    alias_method(\"#{name}=\", \"#{orig}=\")\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/attr_validator'"}},"Enumerable#accumulate":{"!":"method","declarations":["instance","public"],"path":"Enumerable#accumulate","name":"accumulate","namespace":"Enumerable","comment":"Accumulate a set of a set. For example, in an ORM design\nwhere `Group has_many User` we might have something\nequivalent to the following.\n\n  Group = Struct.new(:users)\n  User  = Struct.new(:name, :friends)\n\n  user1 = User.new('John', [])\n  user2 = User.new('Jane', ['Jill'])\n  user3 = User.new('Joe' , ['Jack', 'Jim'])\n\n  group1 = Group.new([user1, user2])\n  group2 = Group.new([user2, user3])\n\n  groups = [group1, group2]\n\nNow we can *accumulate* the users of all groups.\n\n  groups.accumulate.users  #=> [user1, user2, user3]\n\nYou may pass an argument to perform chains, e.g. the following\nreturns the names of users from all groups.\n\n  groups.accumulate(2).users.name  #=> ['John','Jane','Joe']\n\nOr we can gather all the friends of all users in groups.\n\n  groups.accumulate(2).users.friends  #=> ['Jill','Jack','Jim']\n\nThis is more convenient then the equivalent.\n\n  groups.accumulate.users.accumulate.friends  #=> ['Jill','Jack','Jim']\n\nCREDIT: George Moshchovitis, Daniel Emirikol","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"accumulate(iterations=1)","arguments":[{"name":"iterations","default":"1"}]}],"returns":[],"file":"/lib/core/facets/enumerable/accumulate.rb","line":null,"source":"def accumulate(iterations=1)\n  return self if iterations == 0\n  Functor.new do |op, *args|\n    #result = inject([]) { |a, x| a << x.send(op, *args) }.flatten.uniq\n    result = []\n    each { |x| result << x.send(op, *args) }\n    result.flatten.uniq.accumulate(iterations - 1)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#accumulate_all":{"!":"method","declarations":["instance","public"],"path":"Enumerable#accumulate_all","name":"accumulate_all","namespace":"Enumerable","comment":"Same as #accumulate, but does not apply #uniq to final result.\n\n  groups.accumulate_all(2).users.friends  #=> ['Jill', 'Jill','Jack','Jim']","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"accumulate_all(iterations=1)","arguments":[{"name":"iterations","default":"1"}]}],"returns":[],"file":"/lib/core/facets/enumerable/accumulate.rb","line":null,"source":"def accumulate_all(iterations=1)\n  return self if iterations == 0\n  Functor.new do |op, *args|\n    #result = inject([]) { |a, x| a << x.send(op, *args) }.flatten\n    result = []\n    each { |x| result << x.send(op, *args) }\n    result.flatten.accumulate_all(iterations - 1)\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#attr_singleton_reader":{"!":"method","declarations":["instance","public"],"path":"Kernel#attr_singleton_reader","name":"attr_singleton_reader","namespace":"Kernel","comment":"Creates singleton attr_readers.\n\n  obj = Object.new\n\n  obj.attr_singleton_reader :x, :y\n\n  attr_singleton_reader :x, :y\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_singleton_reader(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/kernel/attr_singleton.rb","line":null,"source":"def attr_singleton_reader(*args)\n  #h, a = *args.partition{|a| Hash===a}\n  (class << self ; self ; end).send( :attr_reader, *args )\n  #(class << self ; self ; end).send( :attr_reader, *h.keys )\n  #h.each { |k,v| instance_variable_set(\"@#{k}\", v) }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#attr_singleton_writer":{"!":"method","declarations":["instance","public"],"path":"Kernel#attr_singleton_writer","name":"attr_singleton_writer","namespace":"Kernel","comment":"Create singleton attr_writers.\n\n  obj = Object.new\n\n  obj.attr_singleton_writer :x, :y\n\n  obj.x = 3\n  obj.y = 4\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_singleton_writer(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/kernel/attr_singleton.rb","line":null,"source":"def attr_singleton_writer(*args)\n  #h, a = *args.partition{|a| Hash===a}\n  (class << self ; self ; end).send( :attr_writer, *args )\n  #(class << self ; self ; end).send( :attr_writer, *h.keys )\n  #h.each { |k,v| instance_variable_set(\"@#{k}\", v) }\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#attr_singleton_accessor":{"!":"method","declarations":["instance","public"],"path":"Kernel#attr_singleton_accessor","name":"attr_singleton_accessor","namespace":"Kernel","comment":"Create singleton attr_accessors.\n\n  obj = Object.new\n\n  obj.attr_singleton_accessor :x, :y\n\n  obj.x = 3\n  obj.y = 4\n  obj.x      #=> 3\n  obj.y      #=> 4\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_singleton_accessor(*args)","arguments":[{"name":"*args"}]}],"returns":[],"file":"/lib/core/facets/kernel/attr_singleton.rb","line":null,"source":"def attr_singleton_accessor(*args)\n  #h, a = *args.partition{|a| Hash===a}\n  (class << self ; self ; end).send( :attr_accessor, *args )\n  #(class << self ; self ; end).send( :attr_accessor, *h.keys )\n  #h.each { |k,v| instance_variable_set(\"@#{k}\", v) }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#redefine_method":{"!":"method","declarations":["instance","private"],"path":"Module#redefine_method","name":"redefine_method","namespace":"Module","comment":"Creates a new method for a pre-existing method.\n\nIf _aka_ is given, then the method being redefined will\nfirst be aliased to this name.\n\n  class Greeter\n    def hello ; \"Hello\" ; end\n  end\n\n  Greeter.new.hello   #=> \"Hello\"\n\n  class Greeter\n    redefine_method( :hello, :hi ) do\n      hi + \", friend!\"\n    end\n  end\n\n  Greeter.new.hello   #=> \"Hello, friend!\"\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#redef"],"singleton":null,"interfaces":[{"signature":"redefine_method(sym, aka=nil, &blk)","arguments":[{"name":"sym"},{"name":"aka","default":"nil"}],"block":{"name":"&blk"}}],"returns":[],"file":"/lib/core/facets/module/redefine_method.rb","line":null,"source":"def redefine_method(sym, aka=nil, &blk)\n  alias_method(aka, sym) if aka\n  ## prevent warning about method overwrite\n  begin remove_method(sym) rescue NameError end\n  ## define replacelemt method\n  define_method(sym, &blk)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#redef":{"!":"method","declarations":["instance","private"],"path":"Module#redef","name":"redef","namespace":"Module","comment":"Creates a new method for a pre-existing method.\n\nIf _aka_ is given, then the method being redefined will\nfirst be aliased to this name.\n\n  class Greeter\n    def hello ; \"Hello\" ; end\n  end\n\n  Greeter.new.hello   #=> \"Hello\"\n\n  class Greeter\n    redefine_method( :hello, :hi ) do\n      hi + \", friend!\"\n    end\n  end\n\n  Greeter.new.hello   #=> \"Hello, friend!\"\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"redefine_method(sym, aka=nil, &blk)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/redefine_method.rb","line":null,"source":"def redefine_method(sym, aka=nil, &blk)\n  alias_method(aka, sym) if aka\n  ## prevent warning about method overwrite\n  begin remove_method(sym) rescue NameError end\n  ## define replacelemt method\n  define_method(sym, &blk)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#class_inheritor":{"!":"method","declarations":["instance","public"],"path":"Module#class_inheritor","name":"class_inheritor","namespace":"Module","comment":"= Class Inheritor\n\nCreate an dynamic class inheritable attribute.\n\nInheritor providse a means to store and inherit data via the class\nheirarchy. An inheritor creates two methods one named after the key\nthat provides a reader. And one named after key! which provides the\nwriter. (Because of the unique nature of inheritor the reader and\nwriter can't be the same method.)\n\nThe first argument is the inheritor's name. The second argument\nis the archtype object. This object must be duplicable (via #dup).\nThe last argument is either the symbolic operator/method or a block\nthat specifies how one hierarchical level \"integrates\" with the next.\n\n  class X\n    class_inheritor :x, [], :+\n  end\n\n  class Y < X\n  end\n\n  X.x! << :a\n  X.x  #=> [:a]\n  Y.x  #=> [:a]\n\n  Y.x! << :b\n  X.x  #=> [:a]\n  Y.x  #=> [:a, :b]\n\nNOTE: Adding an inheritor directly to Module or Class will probably\nnot do what is expected. Thankfully that usecase is likely a YAGNI,\nbut in anycase it is even more likely that it is not possible with\nthis code.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.\n\nCREDIT: Thomas Sawyer","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"class_inheritor(key, obj, op=nil, &fop)","arguments":[{"name":"key"},{"name":"obj"},{"name":"op","default":"nil"}],"block":{"name":"&fop"}}],"returns":[],"file":"/lib/core/facets/module/class_inheritor.rb","line":null,"source":"def class_inheritor(key, obj, op=nil, &fop)\n  raise ArgumentError if op && fop\n\n  if !fop\n    op  = op ? op.to_sym : :+\n    fop = lambda{ |o, x| o.__send__(op, x) }\n  end\n\n  #(class << self; self; end).module_eval do\n  class_extend do\n\n    define_method(key) do\n      ancestors.reverse.inject(obj.dup) do |o, a|\n        if a.respond_to?(\"#{key}!\")\n          fop.call(o, a.__send__(\"#{key}!\"))\n        else\n          o\n        end\n      end\n    end\n\n    define_method(\"#{key}!\") do\n      if instance_variable_defined?(\"@#{key}\")\n        instance_variable_get(\"@#{key}\")\n      else\n        instance_variable_set(\"@#{key}\", obj.dup)\n      end\n    end\n\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/class_inheritor'","raise":""}},"Module#redirect_method":{"!":"method","declarations":["instance","private"],"path":"Module#redirect_method","name":"redirect_method","namespace":"Module","comment":"Redirect methods to other methods. This simply\ndefines methods by the name of a hash key which\ncalls the method with the name of the hash's value.\n\n  class RedirectExample\n    redirect_method :hi => :hello, :hey => :hello\n    def hello(name)\n      \"Hello, #{name}.\"\n    end\n  end\n\n  e = RedirectExample.new\n  e.hello(\"Bob\")    #=> \"Hello, Bob.\"\n  e.hi(\"Bob\")       #=> \"Hello, Bob.\"\n  e.hey(\"Bob\")      #=> \"Hello, Bob.\"\n\nThe above class definition is equivalent to ...\n\n  class RedirectExample\n    def hi(*args)\n      hello(*args)\n    end\n    def hey(*args)\n      hello(*args)\n    end\n    def hello\n      puts \"Hello\"\n    end\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":["Module#redirect"],"singleton":null,"interfaces":[{"signature":"redirect_method(method_hash)","arguments":[{"name":"method_hash"}]}],"returns":[],"file":"/lib/core/facets/module/redirect_method.rb","line":null,"source":"def redirect_method( method_hash )\n  method_hash.each do |targ,adv|\n    define_method(targ) { |*args| send(adv,*args) }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Module#redirect":{"!":"method","declarations":["instance","private"],"path":"Module#redirect","name":"redirect","namespace":"Module","comment":"Redirect methods to other methods. This simply\ndefines methods by the name of a hash key which\ncalls the method with the name of the hash's value.\n\n  class RedirectExample\n    redirect_method :hi => :hello, :hey => :hello\n    def hello(name)\n      \"Hello, #{name}.\"\n    end\n  end\n\n  e = RedirectExample.new\n  e.hello(\"Bob\")    #=> \"Hello, Bob.\"\n  e.hi(\"Bob\")       #=> \"Hello, Bob.\"\n  e.hey(\"Bob\")      #=> \"Hello, Bob.\"\n\nThe above class definition is equivalent to ...\n\n  class RedirectExample\n    def hi(*args)\n      hello(*args)\n    end\n    def hey(*args)\n      hello(*args)\n    end\n    def hello\n      puts \"Hello\"\n    end\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"redirect_method(method_hash)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/redirect_method.rb","line":null,"source":"def redirect_method( method_hash )\n  method_hash.each do |targ,adv|\n    define_method(targ) { |*args| send(adv,*args) }\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#compact_map":{"!":"method","declarations":["instance","public"],"path":"Enumerable#compact_map","name":"compact_map","namespace":"Enumerable","comment":"A more versitle #compact method. It can be used to\ncollect and filter items out in one single step.\n\n  c = [1,2,3].compact_map do |n|\n    n < 2 ? nil : n\n  end\n\n  c  #=> [2,3]\n\nCREDIT: Trans\n\nDEPRECATE: This method should probably be removed b/c #purge\ndoes almost the same thing and enum.map{}.compact works too.","format":"rdoc","aliases":["Enumerable#compact_collect"],"singleton":null,"interfaces":[{"signature":"compact_map(&block)","arguments":[],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/compact_map.rb","line":null,"source":"def compact_map(&block)\n  y = []\n  if block_given?\n    each do |*a|\n      r = yield(*a)\n      y << r unless r.nil?\n    end\n  else\n    each do |r|\n      y << r unless r.nil?\n    end\n  end\n  y\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#compact_collect":{"!":"method","declarations":["instance","public"],"path":"Enumerable#compact_collect","name":"compact_collect","namespace":"Enumerable","comment":"A more versitle #compact method. It can be used to\ncollect and filter items out in one single step.\n\n  c = [1,2,3].compact_map do |n|\n    n < 2 ? nil : n\n  end\n\n  c  #=> [2,3]\n\nCREDIT: Trans\n\nDEPRECATE: This method should probably be removed b/c #purge\ndoes almost the same thing and enum.map{}.compact works too.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"compact_map(&block)","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/compact_map.rb","line":null,"source":"def compact_map(&block)\n  y = []\n  if block_given?\n    each do |*a|\n      r = yield(*a)\n      y << r unless r.nil?\n    end\n  else\n    each do |r|\n      y << r unless r.nil?\n    end\n  end\n  y\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#instance_assign":{"!":"method","declarations":["instance","public"],"path":"Kernel#instance_assign","name":"instance_assign","namespace":"Kernel","comment":"Set instance variables using a hash.\n\n  instance_assign('@a'=>1, '@b'=>2)\n  @a   #=> 1\n  @b   #=> 2\n\nDEPRECATE: Use instance.update instead of #instance_assign.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_assign(hash)","arguments":[{"name":"hash"}]}],"returns":[],"file":"/lib/core/facets/kernel/instance_assign.rb","line":null,"source":"def instance_assign(hash)\n  hash.each do |k,v|\n    k = \"@#{k}\" if k !~ /^@/\n    instance_variable_set(k, v)\n  end\n  return self\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#singleton_class":{"!":"method","declarations":["instance","public"],"path":"Kernel#singleton_class","name":"singleton_class","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"singleton_class()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/singleton_class.rb","line":null,"source":"def singleton_class\n  (class << self; self; end)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#recursively":{"!":"method","declarations":["instance","public"],"path":"Enumerable#recursively","name":"recursively","namespace":"Enumerable","comment":"Returns a recursive functor, that allows enumerable methods to iterate\nthrough enumerable sub-elements. By default it only recurses over\nelements of the same type.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"recursively(*types, &block)","arguments":[{"name":"*types"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/enumerable/recursively.rb","line":null,"source":"def recursively(*types, &block)\n  Recursor.new(self, *types, &block)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Recursor":{"!":"class","superclass":"Object","path":"Enumerable::Recursor","name":"Recursor","namespace":"Enumerable","comment":"Recursor is a specialized Functor for recurively iterating over Enumerables.\n--\nTODO: Return Enumerator if no +yld+ block is given.\n\nTODO: Add limiting +depth+ option to Enumerable#recursively ?\n++","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Enumerable::Recursor#initialize","Enumerable::Recursor#method_missing"],"accessors":[],"files":["/lib/core/facets/enumerable/recursively.rb"],"tags":{}},"Enumerable::Recursor#initialize":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Recursor#initialize","name":"initialize","namespace":"Enumerable::Recursor","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(enum, *types, &block)","arguments":[{"name":"enum"},{"name":"*types"}],"block":{"name":"&block"}}],"returns":[{"type":"Recursor","comment":"a new instance of Recursor"}],"file":"/lib/core/facets/enumerable/recursively.rb","line":null,"source":"def initialize(enum, *types, &block)\n  @enum   = enum\n  @types  = types.empty? ? [@enum.class] : types\n  @block  = block\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable::Recursor#method_missing":{"!":"method","declarations":["instance","public"],"path":"Enumerable::Recursor#method_missing","name":"method_missing","namespace":"Enumerable::Recursor","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(op, &yld)","arguments":[{"name":"op"}],"block":{"name":"&yld"}}],"returns":[],"file":"/lib/core/facets/enumerable/recursively.rb","line":null,"source":"def method_missing(op, &yld)\n  rec = @block || lambda{ |v| v }\n  yld = yld    || lambda{ |v| v }  # ? to_enum\n  @enum.__send__(op) do |v|\n    case v\n    when String # b/c of 1.8\n      yld.call(v)\n    when *@types\n      res = v.recursively(*@types, &@block).__send__(op,&yld)\n      rec.call(res)\n    else\n      yld.call(v)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#source_location":{"!":"method","declarations":["instance","public"],"path":"Kernel#source_location","name":"source_location","namespace":"Kernel","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"source_location()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/source_location.rb","line":null,"source":"def source_location\n  file, line, meth = *caller(1).first.split(':')\n  return file, line\nend","language":"ruby","dynamic":null,"tags":{}},"Module#instance_method!":{"!":"method","declarations":["instance","public"],"path":"Module#instance_method!","name":"instance_method!","namespace":"Module","comment":"Access method as a singleton object and retain state.\n\n  module ::K\n    def hello\n      puts \"Hello World!\"\n    end\n  end\n\n  K.instance_method!(:hello).inspect   #=> \"#<UnboundMethod: K#hello>\"\n\nNOTE: This is limited to the scope of the current module/class.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_method!(s)","arguments":[{"name":"s"}]}],"returns":[],"file":"/lib/core/facets/module/instance_method.rb","line":null,"source":"def instance_method!(s)\n  #( @@__instance_methods__ ||= {} )[s] ||= instance_method(s)  # TODO: use class vars for 1.9+ ?\n  #( @__instance_methods__ ||= {} )[s.to_sym] ||= instance_method(s.to_sym)\n  $FIRST_CLASS_INSTANCE_METHODS[self][s.to_sym] ||= instance_method(s.to_sym)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#require_relative":{"!":"method","declarations":["instance","public"],"path":"Kernel#require_relative","name":"require_relative","namespace":"Kernel","comment":"Require file from same dir as calling script...\n\n  require_local 'myscript'\n\nCREDIT: Paul Brannan, Pragmatic Programmers","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"require_relative(relative_feature)","arguments":[{"name":"relative_feature"}]}],"returns":[],"file":"/lib/core/facets/kernel/require_relative.rb","line":null,"source":"def require_relative(relative_feature)\n  c = caller.first\n  fail \"Can't parse #{c}\" unless c.rindex(/:\\d+(:in `.*')?$/)\n  file = $` # File.dirname(c)\n  if /\\A\\((.*)\\)/ =~ file # eval, etc.\n    raise LoadError, \"require_relative is called in #{$1}\"\n  end\n  absolute = File.expand_path(relative_feature, File.dirname(file))\n  require absolute\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#load_relative":{"!":"method","declarations":["instance","public"],"path":"Kernel#load_relative","name":"load_relative","namespace":"Kernel","comment":"Load file from same dir as calling script...\n\n  load_local 'myscript'\n\nCREDIT: Paul Brannan, Pragmatic Programmers","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"load_relative(relative_feature, safe=nil)","arguments":[{"name":"relative_feature"},{"name":"safe","default":"nil"}]}],"returns":[],"file":"/lib/core/facets/kernel/require_relative.rb","line":null,"source":"def load_relative(relative_feature, safe=nil)\n  c = caller.first\n  fail \"Can't parse #{c}\" unless c.rindex(/:\\d+(:in `.*')?$/)\n  file = $` # File.dirname(c)\n  if /\\A\\((.*)\\)/ =~ file # eval, etc.\n    raise LoadError, \"require_relative is called in #{$1}\"\n  end\n  absolute = File.expand_path(relative_feature, File.dirname(file))\n  load absolute, safe\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#disable_warnings":{"!":"method","declarations":["instance","public"],"path":"Kernel#disable_warnings","name":"disable_warnings","namespace":"Kernel","comment":"CREDIT: Trans","format":"rdoc","aliases":["Kernel#silence_warnings"],"singleton":null,"interfaces":[{"signature":"disable_warnings()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/disable_warnings.rb","line":null,"source":"def disable_warnings #:yield:\n  verbose, $VERBOSE = $VERBOSE, nil\n  yield\nensure\n  $VERBOSE = verbose\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#silence_warnings":{"!":"method","declarations":["instance","public"],"path":"Kernel#silence_warnings","name":"silence_warnings","namespace":"Kernel","comment":"CREDIT: Trans\nDEPRECATE: Use #disable_warnings instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"disable_warnings()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/disable_warnings.rb","line":null,"source":"def disable_warnings #:yield:\n  verbose, $VERBOSE = $VERBOSE, nil\n  yield\nensure\n  $VERBOSE = verbose\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#enable_warnings":{"!":"method","declarations":["instance","public"],"path":"Kernel#enable_warnings","name":"enable_warnings","namespace":"Kernel","comment":"CREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"enable_warnings()","arguments":[]}],"returns":[],"file":"/lib/core/facets/kernel/disable_warnings.rb","line":null,"source":"def enable_warnings #:yield:\n  verbose, $VERBOSE = $VERBOSE, true\n  yield\nensure\n  $VERBOSE = verbose\nend","language":"ruby","dynamic":null,"tags":{}},"UnboundMethod#arguments":{"!":"method","declarations":["instance","public"],"path":"UnboundMethod#arguments","name":"arguments","namespace":"UnboundMethod","comment":"Resolves the arguments of the method to have an\nidentical signiture --useful for preserving arity.\n\n  class X\n    def foo(a, b); end\n    def bar(a, b=1); end\n  end\n\n  foo_method = X.instance_method(:foo)\n  foo_method.arguments   #=> \"a0, a1\"\n\n  bar_method = X.instance_method(:bar)\n  bar_method.arguments   #=> \"a0, *args\"\n\nWhen defaults are used the arguments must end in \"*args\".\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"arguments()","arguments":[]}],"returns":[],"file":"/lib/core/facets/unboundmethod/arguments.rb","line":null,"source":"def arguments\n  ar = arity\n  case ar <=> 0\n  when 1\n    args = []\n    ar.times do |i|\n      args << \"a#{i}\"\n    end\n    args = args.join(\", \")\n  when 0\n    args = \"\"\n  else\n    ar = -ar - 1\n    args = []\n    ar.times do |i|\n      args << \"a#{i}\"\n    end\n    args << \"*args\"\n    args = args.join(\", \")\n  end\n  return args\nend","language":"ruby","dynamic":null,"tags":{}},"Binding#local_variables":{"!":"method","declarations":["instance","public"],"path":"Binding#local_variables","name":"local_variables","namespace":"Binding","comment":"Returns the local variables defined in the binding context:\n\n  a = 1\n  b = 2\n\n  binding.local_variables  #=> [:a, :b]\n\nTODO: Rename this to prevent name clash?","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"local_variables(\n)","arguments":[]}],"returns":[],"file":"/lib/core/facets/binding/local_variables.rb","line":null,"source":"def local_variables()\n  eval(\"local_variables\")\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#hierarchical_send":{"!":"method","declarations":["instance","public"],"path":"Kernel#hierarchical_send","name":"hierarchical_send","namespace":"Kernel","comment":"Send a message to each ancestor in an object's class hierarchy.\nThe method will only be called if the method is defined for the\nancestor.\n\nThis can be very useful for setting up a `preinitialize` system.\n\n  m = Module.new do\n        attr :a\n        def preinitialize\n          @a = 1\n        end\n      end\n        \n  c = Class.new do\n        include m\n        def initialize\n          hierarchical_send(:preinitialize)\n        end\n      end\n\n  c.new.a  #=> 1","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"hierarchical_send(method_name, *args, &block)","arguments":[{"name":"method_name"},{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/kernel/hierarchical_send.rb","line":null,"source":"def hierarchical_send(method_name, *args, &block)\n  method_name = method_name.to_s if RUBY_VERSION < '1.9'\n  this = self\n  self.class.hierarchically do |anc|\n    ## is there really no better way to check for the method?\n    if anc.instance_methods(false).include?(method_name) or\n         anc.public_instance_methods(false).include?(method_name) or\n         anc.private_instance_methods(false).include?(method_name) or\n         anc.protected_instance_methods(false).include?(method_name)\n      im = anc.instance_method(method_name)\n      ##im.arity == 0 ? im.bind(this).call(&block) : im.bind(this).call(*args, &block)\n      im.bind(this).call(*args, &block)\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"todo":"Include singleton class?"}},"Module#instance_function":{"!":"method","declarations":["instance","public"],"path":"Module#instance_function","name":"instance_function","namespace":"Module","comment":"Converts module methods into instance methods such that the first parameter\nis passed +self+. This promotes DRY programming when wishing to offer both\ninheritable and module callable procedures.\n\nThis method is modeled after +module_function+ which essentially has the the\nopposite effect. Due to implementation limitations, this must use the callback\n#singleton_method_added to emulate +module_function+ when no method names\nare given.\n\n  module MyModule\n    instance_function\n\n    def self.jumble(obj, arg)\n      obj + arg\n    end\n  end\n\n  MyModule.jumble(\"Try\", \"Me\")  #=> \"TryMe\"\n\n  s = \"Try\"\n  s.extend MyModule\n  s.jumble(\"Me\")                #=> \"TryMe\"\n\nNote: This used to be a module called PromoteSelf and later Instantize,\nbefore becoming a method.\n\nNOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_function(*meths)","arguments":[{"name":"*meths"}]}],"returns":[],"file":"/lib/core/facets/module/instance_function.rb","line":null,"source":"def instance_function(*meths)\n  this = self\n  if meths.empty?\n    extend InstanceFunction\n  else\n    meths.each do |meth|\n      module_eval do\n        define_method(meth) do |*args|\n          this.__send__(meth, self, *args)\n        end\n      end\n      ##class_eval %{\n      ##  def #{meth}(*args)\n      ##    #{self.name}.#{meth}(self,*args)\n      ##  end\n      ##}\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/instance_function'"}},"Module::InstanceFunction":{"!":"module","path":"Module::InstanceFunction","name":"InstanceFunction","namespace":"Module","comment":":nodoc","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Module::InstanceFunction#singleton_method_added"],"accessors":[],"files":["/lib/core/facets/module/instance_function.rb"],"tags":{}},"Module::InstanceFunction#singleton_method_added":{"!":"method","declarations":["instance","public"],"path":"Module::InstanceFunction#singleton_method_added","name":"singleton_method_added","namespace":"Module::InstanceFunction","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"singleton_method_added(meth)","arguments":[{"name":"meth"}]}],"returns":[],"file":"/lib/core/facets/module/instance_function.rb","line":null,"source":"def singleton_method_added(meth)\n  this = self\n  ##module_eval %{\n  ##  def #{meth}(*args)\n  ##    #{self.name}.#{meth}(self,*args)\n  ##  end\n  ##}\n  module_eval do\n    define_method(meth) do |*args|\n      this.__send__(meth, self, *args)\n    end\n  end\n  super(meth)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#alias_method_chain":{"!":"method","declarations":["instance","public"],"path":"Module#alias_method_chain","name":"alias_method_chain","namespace":"Module","comment":"Encapsulates the common pattern of ...\n\n  alias_method :foo_without_feature, :foo\n  alias_method :foo, :foo_with_feature\n\nWith this, you simply do ...\n\n  alias_method_chain :foo, :feature\n\nFor example\n\n  class AliasMethodChainExample\n    def foo \n      \"foo\"\n    end\n\n    def foo_with_feature\n      \"foo!\"\n    end\n\n    alias_method_chain :foo, :feature\n  end\n\nAnd both aliases are set up for you.\n\n  example = AliasMethodChainExample.new\n  example.foo #=> \"foo!\"\n  example.foo_without_feature #=> \"foo\"\n\nQuery and bang methods (foo?, foo!) keep the same punctuation ...\n\n  alias_method_chain :foo?, :feature\n\nis equivalent to ...\n\n  alias_method :foo_without_feature?, :foo?\n  alias_method :foo?, :foo_with_feature?\n\nso you can safely chain foo, foo?, and foo! with the same feature.\n\nCREDIT: Bitsweat, Rails Team","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_method_chain(target, feature)","arguments":[{"name":"target"},{"name":"feature"}]}],"returns":[],"file":"/lib/core/facets/module/alias_method_chain.rb","line":null,"source":"def alias_method_chain(target, feature)\n  # Strip out punctuation on predicates or bang methods since\n  # e.g. target?_without_feature is not a valid method name.\n  aliased_target, punctuation = target.to_s.sub(/([?!=])$/, ''), $1\n  yield(aliased_target, punctuation) if block_given?\n\n  with_method, without_method = \"#{aliased_target}_with_#{feature}#{punctuation}\", \"#{aliased_target}_without_#{feature}#{punctuation}\"\n\n  alias_method without_method, target\n  alias_method target, with_method\n\n  case\n    when public_method_defined?(without_method)\n      public target\n    when protected_method_defined?(without_method)\n      protected target\n    when private_method_defined?(without_method)\n      private target\n  end\nend","language":"ruby","dynamic":null,"tags":{"yield":""}},"Enumerable#map_with_index":{"!":"method","declarations":["instance","public"],"path":"Enumerable#map_with_index","name":"map_with_index","namespace":"Enumerable","comment":"Same as #collect but with an iteration counter.\n\n  a = [1,2,3].collect_with_index { |e,i| e*i }\n  a  #=> [0,2,6]\n\nCREDIT: Gavin Sinclair","format":"rdoc","aliases":["Enumerable#collect_with_index"],"singleton":null,"interfaces":[{"signature":"map_with_index()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/map_with_index.rb","line":null,"source":"def map_with_index\n  r = []\n  each_with_index do |e, i|\n    r << yield(e, i)\n  end\n  r\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#collect_with_index":{"!":"method","declarations":["instance","public"],"path":"Enumerable#collect_with_index","name":"collect_with_index","namespace":"Enumerable","comment":"Same as #collect but with an iteration counter.\n\n  a = [1,2,3].collect_with_index { |e,i| e*i }\n  a  #=> [0,2,6]\n\nCREDIT: Gavin Sinclair\nAlias for map_with_index.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"map_with_index()","arguments":[]}],"returns":[],"file":"/lib/core/facets/enumerable/map_with_index.rb","line":null,"source":"def map_with_index\n  r = []\n  each_with_index do |e, i|\n    r << yield(e, i)\n  end\n  r\nend","language":"ruby","dynamic":null,"tags":{}},"Module#attr_class_accessor":{"!":"method","declarations":["instance","public"],"path":"Module#attr_class_accessor","name":"attr_class_accessor","namespace":"Module","comment":"NOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_class_accessor(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/module/attr_class_accessor.rb","line":null,"source":"def attr_class_accessor(name)\n  attr_class_reader(name)\n  attr_class_writer(name)\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/attr_class_accessor'"}},"Module#attr_class_reader":{"!":"method","declarations":["instance","public"],"path":"Module#attr_class_reader","name":"attr_class_reader","namespace":"Module","comment":"NOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_class_reader(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/module/attr_class_accessor.rb","line":null,"source":"def attr_class_reader(name)\n  module_eval(<<-EOS, __FILE__, __LINE__)\n    def self.#{name}\n      @#{name}\n    end\n    def #{name}\n      self.class.#{name}\n    end\n  EOS\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/attr_class_reader'"}},"Module#attr_class_writer":{"!":"method","declarations":["instance","public"],"path":"Module#attr_class_writer","name":"attr_class_writer","namespace":"Module","comment":"NOTE: This method is not a common core extension and is not\nloaded automatically when using <code>require 'facets'</code>.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"attr_class_writer(name)","arguments":[{"name":"name"}]}],"returns":[],"file":"/lib/core/facets/module/attr_class_accessor.rb","line":null,"source":"def attr_class_writer(name)\n  module_eval(<<-EOS, __FILE__, __LINE__)\n    def self.#{name}=(x)\n      @#{name} = x\n    end\n    def #{name}=(x)\n      self.class.#{name} = x\n    end\n  EOS\nend","language":"ruby","dynamic":null,"tags":{"uncommon":"require 'facets/module/attr_class_writer'"}},"Module#all_instance_methods":{"!":"method","declarations":["instance","public"],"path":"Module#all_instance_methods","name":"all_instance_methods","namespace":"Module","comment":"List all instance methods, equivalent to\n\n  public_instance_methods +\n  protected_instance_methods +\n  private_instance_methods\n\nTODO: Better name for #all_instance_methods?\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"all_instance_methods(include_super=true)","arguments":[{"name":"include_super","default":"true"}]}],"returns":[],"file":"/lib/core/facets/module/all_instance_methods.rb","line":null,"source":"def all_instance_methods(include_super=true)\n  public_instance_methods(include_super) +\n  protected_instance_methods(include_super) +\n  private_instance_methods(include_super)\nend","language":"ruby","dynamic":null,"tags":{}},"Enumerable#each_with_object":{"!":"method","declarations":["instance","public"],"path":"Enumerable#each_with_object","name":"each_with_object","namespace":"Enumerable","comment":"A variation of #inject that saves one from having to\nreturn the aggregate/memo argument.\n\nSay we want to count characters in a string. Using\nthe #each_with_object method we have:\n\n   \"string\".each_with_object(Hash.new(0)) do |c, h|\n     h[c] += 1\n   end\n\nversus using #inject which would be:\n\n   \"string\".inject(Hash.new(0)) do |h, c|\n     h[c] +=1\n     h\n   end\n\nNotice that the order of the block parameters is reversed.\n\nThis method used be called #injecting and had the same\nparameter order as #inject, but Ruby 1.9 has adopted this\nmethod, so we support it instead.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"each_with_object(memo)","arguments":[{"name":"memo"}]}],"returns":[],"file":"/lib/core/facets/enumerable/each_with_object.rb","line":null,"source":"def each_with_object(memo) #:yield:\n  each do |element|\n    yield(element, memo)\n  end\n  memo\nend","language":"ruby","dynamic":null,"tags":{}},"Module#alias_module_function":{"!":"method","declarations":["instance","private"],"path":"Module#alias_module_function","name":"alias_module_function","namespace":"Module","comment":"Alias a module function so that the alias is also\na module function. The typical #alias_method\ndoes not do this.\n\n  module AliasExample\n    module_function\n    def hello\n      \"Hello\"\n    end\n  end\n\n  AliasExample.hello  #=> 'Hello'\n\n  module AliasExample\n    alias_module_function( :hi , :hello )\n  end\n\n  AliasExample.hi     #=> 'Hello'","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"alias_module_function(new, old)","arguments":[{"name":"new"},{"name":"old"}]}],"returns":[],"file":"/lib/core/facets/module/alias_module_function.rb","line":null,"source":"def alias_module_function(new, old)\n  alias_method(new, old)\n  module_function(new)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#include_function_module":{"!":"method","declarations":["instance","private"],"path":"Module#include_function_module","name":"include_function_module","namespace":"Module","comment":"Include module and apply module_fuction to the\nincluded methods.\n\n  module Utils\n    module_function\n    def foo; \"foo\"; end\n  end\n\n  module UtilsPlus\n    include_function_module Utils\n  end\n\nCREDIT: Trans","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"include_function_module(*mod)","arguments":[{"name":"*mod"}]}],"returns":[],"file":"/lib/core/facets/module/include_function_module.rb","line":null,"source":"def include_function_module *mod\n  include(*mod)\n  module_function(*mod.collect{|m| m.private_instance_methods & m.methods(false)}.flatten)\nend","language":"ruby","dynamic":null,"tags":{}},"Module#instance_method_defined?":{"!":"method","declarations":["instance","public"],"path":"Module#instance_method_defined?","name":"instance_method_defined?","namespace":"Module","comment":"Query whether a public instance method is defined for the module.\n\nCREDIT: Gavin Sinclair, Noah Gibbs","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"instance_method_defined?(meth)","arguments":[{"name":"meth"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/module/instance_method_defined.rb","line":null,"source":"def instance_method_defined?(meth)\n  instance_methods(true).find{ |m| m.to_sym == meth.to_sym }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#singleton_method_defined?":{"!":"method","declarations":["instance","public"],"path":"Module#singleton_method_defined?","name":"singleton_method_defined?","namespace":"Module","comment":"Query whether a normal (singleton) method is defined for the module.\n\nCREDIT: Gavin Sinclair, Noah Gibbs","format":"rdoc","aliases":["Module#module_method_defined?","Module#class_method_defined?"],"singleton":null,"interfaces":[{"signature":"singleton_method_defined?(meth)","arguments":[{"name":"meth"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/module/instance_method_defined.rb","line":null,"source":"def singleton_method_defined?(meth)\n  singleton_methods(true).find{ |m| m.to_sym == meth.to_sym }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#module_method_defined?":{"!":"method","declarations":["instance","public"],"path":"Module#module_method_defined?","name":"module_method_defined?","namespace":"Module","comment":"Query whether a normal (singleton) method is defined for the module.\n\nCREDIT: Gavin Sinclair, Noah Gibbs","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"singleton_method_defined?(meth)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/instance_method_defined.rb","line":null,"source":"def singleton_method_defined?(meth)\n  singleton_methods(true).find{ |m| m.to_sym == meth.to_sym }\nend","language":"ruby","dynamic":null,"tags":{}},"Module#class_method_defined?":{"!":"method","declarations":["instance","public"],"path":"Module#class_method_defined?","name":"class_method_defined?","namespace":"Module","comment":"Query whether a normal (singleton) method is defined for the module.\n\nCREDIT: Gavin Sinclair, Noah Gibbs","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"singleton_method_defined?(meth)","arguments":[]}],"returns":[],"file":"/lib/core/facets/module/instance_method_defined.rb","line":null,"source":"def singleton_method_defined?(meth)\n  singleton_methods(true).find{ |m| m.to_sym == meth.to_sym }\nend","language":"ruby","dynamic":null,"tags":{}},"NA = ArgumentError.new.method_missing":{"!":"method","declarations":["class","public"],"path":"NA = ArgumentError.new.method_missing","name":"method_missing","namespace":"NA = ArgumentError.new","comment":"","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(*))","arguments":[]}],"returns":[],"file":"/lib/core/facets/na.rb","line":null,"source":"def method_missing(*); self; end","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise#__result__":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#__result__","name":"__result__","namespace":"Lazy::Promise","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__result__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def __result__ #:nodoc:\n  __synchronize__ do\n    if @computation\n      raise LazyException.new( @exception ) if @exception\n\n      computation = @computation\n      @computation = DIVERGES # trap divergence due to over-eager recursion\n\n      begin\n        @result = demand( computation.call( self ) )\n        @computation = nil\n      rescue DivergenceError\n        raise\n      rescue Exception => exception\n        # handle exceptions\n        @exception = exception\n        raise LazyException.new( @exception )\n      end\n    end\n\n    @result\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise#inspect":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#inspect","name":"inspect","namespace":"Lazy::Promise","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def inspect #:nodoc:\n  __synchronize__ do\n    if @computation\n      \"#<#{ __class__ } computation=#{ @computation.inspect }>\"\n    else\n      @result.inspect\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise#respond_to?":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#respond_to?","name":"respond_to?","namespace":"Lazy::Promise","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"respond_to?(message)","arguments":[{"name":"message"}]}],"returns":[{"type":"Boolean","comment":""}],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def respond_to?( message ) #:nodoc:\n  message = message.to_sym\n  message == :__result__ or\n  message == :inspect or\n  __result__.respond_to? message\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Promise#method_missing":{"!":"method","declarations":["instance","public"],"path":"Lazy::Promise#method_missing","name":"method_missing","namespace":"Lazy::Promise","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"method_missing(*args, &block)","arguments":[{"name":"*args"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def method_missing( *args, &block ) #:nodoc:\n  __result__.__send__( *args, &block )\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::PromiseSafe":{"!":"class","superclass":"Lazy::Promise","path":"Lazy::PromiseSafe","name":"PromiseSafe","namespace":"Lazy","comment":"= PromiseSafe\n\nThread safe version of Promise class.","format":"rdoc","constants":["Lazy::Promise::DIVERGES"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Lazy::PromiseSafe#__synchronize__"],"accessors":[],"files":["/lib/core/facets/lazy.rb"],"tags":{}},"Lazy::PromiseSafe#__synchronize__":{"!":"method","declarations":["instance","public"],"path":"Lazy::PromiseSafe#__synchronize__","name":"__synchronize__","namespace":"Lazy::PromiseSafe","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"__synchronize__()","arguments":[]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def __synchronize__ #:nodoc:\n  current = Thread.current\n\n  Thread.critical = true\n  unless @computation\n    # fast path for evaluated thunks\n    Thread.critical = false\n    yield\n  else\n    if @owner == current\n      Thread.critical = false\n      raise DivergenceError.new\n    end\n    while @owner # spinlock\n      Thread.critical = false\n      Thread.pass\n      Thread.critical = true\n    end\n    @owner = current\n    Thread.critical = false\n\n    begin\n      yield\n    ensure\n      @owner = nil\n    end\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Lazy::Future":{"!":"class","superclass":"Lazy::PromiseSafe","path":"Lazy::Future","name":"Future","namespace":"Lazy","comment":"= Future\n\nFuture class subclasses PromiseSafe.","format":"rdoc","constants":["Lazy::Promise::DIVERGES"],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Lazy::Future#initialize"],"accessors":[],"files":["/lib/core/facets/lazy.rb"],"tags":{}},"Lazy::Future#initialize":{"!":"method","declarations":["instance","public"],"path":"Lazy::Future#initialize","name":"initialize","namespace":"Lazy::Future","comment":":nodoc:","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"initialize(&computation)","arguments":[],"block":{"name":"&computation"}}],"returns":[{"type":"Future","comment":"a new instance of Future"}],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def initialize( &computation ) #:nodoc:\n  result = nil\n  exception = nil\n\n  thread = Thread.new do\n    begin\n      result = computation.call( self )\n    rescue Exception => exception\n    end\n  end\n\n  super() do\n    raise DivergenceError.new if Thread.current == thread\n    thread.join\n    raise exception if exception\n    result\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#promise":{"!":"method","declarations":["instance","public"],"path":"Kernel#promise","name":"promise","namespace":"Kernel","comment":"The promise() function is used together with demand() to implement\nlazy evaluation.  It returns a promise to evaluate the provided\nblock at a future time.  Evaluation can be demanded and the block's\nresult obtained via the demand() function.\n\nImplicit evaluation is also supported: the first message sent to it will\ndemand evaluation, after which that message and any subsequent messages\nwill be forwarded to the result object.\n\nAs an aid to circular programming, the block will be passed a promise\nfor its own result when it is evaluated.  Be careful not to force\nthat promise during the computation, lest the computation diverge.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"promise(&computation)","arguments":[],"block":{"name":"&computation"}}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def promise( &computation ) #:yields: result\n  Lazy::Promise.new(&computation)\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#demand":{"!":"method","declarations":["instance","public"],"path":"Kernel#demand","name":"demand","namespace":"Kernel","comment":"Forces the result of a promise to be computed (if necessary) and returns\nthe bare result object.  Once evaluated, the result of the promise will\nbe cached.  Nested promises will be evaluated together, until the first\nnon-promise result.\n\nIf called on a value that is not a promise, it will simply return it.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"demand(promise)","arguments":[{"name":"promise"}]}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def demand( promise )\n  if promise.respond_to? :__result__\n    promise.__result__\n  else # not really a promise\n    promise\n  end\nend","language":"ruby","dynamic":null,"tags":{}},"Kernel#future":{"!":"method","declarations":["instance","public"],"path":"Kernel#future","name":"future","namespace":"Kernel","comment":"Schedules a computation to be run asynchronously in a background thread\nand returns a promise for its result.  An attempt to demand the result of\nthe promise will block until the computation finishes.\n\nAs with Kernel.promise, this passes the block a promise for its own result.\nUse wisely.","format":"rdoc","aliases":[],"singleton":null,"interfaces":[{"signature":"future(&computation)","arguments":[],"block":{"name":"&computation"}}],"returns":[],"file":"/lib/core/facets/lazy.rb","line":null,"source":"def future( &computation ) #:yields: result\n  Lazy::Future.new(&computation)\nend","language":"ruby","dynamic":null,"tags":{}},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":null,"text":"= Ruby Facets\n\n\"ALL YOUR BASE ARE BELONG TO RUBY\"\n\n\n== Introduction\n\nRuby Facets is the premiere collection of general purpose method\nextensions and standard additions for the Ruby programming language.\n\nFacets houses the largest single collection of methods available for\nextending the core capabilities of Ruby's built-in classes and modules.\nThis collection of extension methods are unique by virtue of their atomicity.\nThe methods are stored in individual files so that each can be required\nindependently. This gives developers the potential for much finer control over\nwhich extra methods to bring into their code.\n\nIn addition Facets provides a collection of extensions to Ruby standard library\nplus a small collection of add-on classes and modules. Together these\nlibraries constitute an reliable source of reusable components, suitable\nto a wide variety of usecases.\n\n\n== Resources\n\n* Homepage: http://rubyworks.github.com/facets\n* Report Bugs: http://github.com/rubyworks/facets/issues\n* Mailing List: http://groups.google.com/group/facets-universal/topics\n* Wiki Pages: http://wiki.github.com/rubyworks/facets\n* Source Code: http://github.com/rubyworks/facets\n\n\n== Documentation\n\nFacets has special documentation needs due to it's extensive bredth.\nThe documentation generated when installing via RubyGems, or the YARD\ndocs provided by rubydoc.info can be somewhat unweildly because it\ncombines all of Facets in one large set. When using these resources,\nit is important to remain aware of the source location of particular\nmethods.\n\nFor better organized online documentation, generated to separate core\nextensions from standard libraries, see the {Learn Facets}[http://rubyworks.github.com/facets/learn.html] page\non the website for links to available documentation.\n\n\n== Installation\n\n=== RubyGems\n\nThe easiest way to install is via RubyGems.\n\n  $ gem install facets\n\n=== Setup.rb\n\nFacets can be installed the old-fashioned way using Ruby Setup (http://rubyworks.github.com/setup).\nDownload and unpack the .tar.gz package and run setup.rb, like so:\n\n  $ tar -xvzf facets-2.x.x.tar.gz\n  $ cd facets-2.x.x\n  $ sudo setup.rb\n\nFacets 2.8+ requires Ruby 1.8.7 or higher.\n\n\n== Mission\n\nFacets holds to the notion that the more we can *reasonably* integrate into\na common foundation, directed toward general needs, the better that foundation\nwill be able to serve the community. There are a number of advantages here:\n\n* Better Code-reuse\n* Collaborative Improvements\n* Greater Name Consistency\n* One-stop Shop and Installation\n\n\n== Usage\n\n=== CORE Library\n\nAt the heart of Ruby Facets is the CORE extensions library. CORE provides\na sizable collection of generally useful methods, along with a few supporting\nclasses, that extend the functionality of Ruby's core classes and modules.\n\nWith the exception of a few *uncommon* extensions, CORE contains anything that\nwill load automatically when issuing:\n\n  require 'facets'\n\nThis loads all the CORE functionality at once. If you plan to use more then a\nhandful of Facets core methods it is recommended that you require the library in\nthis way. However, you can also \"cherry pick\" the CORE library as you prefer.\nAnd for uncommon extensions this must be done. The general require statement for\na core extension library is:\n\n  require 'facets/<class|module>/<method>'\n\nFor example:\n\n  require 'facets/time/stamp'\n\nMost \"atoms\" contain only one method, but exceptions occur when methods\nare closely tied together.\n\nYou can load per-class or per-module groups of core methods by requiring the\nclass or module by name. For example\"\n\n  require 'facets/time'\n\nWill require all the core Time method extensions.\n\nNote that some methods that were part of CORE in 1.8 and earlier are now part\nof MORE libraries. A good example is 'random.rb'. There were separated because\nthey had more specialized use cases, where as CORE extensions are intended as\ngeneral purpose.\n\n==== Method File Names\n\nOperator method redirect files are stored using English names. For instance \n`Proc#*` is `proc/op_mul`.\n\nFor reference, here is the chart.\n\n     +@   => op_plus\n     -@   => op_minus\n     +    => op_add\n     -    => op_sub\n     **   => op_pow\n     *    => op_mul\n     /    => op_div\n     %    => op_mod\n     ~    => op_tilde\n     <=>  => op_cmp\n     <<   => op_lshift\n     >>   => op_rshift\n     <    => op_lt\n     >    => op_gt\n     ===  => op_case\n     ==   => op_equal\n     =~   => op_apply\n     <=   => op_lt_eq\n     >=   => op_gt_eq\n     |    => op_or\n     &    => op_and\n     ^    => op_xor\n     []=  => op_store\n     []   => op_fetch\n\nFacets simply takes the '*' and translates it into a string acceptable to all\nfile systems. Also, if a method ends in '=', '?' or '!' it is simply removed.\n\n\n=== MORE Library (aka Standard Library)\n\nOn top of the extensive CORE library, Facets provides extensions for Ruby's\nstandard library, as well as very small collection of additional modules and\nclasses to supplement it.\n\nUse this library like you would any other 3rd party library.\nThe only difference between Facet's Standard library and other libraries\nis the lack of any enclosing @Facets::@ namespace. This is becuase\nthe libraries provided by Facets are fairly low-level and very general \npurpose.\n\nWhen using Facets extended versions of Ruby's standard libraries,\nthe libraries have to loaded manually, of course. However you\ndo not need to load Ruby's library first, as the Facets' library\nwill do that automatically.\n\nFor example, normally one load Ruby's OpenStruct class via:\n\n  require 'ostruct'\n\nTo load 'ostruct.rb' plus Facets extensions for it simply use:\n\n  require 'facets/ostruct'\n\nFor details pertaining to the functionality of each feature,\nplease see the API documentation.\n\n\n== Contribute\n\nThis project thrives on contribution!\n\nIf you have any extension methods, classes or modules that you think have\nvery general applicability and would like to see them included in\nthis project, don't hesitiate to submit. Also, if you have better versions\nof any thing already included or simply have a patch, they are more than\nwelcome. We want Ruby Facets to be of the highest quality.\n\n\n== Authors\n\nThis collection was put together by, and largely written by Trans. He can be\nreached via email at transfire at gmail.com.\n\nSome parts of this collection were written and/or inspired by other persons.\nFortunately nearly all were copyrighted under the same open license, the Ruby\nLicense, or the more liberal BSD and MIT licenses. In the one or two exceptions\nI have included the copyright notice with the source code. Any code file not\nspecifically labeled othewise shall fall under the Ruby License.\n\nIn all cases, I have made every effort to give credit where credit is due.\nYou will find these acknowledgments embedded in the source code. You can see\nthem in \"CREDIT:\" and/or \"@author\" lines. \n\nAlso see the {Contibutors page}[https://github.com/rubyworks/facets/wiki/Contributors]\non the Wiki for a list of all contributing Rubyists. If anyone is missing from\nthe list, please let me know and I will correct right away. Thanks.\n\n\n== License\n\nThe collection PER COLLECTION is licensed as follows:\n\n  Ruby Facets\n  Copyright (c) 2004,2010 Rubyworks\n\n  Distributed under the terms of the Ruby license.\n\nThe Ruby license is a dual license that also provides for use of the GPL.\nComplete texts of both licenses accompany this document (see LICENSE).\n\nAcknowledgments and Copyrights for particular snippets of borrowed code\nare given in their respective source. All licenses are either compatible\nwith the Ruby license or the original author has given permission for\ninclusion of their code under such license.\n\n\n\"ALL YOUR BASE ARE BELONG TO RUBY!\"\n\nRuby Facets, Copyright (c)2005,2011 Rubyworks\n\nDo you Ruby? (http://ruby-lang.org)\n\n","format":"text/rdoc"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":null,"text":"= Facets Release History\n\n== 2.9.3 / 2011-12-31\n\nHappy New Year! Ruby Facets kicks off the year with a 2.9.x release.\nThis release adds a number of new methods, a few general improvements\nand bug fixes, a couple of deprecations and finally settles the \nproject down to a two-part core/standard project organization.\n\nChanges:\n\n* New Features\n\n  * Add Hash#url_params. (Matt Kirk)\n  * Add Enumerable#hashify. (Ronen Barzel)\n  * Add String#briefcase, similar to #titlecase.\n  * Add Kernel#hierarchical_send (better replacement for preinitialize.rb).\n  * Add Class#hierarchically, which supports #hierarchical_send.\n  * Add Array#median, to get the sorted middle of an array.\n  * Add Math#percentile and Math#median.\n  * Add Instantiable mixin (returns from Mixers spin-off project).\n  * Add Equitable mixin (returns from Mixers spin-off project).\n  * Add Cloneable mixin (returns from Mixers spin-off project).\n  * Add Array#each_pair and #each_value.\n  * Add Numeric#positive? and #numeric?.\n  * Add Method#* and #^ composition methods. (Mike Burns)\n  * Add back Fixnum::MAX and MIN constants.\n  * Add Binding#with.\n\n* Improved Features\n\n  * Improve FileUtils#amass to be more robust.\n  * Improve String#snakecase to convert spaces to underscores.\n  * Improve String#camelcase to convert spaces to \"camels\".\n  * Improve String#snakecase to not handle path names (use #pathize).\n  * Improve String#camelcase to not handle module names (ise #modulize).\n  * Improve Numeric#approx? bu using ratio.\n\n* Renamed Features\n\n  * Rename Enumerable#has? to #incase?.\n\n* Bug Fixes\n\n  * Fix Hash#rekey to keep default_proc.\n  * Fix Binding#self to not be defined for Rubinius.\n\n* Deprecations\n\n  * Deprecate Preinitializable mixin.\n  * Deprecate main.rb, spun-off to `main_like_module` gem.\n\n* Implementation Details\n\n  * Reconsolidated library into just two parts, `core` and `standard`.\n  * The term \"more\" is just a synonym for \"standard\" now.\n  * Relative requires are being used more extensively.\n  * Collection scripts, e.g. `require 'facets'`, are static.\n\n\n== 2.9.2 / 2011-08-23\n\nThe main purpose of this release is a fix for Module#redefine_method,\nso it will not conflict with ActiveSupport. Beyond that a handful of new\nmethods have been added. This release also marks the start of using\na src/ directory to generate the lib/ directory.\n\nChanges:\n\n* New Features\n\n  * Add Enumerable#map_with and alias #zip_map.\n  * Hash#delete_values returns removed keys (#12).\n  * Add clap-like command-line parser to Shellwords.\n  * Add Module#let, akin to RSpec's method.\n  * Add uncommon Module#method_clash method.\n  * Add uncommon Class#singleton? method.\n\n* Bug Fixes\n\n  * Fix Module#redefine_method to use #remove_method.\n  * Fix Kernel#object_hexid, or at least try to do so again.\n  * Fix Exception#detail to not return backtrace if nil.\n\n\n== 2.9.1 / 2011-01-30\n\nPrimarily this release fixes a couple of small issues. But also a handful of\nnew methods have been added.\n\nChanges:\n\n* New Features:\n\n  * Add FileTest#absolute? and #relative?\n  * Add FileTest#contains?\n  * Add FileTest#safe?\n  * Add FileUtils#amass\n  * Add FileUtils#outofdate\n  * Add FileUtils#stage\n  * Add Kernel#yes? and Kernel#no?\n  * Add Enumerable#has? (TOUR library)\n  * Add Digest#salted_digest, etc.\n  * Add Digest#base64digest (1.9.2 method)\n  * Add String#random_binary\n\n* Improved Features\n\n  * Better OS detection in Platform class and RBConfig module\n  * Moved CPU byte order methods from RBConfig to Platform class\n  * General improvements to Platform class API\n\n* Bug Fixes\n\n  * Module#redefine_method need not check pre-existence of method\n  * Fix string/unquote.rb recursive require\n  * Kernel#object_hexid varies on CPU arch, not Ruby version.\n\n\n== 2.9.0 / 2010-09-01\n\nThis release is fairly extensive as it was originally intended to be v3.0.\nAfter further consideration it was decided to reserve v3.0 for the\npolish of real world feedback and more progressive changes. The primary\nfocus of this release has been the completion of migrating Facets into a true\nextensions library. With this release almost all add-on classes and mixins\nhave now been spun-off to other projects. Only the most general purposes\nadd-on classes and mixins remain.\n\nA new TOUR library division has also been added to complement CORE and MORE.\nThis division houses purely optional extensions. The new division serves\na couple of useful purposes. In particular, it helps separates the standard\nlibrary extensions from optional core extension in the RDocs and thus makes\nthe perfect place to vet new extension ideas.\n\nOne important change that will effect anyone using Facets along side\nActiveSupport is that Facets no longer tries to conditionally avoid\nmethod overlaps with ActiveSupport. This is fine for the upcoming\nActiveSupport 3.0 library which extends core classes directly instead of\nusing mixins. One need only require 'facets' in the Rails config/preinitializer.rb\nfile and ActiveSupport will take precedence over Facets. For older versions\nof ActiveSupport, the best approach is to cherry pick from Facets just the\nextensions you want, thus avoiding any conflicts. There are actually only a\ndozen or so overlaps and all are intended to compatible, but it doesn't hurt\nto be sure.\n\nLastly, it is worth mentioning that this release has been more thuroughly\ntested than any version of Facets to date. Thanks to RVM this release runs\ngreen on Ruby 1.8.6, 1.8.7 and 1.9.2.\n\nChanges:\n\n* New Features\n\n  * Add Kernel#temporarily, set variables temporarily and eval block\n  * Add Kernel#deep_clone, a better alternative to #deep_copy\n  * Add Kernel#present? and Kernel#presence\n  * Add Kernel#not and #not?\n  * Add Array#extract_options!, for pulling options off argument list\n  * Add Regexp#|, operator for Regexp#union\n  * Add Array#percentile and Array#median\n  * Add Module#memo, for instance level memoization\n  * Add YAML.read method\n  * Add Pathname#include?\n  * Add Module#anonymous?\n  * Add Module#copy_inheritor\n  * Add Indexable#from and Indexable#upto\n  * Add Array#from and Array#thru\n  * Add NA class via na.rb\n  * Add Memoizable in memoizable.rb for a more robust memoization system\n  * Add Module#safe_memo in thread.rb for thread safe memoization\n  * Add Kernel#sandbox in thread.rb for threaded $SAFE=4 evaluation\n  * Add Hash#subset\n  * Add Kernel#Y to tour library\n  * Add numerous Math extensions\n\n* Deprecations\n\n  * Deprecate Module#attr_toggler as a YAGNI\n  * Deprecate Kernel#class_eval b/c of it's confusing behavior\n  * Deprecate Module#once is no longer an alias for #memoize\n  * Deprecate Integer#succ(n) (for compatibility reasons)\n  * Deprecate Stackable, it's method were moved to CORE\n  * Deprecate Kernel#populate and #set_from (use #assign and #assign_from)\n  * Deprecate Kernel#non_nil? since #not_nil? is enough\n  * Deprecate #__HERE__ b/c implementation was unreliable\n  * Deprecate Time#since, use #less instead\n  * Deprecate Time#advance, use #shift instead\n  * Deprecate Kernel#super_as (no good way to get callers method name)\n  * Deprecate Integer#clear_bit, use #bit_clear instead\n  * Deprecate Kernel#resc, use String#to_re or #to_rx instead\n  * Deprecate Module#modspace\n  * Deprecate Kernel#__ and class X for Proc#partial, use NA instead\n  * Deprecate autoreload.rb has been spun-off to a separate project\n  * Deprecate Module#nesting, b/c redundant and overlap with Module.nesting\n\n* Renamed Features\n\n  * Rename Module#parent            to Module#enclosure\n  * Rename Module#parents           to Module#enclosures\n  * Rename Module#parent_name       to Module#modname\n  * Rename Array#recurisvely        to Array#recurse  \n  * Rename Hash#recurisvely         to Hash#recurse\n  * Rename Enumerable#recursive     to Enumerable#recursively\n  * Rename Array#recursive          to Array#recursively\n  * Rename Hash#recursive           to Hash#recursively        \n  * Rename Kernel#silence_warnings  to Kernel#disable_warnings\n  * Rename Hash#recursive_merge     to Hash#deep_merge\n  * Rename Class#prepend            to Class#preallocate\n  * Rename File#atomic_write        to FileUtils#atomic_write\n  * Rename Module#conflict          to Module#method_clash\n  * Rename Class#inheritor          to Module#class_inheritor\n  * Rename Symbol#re_s              to Symbol#as_s\n  * Rename String#chars             to String#characters\n  * Rename String#outdent           to String#unindent\n  * Rename Time#round               to Time#round_to\n  * Rename Time#hence               to Time#shift (but keep aliases)\n  * Rename Hash#zipnew              to Hash#zip\n\n* Moved Libraries\n\n  * Move roman.rb to integer/roman and string/roman.rb\n  * Move blank.rb to kernel/blank.rb\n  * Move facets-live.rb to facets/auto_core.rb\n  * Move cattr.rb to MORE library\n  * Move duplicable.rb to kernel/dup.rb\n  * Move bitmask.rb to integer/bitmask.rb\n  * Move enumerable/divide.rb to array/divide.rb\n  * Move enumerable/split.rb to array/split.rb\n  * Move enumerable/entropy.rb to array/entropy.rb\n  * Move enumerable/probability.rb to array/probability.rb\n  * Move enumerable/duplicates.rb array/duplicates.rb\n  * Move module/enclosure.rb to optional TOUR libs\n  * Move kernel/instance_exec to option TOUR libs\n\n* Bug Fixes\n\n  * Fix Fixed Hash#rekey! from clobbering previous keys\n  * Fix Exception#raised? is a class method\n  * Fix Enumerator#fx should use #map instead of #each\n  * Fix String#splice needs String#store\n  * Fix Kernel#blank? empty condition was faulty\n  * Fix Comparable#bound needs clip.rb, not cap.rb\n  * Fix String#file needs to pass block\n  * Fix String#edit_distance use new encodings for Ruby 1.9\n\n* Improved Features\n\n  * New lib/tour division of libraries\n  * Module#class_extend dynamically creates append_features method\n  * Kernel#require_all is only for relative requires\n  * __DIR__ can take subdirectory arguments\n  * Hash#join has more sensible default separator (' ')\n  * Some OpEsc escapes have been renamed\n  * Kernel#assign does not accept a block\n  * Kernel#try is now like ActiveSupport's\n  * Improved #respond (which is like old #try)\n  * Remove all `if defined?(ActiveSupport)` conditions\n  * Use #random_range to support specialized Range#at_rand functionality\n  * Use Comparable.[] instead of Comparable()\n  * Array#rotate rotates in opposite direction than before (b/c or Ruby 1.9)\n\n\n== 2.8.4 / 2010-04-27\n\nA minor point release just to get a few improvements out there before\nendeavering into more extensive work for the next major release.\n\n* New Features\n\n  * Added #glob_relative to Pathname\n\n* Deprecations\n\n  * Deprecated BlankSlate (use BasicObject)\n  * Deprecate hashbuilder.rb\n  * Removed casting_hash.rb, moved to new library\n  * Removed opencollection.rb, moved to new library\n  * Removed ansicode.rb, use ansi gem\n\n* Bug Fixes\n\n  * changed Numeric#length to return self, not to_s.self\n  * Fix mispelling of Class#descendants\n\n* Other Improvements\n\n  * Range#at_rand has been optimized\n  * Kernel#singleton_class no longer can take a block\n  * Hash#to_proc takes response argument replacing #to_proc_with_response\n  * OpenHash becomes more like OpenObject and OpenObject becomes bare bones\n  * Range#at_rand optimized for Fixnum/Bignum instead of Integer\n\n\n== 2.8.3 / 2010-04-10\n\nNew release which makes a few adjustments in Kernel core extensions,\nadds a few new extensions and additions, plus other small improvements.\nThe biggest change is the addition of Recusor, which is created via\nEnumerable#recursive. This class is somewhat like Enumerator and\nprovides a number of recursive methods.\n\nChanges:\n\n* 9 New Core Extensions\n\n  * Enumerable#recursive provides a number of other recursive methods.\n  * Enumerable#visit can be used to recursively iterate any Enumerable.\n  * Module#set has been added (from Sinatra).\n  * Symbol#/ is added to be like String#/.\n  * Struct#to_h is added and will ultimately replace Struct#attributes.\n  * ObjectSpace#reflect routes method calls to Kernel context.\n  * Hash#to_module converts a hash to mixin module (Jay Fields).\n  * Kernel#dup! is same as #try_dup from extlib.\n  * Add File#ext which is a useful variation of #extname (Lavir the Whiolet).\n\n* 3 Core Extensions Renamed\n\n  * Renamed #set_from to #assign_from (alias remains until Kernel#set is considerd).\n  * Renamed #populate to #assign and improve.\n  * Kernel#instance_vars is now Kernel#instance and also more useful.\n\n* 1 Core Deprecation\n\n  * Removed #instance_eval hack.\n\n* 2 Core Bug Fixes\n\n  * #map_with_index now uses #each_with_index.\n  * #to_proc_with_response spelling correction.\n\n* 1 Core Adjustment\n\n  * Aliased #metadef to #meta_def.\n\n* 3 New More Libraries\n\n  * casting_hash.rb provides CastingHash class, a hash with flexible keys and values.\n  * prepend.rb allows for AOP-like inclusion of modules.\n  * roman.rb provides simple roman numeral extensions to String and Integer.\n\n* 5 More Improvements\n\n  * Pathname#visit for iterating all entries beneath a path (chikamichi).\n  * Pathname#to_str, b/c Pathname is basically a type of String (from extlib).\n  * Range#at_rand in random.rb handles Float ranges (Lavir the Whiolet).\n  * FileUtils#cp_rx provides controlled copies.\n  * Stash class in stash.rb is improved and is now available as a stand-alone library.\n  * ioredirect.rb has been removed as IORedirect no longer worked.\n  * plugin_manager.rb has been removed. Use 'plugin' gem instead.\n\n\n== 2.8.2 / 2010-02-22\n\nThis release fixes a bug by removing Numeric#size. Turns out that was a\ncore method already. It includes an \"auditing\" of the core enumerable\nmethod which has led to a few modifications most noteable amoung them\nrenaming #map_detect to #find_yield and #compact_map to #purge.\n\nChanges:\n\n* 7 New Core Extensions\n\n  * Add Enumerable#each_with_object.\n  * Add #collapse which is a shortcut for flatten.compact.\n  * Add Numeric#spacing (Mr. Groff)\n  * Add Array#uniq_by! to complement Enumerable#uniq_by.\n  * Add String#exclude? as opposite of #include?\n  * Add Enumerable#exclude? as opposite of #include?\n  * Add Proc#bind_to \n\n* 2 Extensions Renamed\n\n  * Rename Enumerable#compact_map to #purge.\n  * Rename Enumerable#map_detect to #find_yield.\n\n* 4 Deprecations\n\n  * Deprecate #inject!/#injecting in favor of #filter.\n  * Deprecate Array#** as alias of #product.\n  * Remove Numeric#size, as it was already used by core.\n  * Spun tracepoint.rb off as a seprate library.\n\n* 3 Other Changes\n\n  * Integer#multiple? handles zero as an argument.\n  * facets.rb is now dynamically loaded instead of code generated.\n  * General imporvements to date.rb.\n\n\n== 2.8.1 / 2009-12-25\n\nThis release simply fixes a few minor issues.\n\nChanges:\n\n* 1 New Standard Extension\n\n  * Added Pathname#glob_relative to pathanme.rb.\n\n* 3 Adjustments\n\n  * Loading string/tab.rb no longer loads margin.rb or expand_tab.rb.\n  * Fixed FileList method delegations.\n  * Numeric#length and #size return +self+, not +to_s.length+.\n\n\n== 2.8.0 / 2009-11-05\n\nFacets 2.8 effectively completes the MORE library clean-up which peaked\nwith the previous 2.7 release. Another eight libraries have been deprecated,\na few of them spun-off to a separate project. However, this verison also\nreverts a few of the deprecations made in the last version. These libs \nwill remain in Facets's MORE library for the forseeable future.\n\nThis version effectively concludes the MORE library clean-up. The next, and\nlast version before Facets 3.0, will focus on \"auditing\" the CORE library.\n\nChanges:\n\n* 6 Libraries \"Undeprecated\":\n\n  * ini.rb\n  * linkedlist.rb\n  * matcher.rb\n  * memoizer.rb\n  * roman.rb\n  * semaphore.rb\n\n* 5 Libraries Deprecated:\n\n  * fileable.rb    (too esoteric)\n  * ioredirect.rb  (needs better implementation)\n  * coroutine.rb   (because of Fiber)\n  * capsule.rb     (may be spun-off)\n  * recorder.rb    (may be spun-off)\n\n* 3 Libraries Spun-Off and Deprecated:\n\n  * ansicode.rb           ansi\n  * progressbar.rb        ansi\n  * logger.rb             ansi\n\n* Additonal Enhancements:\n\n  * Kernel#extend can now take a block\n  * Fixed kernel#d so it is useable\n  * Added Range#at_rand (thanks to Tyler Rick)\n  * Added Enumerable#map_detect (thanks to Scott Taylor)\n  * String#/ calls File.join\n  * Added String#newlines and String#cleanlines\n  * String#titlecase includes apostrophe in words\n  * BasicObject/BlankSlate is more compliant with 1.9.1 design\n  * Enumerable#count can take multiple items, treats as logical Or\n  * Class#class_extend extends class level, not class_eval\n  * Integer#succ(n) becomes Fixnum#succ(n), succ.rb\n  * Complete rewrite of Inheritor\n  * Shellwords extensions have been reworked\n  * Added String#similarity\n  * Added Levenshtein String#edit_distance method\n  * And other minor improvements (some thanks to ccjr)\n\n\n== 2.7.0 / 2009-08-01\n\nFacets 2.7 is the biggest release of Facets since 2.4. Rather then trickle-release these\nchanges over the course of the 2.6.x series, I made the decision to let 2.7 have them\nall at once. In so doing this release nearly completes the process of trimming down\nthe MORE library to its essentials. Over 40 high-level libraries have been spun-off\nas separate gems and/or deprecated. No doubt this is a big change for Facets, and the\ntransition may be a bit bumpy over the short-term, but I am certain that in the long-run\neveryone involved will be better served. To help, I have listed the effected libraries\nand the alternate gems availble to take their place.\n\nA few other changes have also been made in the release that may also effect your code.\nIn particular you should note that #class_extension has been renamed to #class_extend\n(require 'facets/class_extend'). In addition we have added a few new core methods such\nas Exception#raised? and Symbol#thrown?.\n\nChanges:\n\n* Spun-Off Projects\n\nThese libraries have been deprectated from Facets entirely, but are available\nas separate gems (or soon will be).\n\n    LIBRARY               GEM\n    --------------------  ------------------------------\n    overload.rb           overload\n    binreadable.rb        binaryio\n    downloader.rb         downloader\n    xoxo.rb               xoxo\n    bicrypt.rb            bicrypt\n    typecast.rb           typecast\n    association.rb        association\n    syncarray.rb          sync\n    synchash.rb           sync\n    paramix.rb            paramix\n    crypt.rb              crypt3\n    lrucache.rb           lrucache\n    net/smtp_tls.rb       smtp_tls\n    advisable.rb          advisable\n    buildable.rb          buildable\n    memoizer.rb           memoizer\n    harray.rb             sparray\n    sparse_array.rb       sparray\n    iteration.rb          iteration\n    interval.rb           stick\n    infinity.rb           stick\n    pool.rb               pool\n    linkedlist.rb         linkedlist\n    semaphore.rb          semaphore\n    pqueue.rb             pqueue\n    censor.rb             language\n    matcher.rb            language\n    basex.rb              radix\n    minitar.rb            archive-tar-minitar -or- folio\n\n* Spun-Off But Still Available\n\nThese libraries have been spun-off into stand-alone gems, but remain\navailable via Facets too. Ultimately some of these will be removed\nfrom Facets too (in particular the ansi libraries).\n\n    LIBRARY               GEM\n    --------------------  ------------------------------\n    ansicode.rb           ansi\n    progressbar.rb        ansi\n    logger.rb             ansi\n    tracepoint.rb         tracepoint\n    dictionary.rb         dictionary\n    recorder.rb           recorder\n    ostructable.rb        ostructable -or- openhash\n    openobject.rb         openhash\n    opencollection.rb     openhash\n    opencascade.rb        openhash\n    openhash.rb           openhash\n    openmodule.rb         openmodule\n    fileable.rb           fileable\n    enumerablepass.rb     enumargs\n\n* Deprecations Without Current Replacement\n\nThe libraries have been deprecated but do not yet have replacements.\nSeperate gems for these are planned though.\n\n    * bbcode.rb\n    * ini.rb\n    * settings.rb\n    * xmlhash.rb\n\n* Deprecations Merged Into CORE\n\nThese libraries have been deprecated because their functionality was merged into\nthe CORE library and/or made available in some another way.\n\n    * 1stclassmethod.rb   #method! and #instance_method! are now part of CORE.\n    * elementor.rb        #per has been added to CORE.\n    * elementwise.rb      #ewise has been added to CORE.\n    * consoleutils.rb     #ask is in CORE, for the rest see Ansi or Clio project.\n    * attr.rb             Added Module#attr_setter to CORE, and separated the rest in MORE.\n\n* General Deprecations\n\nThese libraries have simply been deprecated because they were found lacking in\nsome significant fashion.\n\n    * nilstatus.rb        Poved rather useless, not to mention trivial.\n    * heap.rb             Heap was just an alias for PQueue anyway. Use 'pqueue' instead.\n    * dependency.rb       Other solutions exist that are much better (like Advisable).\n    * classmethods.rb     #class_extend solution is more robust.\n    * ziputils.rb         Have a look at Folio (gem install folio) for replacement.\n    * unheritable.rb      Implementation is trivial and usefulness questionable.\n    * instantise.rb       Replaced by instance_function.rb.\n\n* Other Enhancements\n\n    * Fixed Proc#curry to work with #define_method (Thanks to R.Potter)\n    * Module#class_extension has been renamed to #class_extend (require 'facets/class_extend').\n    * kernel#instance is no longer in core; now it is an extra monkey patch for #instance_eval.\n    * Kernel#this has been removed. It is equivalent to 'method(__method__)'.\n    * BlankSlate is now an alias for BasicObject, and will be deprecated in the future.\n    * Kernel#method! and Module#instance_method! now use a global variable for their cache.\n    * #object_state (old name was #state) has been added to core.\n\n\n== 2.6.0 / 2009-07-03\n\nFacets 2.6.0 removes htmlfilter.rb and cssfilter.rb due to licensing\nincompatability. These scripts are now available as a separate package\ncalled 'htmlfilter'. Also removed are a few MORE libs that were too\nexpiremental and/or not robust enough. Effectively this finishes up\nthe \"spring cleaning\" of the MORE lib mentioned a few releases back.\n\nBut it also marks a new start in trimming MORE down further. We have\ndecided to do this for three reasons 1) Some of the MORE libs would\nbe better served as separate projects. 2) Facets will become a tighter\nlibrary, primarily focused on extensions. And 3) all libraries involved\nwill become easier to maintain and thus more robust in the long run.\n\nThis release also fixes an important arity bug with the recently added\nModule#extend method --one of the very few actual core overrides in Facets.\n\nChanges:\n\n* 7 Major Enhancements\n\n    * Removed htmlfilter.rb due to licensing issues.\n    * Also removed cssfilter.rb ('gem install htmlfilter' now)\n    * Removed rwdelegator.rb, simply not a robust solution.\n    * Removed buildable.rb, api is too confusing.\n    * Removed meta.rb which was not very useful and too expiremental anyway.\n    * Removed prototype.rb, which needs it's own project.\n\n* 3 Minor Enhancements\n\n    * Removed Kernel#__HERE__ as it simply cannot work.\n      (Ruby 1.9.2 will offer #source_location for the same, btw)\n    * Returned binding/opvars to core.\n    * Added Integer#length as suggested by Victor H. Goff III.\n\n* 1 Bug Fix\n\n    * Fixed arity issue with Module#extend.\n\n\n== 2.5.2 / 2009-04-07\n\nFacets 2.5.2 is a simple maintentance release which fixed a few issues\nin the new to_hash.rb library. This release also added String#lowercase\nand String#uppercae.\n\nChanges:\n\n* 1 Major Enhancement\n\n    * added string/uppercase and lowercase\n\n* 1 Minor Enhancement\n\n    * adjustments to to_hash.rb\n\n\n== 2.5.1 / 2009-03-05\n\nFacets 2.5.1 fixes a few bugs, makes some small but nice additions\nand improves 1.9 compatibility.\n\nThe most important addition to make note of is Object#extend, which has\nbeen overridden to allow a block parameter. This is one of only two or three\nactual \"monkey patches\" in all of Facets. The block, when provided,\nis used to create an annonymous module which then extends the reciever.\nThis is a \"good practice\" way to extend objects, rather than using class_eval\non the singleton class.\n\nSpecial thanks to Erik Veenstra, Pit Capitan and especially Sandor Szcs\nfor their contributions to this release.\n\nChanges:\n\n* 7 Major Enhancements\n\n    * added Hash#group_by_value (thanks to Erik Veenstra)\n    * added String#file\n    * added Hash#new_with (Pit Capitan)\n    * added module/extend.rb, now can take a block.\n    * added hook.rb\n    * added to_h_auto\n    * overhauled to_hash.rb, now has multiple methods\n\n* 10 Bug Fixes\n\n    * corrected ostruct.rb to test for frozen state on updates\n    * fixed String#left_align\n    * fixed conflict between test_name.rb and test_arguments.rb\n    * fixed Enumreable#split when reciever is empty array\n    * fixed coruption of reciever by Hash#collate (thanks to Tilo Sloboda)\n    * fixed Array#to_h, h={} was not initialized\n    * fixed test of Module#conflict according ruby19\n    * fixed Hash#dearray_singluar_values\n    * association.rb stores reference when using #new\n    * changed Array#product to make it compatible to ruby 19, deleted block parameter\n\n* 5 Minor Enhancements\n\n    * split enumerable/collect into map_with_index and compact_map\n    * improved Array#to_h for 1.9 using flatten(1)\n    * Dictionary#replace can take regular Hash too\n    * move test_to_hash.rb from more to core\n    * Doc'd that UnboundMethod#name returns Symbol in 1.9, but String in 1.8\n\n\n== 2.5.0 / 2008-11-23\n\nFacets 2.5.0 is an important milestone in the development of Facets.\n\nThis release has been tested against Rails' ActiveSupport library.\nAs long as Facets is loaded after ActiveSupport, everything\nshould work fine. Of course, there's no counting for real world\ntrials, but all ActiveSupport testcases pass under this scenario.\n\nSecondly, this release is the first of two (or three) down-scaling\nreleases intended to remove all the remaining \"excess\" from the\nlibrary. This is being done for a variety of reasons. Some scripts\nare substantial enough to be one their own and have been spun-off\ninto separate largely compatible projects. In this release:\n\n  If you were using...   Use this project instead...\n\n    annotations.rb         Anise\n\n    bytes.rb               RichUnits\n    times.rb\n\n    command.rb             Clio\n    consoleutils.rb\n\nA few others scripts have been deprecated, without an alternative\nrecourse, simply because they were too weak, such as  uploadutils.rb,\nor highly experimental, such as chain.rb and eventhook.rb.\n\nAlthough this release constitutes an over all slimming down of Facets,\ntwo excellent new libraries have been added.\n\n1) *ini.rb* by Jeena Paradies. While YAML is frequently used by\nRubyists for configuration files, a full-on serializer like YAML\nis often overkill. INI files provide a lightweight solution\nspecifically geared for configuration.\n\n2) *filter.rb* by Brian Candler offers lazy evaluation chains of\nEnumerable methods. This is an elegant way to optimize contiguous\nmaps, selections, etc. --effective even on infinite enumerators.\n(Note, the name of this library may be changed in the next release.)\n\nWhile work remains to be done, I am happy to say, Facets is\nfinally beginning to approach the level of solidity I set out to\nachieve just over a year ago. Thank the Maker!\n\nSpecial thanks to Brian Candler, Jeena Paradies and Tyler Rick.\n\nChanges:\n\n* 9 Major Changes\n\n    * added Brian Candler's Enumerator::Filter\n    * added sparse_array.rb (was old harray.rb)\n    * added Jeena Paradies' ini.rb\n    * renamed CacheDelegator to Memoizer\n    * renamed DictionaryMatcher to just Matcher\n    * deprecated bytes.rb and times.rb (use RichUnits instead)\n    * deprecated uploadutils.rb; ziputils.rb will be (use Folio)\n    * deprecated annotations.rb (use Anise instead)\n    * deprecated command.rb and consoleutils.rb (use Clio instead)\n\n* 5 Minor Changes\n\n    * deprecated chain.rb (very expiremental)\n    * deprecated eventhook.rb (moved to ToadCode project)\n    * deprecated tagiter.rb (moved to ToadCode project)\n    * moved Hash#symolize_keys and #stringify_keys to core lib\n      (still recommend #rekey instead though)\n    * switched to git as of 2.4.5\n\n* 4 Bug Fixes\n\n    * memoize.rb, cache was at class-level, now at instance-level\n    * binding/caller.rb, fixed require for callstack.rb\n    * fixed missing require in string/tabto.rb\n    * Fixed some bugs with Time#ago/Time#hence not changing years\n      correctly when you changed months.\n      (For example, Time.utc(2008, 1, 1).ago(12, :months) incorrectly\n      returned 2009-01-01 instead of 2007-01-01.)\n      Changed Time#ago/Time#hence to still work if passed negative number.\n\n\n== 2.4.5 / 2008-10-02\n\nFacets 2.4.5 is a maintaince release. This release is notable however in that\nit will likely be the last that to use SVN. Facets will be switching to Git.\nAlso, some libraries that have been flagged \"to be deprecated\" for some time\nwill finally be so.\n\nChanges:\n\n* 8 Major Enhancements\n\n    * Re-added date.rb to lore library, and removed from core.  (#r1014)\n    * Much improved date.rb extension now in Lore library.  (#r1027)\n    * Deprecated kernel/suppress. Use Exception.suppress from now on.  (#r1040)\n    * Deprecated string/style.rb. Use English project instead.  (#r1074)\n    * Console namespace is no longer supported (for Ansicode).  (#r1077)\n    * enumerable/mode.rb, Enumerable#mode returns array since there can be more than one.  (#r1079)\n    * OpenCascade automatically creates nodes, use foo? to query.  (#r1056)\n    * Change #index_of to #index which now takes a block.\n\n* 14 Minor Enhancements\n\n    * OpenStruct.new can now take a default block, like Hash.new.\n    * Moved variablize methods out of metaid.rb and into separate files (string/ and symbol/).  (#r1042)\n    * Added Time#advance.  (#r1046)\n    * Speed up of Integer odd/even methods.  (#r1057)\n    * Array#index now takes a block (this is a core override).  (#r1059)\n    * Spilt file/write.rb into separate method files (append, create, writelines).  (#r1073)\n    * Modified Enumerable#split to behave like String#split.  (#r1076)\n    * hash/op.rb, split into separate method files.  (#r1081)\n    * Added string/modulize. string/methodize handles path names now too.  (#r1085)\n    * Class#cattr is now part of core.  (#r1089)\n    * Modified Enumerable#split to behave like String#split.  [minor]\n    * Removed Rope class. If anything this will have a separate project.\n    * Added doc/news.html and doc/authors.html to website (temporarily?).\n    * Added zlib.rb to Lore library.\n\n* 7 Bug Fixes\n\n    * OpenStruct#to_h dups internal table.  (#r1015)\n    * Fixed require of string/xor in bicrypt.rb.  (#r1039)\n    * integer/odd.rb, fixed Ruby 1.9 condition.  (#r1080)\n    * class/cattr_*.rb fix require bug\n    * opencascade.rb, fixed bug when accessing sub-hash.\n    * typecast.rb, fixed require for string/methodize.\n    * Fixed Pathname#glob to ensure use of ::File.\n\n\n== 2.4.4 / 2008-09-01\n\nFacets 2.4.4 includes a major bug fix that caused Facets not to load properly,\nhaving to do with a Time extension. The problem has been fixed. In addition,\nthis release put Facets only a few pending adjustments away from full\nRails/ActiveSupport compatibility.\n\nChanges:\n\n* 10 Major Enhancements\n\n    * Added string/mask providing powerful string manipulation.  (#997)\n    * BasicObject is now just a synonm for BlankSlate unless Ruby 1.9.  (#1000)\n    * Added Symbol#plain?, Symbol#query? and Symbol#setter?  (#1011)\n    * Removed Time#to_date.\n      * Due to clobberd RI Docs (!) this should have been in Lore lib date.rb\n      * Moved to Lore date.rb. (#1012)\n    * Re-added date.rb to lore library, and removed from core.  (#1014)\n    * Much improved date.rb extension now in Lore library.  (#1027)\n    * Deprecated kernel/suppress. Use Exception.suppress from now on.  (#1040)\n    * Improved date.rb and moved to LORE library, and removed from CORE.  [major]\n    * Deprecated kernel/suppress. Use Exception.suppress from now on.  [major]\n    * Deprecated String#to_time.\n      * This method reqiures the loading of a number of other standard libs.\n      * We can reconsider adding it again if we decide these other libs should be core.\n      * Or if we find a more suitable way to define the method.\n\n* 17 Minor Enhancements\n\n    * Moved style.rb to string/stylize.rb  (#998)\n    * Renamed string/subtract to string/op_sub.\n      Old name will remain for time being for compatability. (#1002)\n    * Module#instance_method_define? now only applies to public methods.  (#1003)\n    * Array#index accepts a block (one of the few core overrides).  (#1004)\n    * Moved Hash#<< from hash/update.rb to hash/op_push.rb  (#1005)\n    * Add facets class files (eg. facets/string) have been made dynamic.  (#1013)\n    * Moved variablize methods out of metaid.rb and into separate files (string/ and symbol/).  (#1042)\n    * Added Time#advance.  (#1046)\n    * Added qua_class.rb. Yea. It really is my favorite.\n    * Added simple functional test that loads all of Facets.\n    * Added a benchmark for measuring how fast Facets loads. (Core < 1sec!)\n    * Made Module#alias_method_chain a public method (for better Rails support).\n    * Wrapped Nilclass#to_f in 1.9 condition.\n    * float/round.rb redirects to numeric/round.rb.\n    * numeric/float.rb holds rounding methods for all classed Numeric, Integer and Float.\n    * Replaced Kernel#instance_exec with Mauricio's version.\n    * Improved String#each_char to work like Ruby 1.9.\n      * This loads strscan.rb.\n      * It is wrapped in a 1.9 condition.\n\n* 8 Bug Fixes\n\n    * Hash#<< now returns self  (#1001)\n    * OpenStruct#to_h dups internal table.  (#1015)\n    * Fixed require of string/xor in bicrypt.rb.  (#1039)\n    * Fixed facets.rb to use relative paths.\n    * Fixed cgi.rb (CGI is a class not a module).\n    * OpenStruct#to_h dups internal table.  [bug]\n    * Fixed require of string/xor in bicrypt.rb.  [bug]\n    * date.rb (stamp) fixed ref to constant FORMAT.\n\n\n== 2.4.3 / 2008-08-14\n\nFacets is almost fully interoperable with ActiveSupport and Ruby 1.9.\nWe will continue to improve this interoperability in upcoming releases.\n\nAs a REMINDER, Facets 2.4+ now encourages:\n\n  require 'facets'\n\nThis is better than cherry-picking methods. It may seem counter-intuitive,\nbut it actually proves more advantages to do this for the sake of\nimproved interoperability. The practice of cherry-picking can become\nproblematic if other dependent libraries have cherry-picked different\nmethods. In those cases these distinctions go unaccounted and untested.\n\nNote that this release does not include a setup.rb script. We are working\non a new version of this script, which we plan to include in the next release.\n\nThis release give special thanks to the following people for their contributions:\nKen Bloom, Nick Caruso, Evgeniy Dolzhenko, Andy Freeman, Tomasz Muras and Dave Myron.\nAnd of course, to anyone else I failed to mention that has contributed.\n\n(NOTE: 2.4.3's changes may actually be long to 2.4.2. Notice the releases are\nonly two days apart. There was an issue with 2.4.2 and it had to be replaced\nimmediately. So take the distinct with a grain of salt.)\n\nChanges:\n\n* Additions\n\n    * Add Time#trunc and Time#round to Core.\n    * Add Array#recursively and fixed bug in Hash#recursively.\n    * Add Kernel#instance method which provides a fluent interface to private object space.\n    * Add Symbol#plain?, Symbol#query? and Symbol#setter?\n    * Add Hash#symbolize_keys and #stringify_keys.\n    * Add File#split_root.\n    * Add #glob and #glob_first as extensions to Pathname.\n    * Add NilClass#ergo whic points back to kernel/ergo.\n    * Add #bump method to VersionNumber class.\n    * Add String#mask providing powerful string manipulation.\n    * Add Ken Bloom's DictionaryMatcher class (will be renamed in future version)\n\n* Deprecations\n\n    * Deprecate Hash#keys_to_s and Hash#keys_to_sym.\n      * These are the original versions of these methods.\n      * But now we can use #rekey(:to_s) and #rekey(:to_sym) instead.\n    * Deprecat ruby.rb, which was a sort 1.9 compatibility layer.\n\n* 22 Major Enhancements\n\n    * Changed File#rewrite to not use the in-place change of the string.\n    * Renamed Class#to_pathname and #to_methodname to #pathize and #methodize.\n    * Removed Console:: namespace for ANSICode.\n    * Moved Mentalguy's lazy.rb to core!\n    * Added Indexable and Stackable to core.\n    * BasicObject is now just a synonm for BlankSlate unless Ruby 1.9.  [major]\n    * Moved Indexable and Stackable to core.\n    * Renamed arguments.rb and CLI::Arguments to argvector.rb and Argvector.\n    * Added optional argument to Dictionary#first and #last.\n    * Moved binding/opvars from core to more.\n\n* 19 Minor Enhancements\n\n    * Improved File#rootname --it is now more robust.\n    * Made FileUtils#whereis a module_function again.\n    * Created Lore library to house extensions to Ruby's standard library.\n    * Re-added facets class files (eg. facets/string) and are now dynamic.\n    * Added block to Array#index.\n      * This is one of the few core overrides in Facets.\n      * It is a feature already in Ruby 1.9.\n    * Added Jim Weirich's BlankSlate class.\n      * This is a temporary measure be compatible w/ AcitveSupport's BasicObject.\n    * Split kernel/load.rb into require_all.rb and require_local.rb.\n    * Split module/alias.rb up into alias_accessor, alias_module_function and alias_method_chain.\n    * Renamed string/subtract to string/op_sub.\n      Old name will remain for time being for compatability. [minor]\n    * Moved style.rb to string/stylize.rb  [minor]\n    * Added warning to bytes to use RichUnits instead.\n    * Updated warn line fore eventual deprecation of fileshell and arguments.*\n    * Added facets-load.rb to allow old school cherry picking.*\n      * Between 2.0 and 2.4 require 'facets' simply added core to LOAD_PATH.\n      * Starting with 2.4 it loads all of core automatically instead.\n      * facets-load.rb provides a way to use the old behavior.\n            require 'facets-load.rb\n            require 'kernel/with'\n            require 'symbol/to_proc'\n      * This adds the path to the end of LOAD_PATH to prevent any load conflicts.\n\n* 5 Bug Fixes\n\n    * Fixed Time#hence changed years when changing months.\n    * Fixed Time#hence to flip year correctly when adding months.\n    * Hash#<< returns self\n    * Fixed String#pathize.\n    * Module#instance_method_defined? now only applies to public methods.\n\n* Administrative Enhancements\n\n    * While not perceptible to an end user, there are now 3 divisions: lib/core, lib/lore, lib/more.\n    * Modified script/test to display $LOAD_PATH before running tests.\n\n== 2.4.2 / 2008-08-12\n\nJust some more of those great old work your ass off changes.\n\nChanges:\n\n* Major Enhancements\n\n    * Added Ken Bloom's DictionaryMatcher class from Ruby Quiz #103.\n      (Note this class will probably be renamed in the future.)\n    * Changed File#rewrite to not use the inplace change of the string.\n      * If you were using the function, change your code to use File#rewrite! instead.\n      * Or, modify your code ot use the new behavior.\n      * This change can make for a slippery bug, so be sure to check for it!\n    * Moved live.rb to facets-live.rb.\n    * Added kernel/instance method which provides a fluent interface to private object space.\n\n* 5 Minor Enhancements\n\n    * Added sow generation forms.\n    * Spilt Time#trunc into separate file.\n    * Remove old log files --shouldn't version control these.\n    * Added note to FileList to add glob options parameter.\n    * Added optional argument to Dictionary#first and #last.\n\n* Other Enhancements\n\n    * Move \"lore\" tests to test/lore (lore are extensions to Ruby's standard lib).\n    * Added test/core, test/lore and test/more.\n    * Added time/test_round.rb\n    * Added array/recursively.\n    * Added time/round.\n    * Time#to_date makes the public (it already existed in Ruby!)\n    * Fixed Time#hence to flip year correctly when adding months.\n    * Work on documentation using new Sow system.\n    * Moved meta.rb to more/kernel/meta.rb and merged facets/core.rb into facets.rb.\n    * Added more/kernel directory --hey not every extension can be core.\n    * Adjusted loadpath and moved lazy.rb to core!\n    * Moved remaing files to subdirectory locations.\n    * Moved most core libs to core/.\n    * Move most more files to the more directory.\n    * Added lore and more directories.\n    * Added facets/core directory. Yes, I'm spiliting the lib again.\n      * Loadpath will be used, so user inteface will stay the same.\n      * Setup.rb will be adjusted to recognaize loadpath.\n    * Removed Rope class. If anything this will have a separate project.\n    * Moved setup.rb to script/setup.\n      * This will either be replaced with configure/install scripts.\n      * Or, depend on a separate ruby setup.rb project.\n    * Added recorder.rb to consider in work directory.\n    * Added admin directory.\n    * Added \"TO BE DEPRECATED\" message to ruby.rb.\n    * Added all methods from ruby.rb as individual core methods.\n      * These are the methods that overlap with 1.9.\n      * They are encased in 'unless RUBY_VERSION' caluses.\n    * Imporved file/rootname --now much more robust.\n    * Added Kernel#to_yamlfrag to yaml.rb as way to output yaml w/o the \"---\" header.\n      * Perhaps not the most robust solution, but okay for now.\n      * Maybe a poor name for the method, but you got a better one?\n    * Made FileUtils#whereis a module_function again like it used to be. Because:\n      (1) that seems to be the way most other FileUtils methods are (cd, mkdir, cp, ...) and the most\n          obvious way that users would WANT to use FileUtils: FileUtils.whereis(\"ruby\").\n      (2) I see module_function used in other comparible parts of Facets: UploadUtils, ConsoleUtils,\n          ZipUtils, FileUtils#safe_ln, ...\n      (3) My code that relied on the old module_function behavior was breaking\n          What were you thinking changing it?? ;)\n\n\n== 2.4.1 / 2008-04-03\n\nThis release takes aim at improving compatability with ActiveSupport.\nIt also reintroduces an improved paramix.rb.\n\nChanges:\n\n* 4 Major Enhancements\n\n    * A much improved paramix.rb has been returned to the library.\n      * There a no longer capitialize module methods at all.\n      * Use Module#[] and mixin_params[] instead.\n    * Deprecated behavior.rb. It was not robust.\n    * Added basex.rb, for working in any encoding base using any character set (base62 is the default).\n\n* 3 Minor Enhancements\n\n    * Comparing to ActiveSupport, found 63 extension clashes, but most are due to 1.9 features.\n      The rest should be compatible.\n    * Reatomized a number of Kernel and String methods. Reatomization is nearly complete.\n    * Continued work on reatomizing core extensions (nearly complete now).\n\n\n== 2.4.0 / 2008-03-24\n\nFacets 2.4 is a major step forward for Facets. It is perhaps the release\nthat 2.0 should have been, but of course it took the actual 2.0 release\nto make 2.4 possible. Some annoyances you may have encountered in updating\nyour code to 2.0 are now fixed. And from 2.4 on, Facets will now be\nsettling down into simple refinement release cycles for a while.\n\nThe main change under the hood is to bring everything up to the top\nlib/facets/ directory. No longer are the libraries sorted by category.\nI had done so for a long time to make it easier to track the various libs,\nbut in the end it was only making it more diffcult to deal with build tools\nand packaging.\n\nFor the end-user, the largest change is a new emphisis on:\n\n  require 'facets'\n\nThis is better than cherry-picking methods. It may seem counter-\nintuitive, but it actually proves more advantantages to do this\nfor the sake of interoperability than the practice of cherry-picking.\nThe reason is simply because others may have cherry-picked different\nmethods, and those distinctions go unaccounted and untested.\n\nAlso with this release, to bolster the use of require 'facets',\nsome lack-luster extensions have been deprecated and namespace usage\nhas been improved. In addition, we are getting very close to full\nActiveSupport, and Ruby 1.9, interoperability. Expect this\nto be complete in the next minor release or two.\n\nChanges:\n\n* Enhancements\n\n    * String#to_re and String#to_rx have swapped default behaviors. #to_rx escapes, #to_re does not.\n    * The Console namespace is being deprecated. command.rb and arguments.rb now use CLI naemspace.\n    * #compare_on and #equate_on are now \"mixin methods\" Comparable() and Equateable().\n    * Enumerable#product, #combintations and #permutations have change to be Ruby 1.9 compatible.\n    * thread.rb, map_send, et al, block is passed to send instead of yielding on result.\n    * namespace.rb has been renamed to methodspace.rb.\n    * Ruby 1.9 defined a new Proc#curry method, so Facets version has been made compatible.\n    * The old curry method is now called #partial, as in \"partial application\".\n    * Deprecated interface.rb. Perhaps a better approach but nonetheless extraneous.\n    * Deprecated paramix.rb. A better way is to use a capitialized methods. (Perhaps a lib for that?)\n    * Brought back a few web related libs, htmlfilter.rb and cssfilter.rb in particular.\n    * camelcase and snakecase are core extensions. For specialized styles use String#style in style.rb.\n    * Renamed ArgVector to CLI::Arguments\n    * Moved one_nine.rb to ruby.rb\n    * Moved test/test_one_nine.rb to test/test_ruby.rb.\n    * Updated requires for \"one_nine\" to just \"ruby\" b/c of backports to 1.8.7.\n    * Added warning to Rick Kilmers's unit system.\n        * Moving Rich Kilmers's units system to it's own package.\n        * Three are alternate unit systems available and Facets should work with any of them.\n        * Will keep a fair amount of the Time extensions though.\n    * Moved nil/status.rb to nilstatus.rb\n    * Got rid of Method#curry and Method#partial since they just convert to Procs.\n    * Made op_esc.rb a separate module rather thanan extension.\n    * Deprecated with_reader, with_writer and with_accessor for attr_singleton_reader, &c.\n    * Deprecated Hash#pairs_at. Use Hash#slice instead from core.\n    * Fixed the namespaces of some extensions.\n    * Added prime directory and files.\n    * Removed all \"prime\" extension files.\n    * Move mattr to module.\n    * Fixed require bug in time methods.\n    * Reverted memomize.rb back to original code --will come back to later.\n    * Added stylizer.rb to replace stylize.rb\n    * Array #recursively is not only called #traverse.\n    * Added case/stylize methods to more/facets/string.\n    * Renamed more/string/facets/titlecase to captialize_all.\n    * Added uri and xoxo tests.\n    * Progressive work on memoize and elementor.\n    * Functor no longer privatizes =, == and =~.\n    * Properly split conversion.rb.\n    * Some string methods extracted from stylize.rb.\n    * Moved random.rb to more/.\n    * Renamed namespace.eb to methodspace.rb.\n    * Moved autoreload to more/facets/kernel.\n    * Removed old curry.rb.\n    * Added cgi.rb with some standard extensions.\n    * Deprecated paramix.rb.\n    * Added xmlhash.rb and returned uri.rb extensions to the library.\n    * Added #method_name to Date class.\n    * Remove cut-bases AOP, now in it's own library.\n    * Converted compare_on.rb to Paramtric Mixins.\n    * Split fileutils up into individual methods.\n    * Renamed console.rb to what it should be consoleutils.rb.\n    * Update to command.rb integrating MasterCommand and Command into a single class.\n    * Added options back into multiglob_r.\n    * Improved cloneable.rb to be a true deep dup/clone mixin using Ken Bloom's suggestion.\n    * Added tasksystem.rb.\n    * Added enumerable/combinations.\n    * Added openhash and tracepoint.\n\n* Bug Fixes\n\n    * Fixed bug with #peek in stackable.\n    * Fixed bug in Kernel#object_hexid.\n    * Fixed bug in multiglob_r so it will NOT follow symlinks.\n    * Fixed test_keyize.rb.\n\n* Adminstrative Changes\n\n    * This was a fairly large and fast-paced update, so unfortunately not all changes are listed this time.\n    * Added ri generation to setup.rb.\n    * Updated README and allowed doc/ to be included in package.\n    * Finally completed removal of all embedded tests.\n    * Organized all libs between core, more, class and mixin.\n\n\n== 2.3.0 / 2008-02-01\n\nAmoung other changes with this release, cloneable.rb is now a true deep\ndup/clone mixin; tracepoint.rb returns to the library.\n\nChanges:\n\n* 4 Major Enhancements\n\n    * Cloneable provides true deep cloning.\n    * Moved hash_keyize.rb to CORE as hash/keyize.rb.\n    * Added tracepoint.rb back to the library.\n    * Added hash/collate.\n\n* 3 Bug Fixes\n\n    * Fixed multiglob_r bug, so it will NOT follow symlinks.\n    * Added a couple of missing binding requires.\n    * Fixed test_keyize.rb.\n\n* 6 Admistrative Changes\n\n    * Reorganized library into smaller groups: core, more, class and mixin.\n    * Remove admin/svn subdir.\n    * Remove admin/log.\n    * Add admin tasks.\n    * Moved admin tasks to admin directory.\n    * Added admin directory.\n\n\n\n== 2.2.1 / 2007-12-22\n\nThis release get rid of the underlying methods subdir.\nAll method redirects are now in core, to ensure there\nare no more name clashes.\n\nChanges:\n\n* Method Renames\n\n  * Moved string/format.rb to string/wrap.rb.\n  * Updated String#brief.\n  * Moved binding/cflow.rb to caller.rb.\n  * Moved core hash/keyize to more.\n\n* Other Enhancements\n\n  * Fixed up binding extensions.\n\n* Administrative Adjustments\n\n  * Got rid of methods subdir. All method redirects are in core/.\n  * Moved doc/wiki to apiwiki b/c of Rubyforge's wiki.\n  * Removed doc/api dir.\n  * Added wiki.\n  * Renamed a couple test tasks.\n  * Update per-module/class files.\n  * Moved methods and groups task to trash.\n  * Added test class/remove_descendents.rb.\n  * Added all remaining per-method require libs from methods/ (will need to wrok through these over time).\n  * Added trash work directory.\n  * Adjust text according to per-method file changes.\n  * All hash method, but the conversion methods, are now represented in core/facets/hash.\n  * Added a few more Hash per-method files.\n  * Add per-method libs for hash.\n  * Updated facets/string.rb.\n  * Renamed ROLLRC to facets.roll.\n\n\n== 2.2.0 / 2007-12-13\n\nThis release provides improved rdocs and prepares facets for use with Ruby 1.9.\nIt also adds Matthew Harris' duration.rb library. Bug thanks to Matthew!\n\nChanges:\n\n* Additions\n\n    * Added Matthew Harris' Duration class.\n    * Added Hash#slice and Hash#except (didn't we have this before?)\n    * Added registerable.rb, updated history.\n    * Added #include_as to facets/namespace.rb.\n    * Added op.rb to string.rb.\n    * Added String/op.rb with String#- method.\n\n* Method Renames and Reorganizations\n\n    * The name Array#unzip didn't makes sense, it was renamed to #modulate (though #collate seems better?)\n    * Renamed Enumerable#collate to #mash (Map hASH); #collate and #graph remain aliases for the time being.\n    * Renamed accessor #attributes to #instance_attributes.\n    * Renamed Enumerable #collate to #mash. (old name, along with graph, will be an alias for time being)\n    * Divided enumerable/collect into split.rb and each.rb as well.\n    * Moved mapsend.rb to thread.rb.\n    * Updated mapsend.rb to focus on threads.\n    * Moved continuation extensions to more lib.\n\n* Deprecations\n\n    * Deprecated Module#include_and_extend. Just use both silly.\n    * More lib pp_s.rb has been removed. Use #pretty_inspect instead.\n    * Removed continuation from core.\n    * Removed pp_s.rb (use pretty_inspect) add continuation.rb.\n    * Remove kernel/require_esc.rb.\n\n* Other Enhancements\n\n    * integer/bitmask.rb has changed a bit --pun intended ;) Deprecated some methods and now use \"~\" instead of \"-\" to clear bits.\n    * Split binding extensions up a bit more finely --eval.rb sprouted here.rb, self.rb and defined.rb.\n    * Move Time#stamp out of conversion.rb and into time/ dir, and remove to_s alias.\n    * Preliminary addition of Matthew Harris' excellent duration.rb lib (will integrate with times.rb better in future).\n    * Minor edit to basicobject.rb in light of 1.9.\n    * Minor adjustments to lazy.rb to fix warnings by Ruby 1.9.\n    * Added if clauses to handle upcoming Ruby 1.9 gracefully. Facets should now be just about ready for use with 1.9.\n\n* Documentation Enhancements\n\n    * A lot of rdoc updates to core extensions --as promised ;)\n    * Just about every method now has at least a brief explinaiton and an example.\n\n* Administrative Adjustments\n\n    * Moved task/config.yaml to meta/ per new Ratch.\n    * Moved task/special to task/doc.\n    * Updated todo list (in dev/).\n    * Copied log/history.rd to CHANGES.\n    * Removed log/history.rd and log/todo.rd\n    * Fixed stylize.rb for use with 1.9 (fixed case statement).\n    * Separated kernel/returning, now that #tap will be in 1.9.\n    * Updated facets.rb for use with 1.9.\n    * Separated time/stamp.rb.\n    * Divided binding up into a few more pieces.\n    * Fixed kernel/instance to play nice with 1.9.\n    * Added test for string/op.rb.\n    * Added test_collect.rb split-offs and test_mash inplace of test_collate.\n    * Cleanup test headers.\n    * Added 1.9 check in continuation/create.rb.\n    * Add a couple new task for rdoc gen.\n    * Added nbsp to quickopts task.\n    * Work on website using siteparts.\n\n\n== 2.1.3 / 2007-11-28\n\nThis release fixes four bugs --one being fairly serious, as it prevented\nrequire 'facets' from working at all.\n\nChanges:\n\n* 4 Bug Fixes\n\n    * Fixed oddity in Enumerable/collate.\n    * Fixed issue that prevented loading of facets.rb.\n    * Array#to_h used flatten, but it needed to be flatten(1).\n    * Move core/main.rb back to core/facets.rb as it conflicts with lib in more/.\n\n\n== 2.1.2 / 2007-11-22\n\nChanges:\n\n* Additions\n\n    * Added Exception#details.\n\n* General Enhancements\n\n    * Dir::multiglob no longer handels -/+ modifiers. Use FileList instead.\n\n* Administrative Adjustments\n\n    * Fixed task/install script.\n    * Improved task/changes.\n\n\n== 2.1.1 / 2007-11-16\n\nChanges:\n\n* Additions\n\n    * Added kernel/ergo.rb.\n    * Added pp_s.rb (Questionable addition, but we'll leave it for now.)\n    * Added validation.rb. This is here for Nitro's sake --better techinques may replace it in the future.\n    * Added Console::Logger to logger.rb (may be separated in future).\n    * Added option arity to command.rb.\n\n* Deprecations\n\n    * Removed tracepoint.rb.\n\n* Bug Fixes\n\n    * Fixed bug in command.rb that clobbered options.\n    * Fixed options bug in command.rb.\n\n\n== 2.1.0 / 2007-11-10\n\nMajor changes include a new and much-improved command.rb, a new BiCrypt\nclass for simple two-way crypotgraphy, as well as attr_reader!, \nattr_writer! and attr_accessor! for flag attributes, plus \nalias_xxx methods for all attr_xxx methods.\n\n\nChanges:\n\n* Additions\n\n    * Added BiCrypt class for simple two-way encryption.\n    * module/attr.rb now has attr_reader!, attr_writer! and attr_accessor!\n    * All attr_xxx methods have coresponding alias_xxx methods.\n    * Added UniversalOptions module.\n    * Added \"tester\" attribues attr_xxx!. Also added alias_xxx for all attr_xxx methods.\n\n* Enhancements\n\n    * command.rb has been completely rewritten. The API has changed completely!\n    * There is no longer a Commmand::Optoins class. Use Console::Arguments instead.\n    * Moved common alias methods from attr.rb to alias.rb.\n    * MasterCommand now passes (args, opts), until 1.9 is main stream.\n    * Cleaned up enumerable/permutation.rb\n    * Added -q option to zip method in ZipUtils.\n    * Ok. #p is back. This will in fact be in 1.9, so we're good.\n\n* Bug Fixes\n\n    * Fixed bug in Enumerable#cluster_by which returned nil instead of [].\n    * Fixed minor bug in arguments.rb that prevented proper repeat parameters.\n    * Fixed bug in to_console.\n    * Fixed bug in enumerable/cluster_by (returned nil instead of []).\n    * Fixed bug in Hash#- Thanks to Xavier Shay.\n    * Fixed to_h in Command::Options\n\n* Admin Changes\n\n    * Added dev/test\n    * Renamed RELEASE to WHATSNEW\n    * Added injecting test and cleaned up.\n    * Added comment for potential future #is.\n    * Added top-level log directory.\n    * Remove #q reference from RELEASE.\n    * Cleanup of test_initializer.rb.\n\n\n== 2.0.5 / 2007-11-07\n\nMinor release that fixes a couple of bugs and adds the last of\nadopted methods from Gavin Sinclair's Extensions project.\n\nAlso, renamed #p to #q, because of multiple args problem. \nI don't know how Ruby 1.9 plans to handle multiple args.\nWill deprecate for 1.9 anyway so doesn't matter much.\n\nChanges:\n\n* Additions\n\n    * Added final methods Gavin Sinclair's Extensions project. (Noah Gibbs)\n\n* General Improvements\n\n    * Made #alias_method_chain compatible with current ActiveSupport version.\n    * Rename #p to #q, because of multiple args problem.\n    * Allow Class#initializer to return the attribute names.\n\n* Bug Fixes\n\n    * Fixe return bug in hash/op.rb.\n    * Fixe bug with Dictionary#initialize.\n    * Fixe bug with Hash#-. (Xavier Shay)\n\n* Admin Adjustments\n\n    * Fixed package name in icli.yaml.\n    * Added name field to meta/icli.yaml.\n    * Added meta/icli.yaml.\n    * Added a RELEASE file to hold current release notes.\n    * Added log task.\n    * Added changelog file in doc/log/.\n\n\n== 2.0.4 / 2007-11-04\n\nChanges:\n\n* Unsorted Changes\n\n    * Up'd version to 2.0.4.\n    * Update task/groups.\n    * Removed extest task. We will no longer need it.\n    * Minor update to rdoc.yaml.\n    * Renamed old changelogs.\n\n\n== 2.0.3 / 2007-11-02\n\nChanges:\n\n* Unsorted Changes\n\n    * Touch up to methods task.\n    * Update rsync filter\n    * Minor updates fixing issues highlighted by running crosstest.\n    * Many minor bug fixes after running against crosstest.\n    * Added usage support for __foo options.\n    * Fixed a many a test after running against crosstest.\n    * Removed load task. It did not isolate the libs, so wasn't effective.\n    * Added a number of new tasks.\n    * Rename SMTP_TLS to Smtp_tls for Rdocs.\n    * Moved rdoc.yaml to config/.\n    * moved task/config to task/config/general.\n    * Update tasks.\n\n\n2007-11-01  transami\n\nChanges:\n\n* Unsorted Changes\n\n    * Added array/only,  symbol/to_proc (where did it go?) and hash/select.\n\n    * Update roll file.\n    * Moved test_command_options to test_command.\n    * Update dictionary test to check dup and autohash.\n    * Fixed autohash and dup bugs.\n    * Verbatim support for Rails' version of #alias_method_chain.\n    * Remove site/ directory.\n    * Moved rsync filter up too.\n    * Moved doc/site/ up to doc/.\n    * Added javascript directory to doc/.\n\n    * Updates across the board.\n    * Updates to stylize and command.rb.\n    * Made facets.rb a shortcut to facets/facets.rb (this is for Rolls, better way?)\n    * Oh smack. Lots of stuff fixed.\n\n    * Remove version.txt. No longer needed.\n    * Removed meta/project.yaml, replaced by facets roll file.\n\n    * Modifications to command.rb, snapshot and rbsystem.\n        * Merged command.rb and command_options.rb into command.rb.\n        * Added to_data aliases to snapshot.rb\n        * Minor additions to rbsystem. Rather than System, maybe Ruby?\n\n    * Removed embedded test from overload.rb.\n    * Allow OpenStruct#initialize to take a setter block.\n    * Downloader needs 'wb' flag rather then just 'w'.\n    * Fixed typo and removed embedded test.\n    * Fixed bug in command_options.rb, putting the class back in the Console namespace.\n\n    * improved module/traits.rb\n\n\n== 2.0.2 / 2007-10-08\n\nChanges:\n\n* Administrative Changes\n\n    * Cleaned up some test and updated version to 2.0.2\n    * Update methods to eleminate duplicate file names between lib/core and lib/methods\n\n\n== 2.0.1 / 2007-10-06\n\nChanges:\n\n* Unsorted Changes\n\n    * updated version to 2.0.1\n    * minor bugs fixes\n    * update methods task to display each file as it process it\n    * added benchmarks for some enumerable methods.\n    * moved demo/bench/bench_factorial to an demo/bench/integer subclass\n    * added Erik Veenstra to AUTHORS for work on enumerable/group_by and cluster_by\n    * minor improvement to test task to specifically read test_*.rb files\n    * removed enumerable/partition.rb\n    * move enumerable/partition.rb methods to collect.rb.\n    * Improved Integer#of.\n    * Minor improvements to collect.rb and partition.rb\n    * Deprecated nonuniq!, bug fixed cluster_by and aliased group_by and partition_by.\n    * Renamed Enumerable#partition_by to group_by (like Ruby 1.9) and fixed bug in cluster_by.\n\n\n== 2.0.0 / 2007-10-02\n\nChanges:\n\n* General Enhancements\n\n    * Added Oliver Renaud to the AUTHORS list (oops!)\n\n* Bug Fixes\n\n    * Fix requires in `cut.rb` and `attributes.rb`.\n    * Fix `String#brief` in `format.rb`.\n\n* Unsorted Changes\n\n    * removed 1stClassMethod from \"more\" docs\n    * removed 1stClassMethod as a rdoc target (now in Core target)\n    * update install and rdoc tasks\n    * moved string/test_index.rb to string/test_nchar.rb\n    * updated indexable tests\n    * update string.rb to include string/nchar.rb\n    * moved index.rb to nchar.rb\n    * clean up string/index.rb\n    * moved facets.rb to fore directory\n    * add comment to groups task\n    * added groups task\n    * updated all extrension group files (array.rb, binding.rb, etc.)\n    * uncapitalize meta files\n    * update methods task a bit more, plus related configuration\n    * updated methods task\n    * removed lib/core --this is generated content (may be renamed too)\n    * added load and stats tasks\n    * update install task --this replaces setup b/c of Facets' special install needs\n    * update project file\n    * removed lib/facets\n    * moved remaining libs to fore (will later consider an additional subdivision)\n    * move facets/fore to fore/facets\n    * move facets/more to more/facets\n    * added ;ob/core, more and fore\n    * move memorize\n    * removed io and net directories\n    * moved io/redirect.rb to more/ioredirect.rb and net/smtp_tls.rb and net/uploadutils.rb libs to more too.\n    * few more libs moved to more/ directory\n    * moved all the most obvious more libs to the more directory\n    * moved fore \"grouping\" libs to fore directory\n    * moved \"fore\" libs to fore directory\n    * create for and more directories (yes, you know what's coming ;)\n    * renamed remain.rb (was main_as_module.rb) to just main.rb\n    * improved rdoc task and project.yaml file\n    * better docs for OpenObject\n    * improved method hiding\n    * documentation touch ups\n    * fixes for conversion.rb rather than conversions.rb\n    * updated to website docs\n    * moved demos to demo/sample\n    * added bench and sample dir to demo\n    * moved spy.html to light.html\n    * menum change to webpage, fixed core doc link\n    * moved metadata files to meta/ (info/ or box/ would be better?)\n    * updated test_conversion.rb for to_h/to_hash\n    * reverse_each instead of each for after advice in advice.rb\n    * final fix to to_h/to_hash discrepency\n    * added a Path and Root features to Pathname (good idea?)\n    * update advice.rb test and moved old cut test to dev/scrap\n    * updated advice; removed preinitialize.rb to trinkets project (it was too expiremental)\n    * command_filter.rb needs to considered/developed; moved to dev/new/\n    * fixed interface.rb fo singelton methods\n    * updates to tests\n    * whole lot of small bug fixes\n    * add tests to revision control\n    * removed old cut test (moved to dev/scrap)\n    * working on tests\n    * added read.rb (taken from readwrite.rb)\n    * split readwrite.rb into read.rb and write.rb\n    * remove string/unpack.rb, offset can be had using '@' format instead\n    * renamed conversions.rb to conversion.rb, fixed some requires\n    * improved attr.rb\n    * some cleanup of enumerable extensions\n    * setup annotations demo\n    * add non-embedded tests\n    * finally brough over toadcode prototype.rb and cleaned it up enough to be useful\n    * removed annotations subdir\n    * moved annotations/ann.rb and attr.rb to annotations.rb and attributes.rb\n    * remove annotations.rb\n    * moved annotations/settings.rb up a dir\n    * remove settings.rb\n    * chnaged multiton_id(e) to multiton_id(*e,&b)\n    * updated test task\n    * added Christoph Rippel to authors lists\n    * added doc header to new multiton class\n    * update to new version of multiton\n    * playing around with multiton2.rb\n    * renamed dev/try to dev/new\n    * created dev/old to temporarily house old versions of libs that have been replaced.\n    * fixed quick.html documentation\n    * used old wiki.gif as email.gif instead\n    * fixed config.yaml publish entry\n    * some minor updates to index.html\n    * moved site to doc/site\n    * update to publish task\n    * updates of tasks\n    * added kernel/report.rb to hold debug/warn extensions.\n    * renamed reporting.rb to silence.rb\n    * update reporting.rb (created report.rb from it)\n    * task work\n    * clean up dev finis\n    * cleanup dev just a bit more\n    * continue cleanup of dev directory\n    * moved dev/twiki to misc/\n    * removed dev/core\n    * moved require_directory.rb to misc/\n    * added dev/misc for code scraps that might be useful but are not straight lib or task code\n    * more dev changes\n    * organize dev better\n    * cleanup of dev continues\n    * cleanup of dev dir\n    * clean up dev dir more\n    * some cleanup of dev directory\n    * almost completed advice lib\n    * added comment about possible update\n    * deprecate instance_send and instance_map\n    * work on rdoc task\n    * work on rdoc task\n    * added dev/cut dir\n    * no reason to track .config\n    * clean up trunk\n    * added todo comment\n    * added advice.rb to replace old aspects.rb\n    * removed aspects.rb (sucked), added prototype.rb (infancy) and adjusted to class_extension.rb\n    * removed #to_roman (now part of the English project)\n    * cont. work on aop and cuts\n    * fixed IMG tag bug\n    * added yaml.rb\n    * move #here convenience method to binding/eval (separate?)\n    * added in order to remove kernel/misc.rb\n    * consolidate string/regesc\n    * added module/methods\n    * updates to include and attr\n    * fixed Range#umbrella\n    * more organization of docs\n    * orginizing docs\n    * update val.rb\n    * added proc/fn.rb (from kernel/misc.rb) and fixed typo in compose.rb\n    * moved misc.rb to val.rb\n    * better organization of some kernel methods\n    * moved #here alias to eval.rb\n    * minor updates and some bug fixes (modspace what broke)\n    * removed file/yaml.rb in favor or just yaml.rb\n    * moved this to facets/yaml.rb\n    * work on aop system\n    * Added aop.rb, and cut.r and recursive.rb\n    * moved cut.rb to dev (old version will be deprecated)\n    * added to_hash to Dictionary, and minor mods to others\n    * oops, no need for enumerator directory\n    * moved threaded_send.rb to mapsend.rb\n    * moved threaded_send out of enumerable/ dir\n    * updates to elementor.rb\n    * merged instance_map into threaded_send\n    * removed map_send\n    * merging map_send with threaded_send\n    * cont work on elementwise methods\n    * divide elementwise functions betwee two libs\n    * uniq.rb is merged into count.rb\n    * removed count.rb (uniq.rb will become count.rb)\n    * continued refinement of enumerable extensions\n    * general improvements to the organization of enumerable extensions\n    * removed facets/cli dir\n    * moved all cli libs from facets/cli to facets/\n    * moved cli support files to facets locations\n    * moved cli lib to facets main (also modified functor)\n    * renamed hash/reverse to hash/merge (it contains #reverse_merge)\n    * remove instance_intercept (moced to Trinkets project)\n    * continued modification of those tasky tools\n    * removed lib/more (this is it!)\n    * moved M-Z of more/facets to facets (this is it!)\n    * moved A-L of more/facets to facets (this is it!)\n    * removed lib/core (this is it!)\n    * moved lib/core/facets.rb to lib/facets.rb (this is it!)\n    * moved lib/core/facets to lib/facets (this is it!)\n    * added file/yaml.rb\n    * added a list of libraries considered \"core\"\n    * continued work on build tools\n    * change tools for core/more convergence (so help us god!)\n    * added conversion requirement to some core libs\n    * update methods task\n    * update quick.html to mirror rdoc changes --still needs work though\n    * remove old rdoc task\n    * added rdoc section (minimal) to tool/config.yaml\n    * nope. remove site/rdoc\n    * add rdoc dir, should we?\n    * remove site/rdoc in preperation for new way\n    * facets.rb belongs to core/\n    * renamed some doc files\n    * removed src/core\n    * move src/core/lin to lib/core\n    * added kernel/constant\n    * remove src/core/web\n    * moving more of core to top-level (svn sucks!)\n    * moving core support files to top-level\n    * removed src/more\n    * move src/more/lib to lib/more\n    * made lib dir (to replace src)\n    * added settings.rb which points to annotations/settings.rb\n    * moved svn to annotations/ subdir\n    * moved dev files to top-level as part of more transition\n    * temporarily removed dev/more\n    * moved annotations demo to demo dir\n    * added demo folder\n    * add dev/more\n    * remove struct again! (stupid svn)\n    * moved file to top-level doc as part of more transisiton\n    * bullshit svn crap\n    * ann moved back to more (strongly considering annotations for it's own project)\n    * build moved back to more\n    * aop moved back to more\n    * cast moved back to more\n    * crypt moved back to more\n    * exts moved back to more\n    * file moved back to more\n    * meta moved back to more\n    * misc moved back to more\n    * model moved back to more\n    * struct moved to back to more\n    * moved sync back to more\n    * moved commandoptions.rb to command_options.rb\n    * rewrote command and command options libs\n    * initial Subversion import\n\n\n== 1.8.54 / 2007-03-21\n\nThe following list of changes also includes changes from intrim releases,\n`1.8.51 / 2007-02-19`, `1.8.49 / 2007-02-16`, `1.8.20 / 2007-02-06` and\n`1.8.8  / 2007-01-31`. Unfortuantely the transition form darcs to git, \nled to some information loss in this regard.\n\nChanges:\n\n* Unsorted Changes:\n\n    * added reqiure to ostruct.rb test\n    * fix to command.rb's initializer\n    * fixed bug with times.rb beginning_of_year and beginning_of_month\n    * replaced pqueue and heap with new working class (thanks to Olivier Renaud)\n    * fixed bug in ormsupport.rb (this will be moved out of facets in next release)\n    * added empty? to dictionary (removed old subclass of Hash)\n    * significant improvements to command.rb thanks to Tyler Rick\n    * added tests to elementwise and tap\n    * fixed test for elementwise and op_tilde_self\n    * added enumerable/map_send\n    * added thread_map and thread_map_send thanks to greg\n    * added operator \"~@\" for enumerable/elementwise\n    * added more/consoleutils.rb\n    * added string/cleave\n    * added capitalize_all thanks to Richard Laugesen\n    * cartesian_product is an alias of enumerable/cart\n    * added array pad thanks to Richard Laugesen\n    * added kernel/tap\n    * fixed test/unit load issues\n    * converted facet/ requires to facets/core or facets/more as needed\n    * further improvements to arguments.rb (looking good!)\n    * improved symbol/self/generate\n    * bug fix kernel/autoreload arguments needed to be in opposite order\n    * add to_xoxo\n    * removed bad character codes in multiplier.rb\n    * used yaml to allow json.rb to work for all object in general\n    * improvements to functor (note: is to_a and to_proc okay?)\n    * add test to string/bytes.rb\n    * bug fix to nilclass/op_cmp\n    * fixed enumerable/op_pow to use enumerable/cart\n    * added array/op_div\n    * adjustments to xmlbuilder and htmlbuilder dur to buildingblock changes\n    * improved buildingblock.rb\n    * simplified interface of arguments.rb (still a little more to do)\n    * improvements/simplifications to Dir.multiglob\n    * added new authors to list\n    * fixed misspelling of behavior.rb (was bahvior.rb)\n    * removed #own from base list in facets.rb (really need a standard for \"singleton class\")\n    * minor adjustments to uploadutils\n    * fixed bug in aspects.rb that would not handle args of wrapped method\n    * Symbol#to_s optimization, had to remove freeze\n    * updates to fileutils/stage (stage worth keeping?)\n    * update to credits\n    * fix bug in kernel/ask, returns more than one character\n    * cleanup of enumerbale/graph (no effective change)\n    * new super fast enumerable/cart by Thomas Hafner (replaces #cross)\n    * improved multiglob rountines (accept '+' and '-' prefixes)\n    * No longer will track project file via scm until it settles\n    * fixed bug in attr_tester, thanks Dov!\n    * added weekdays to times.rb thanks to Ryan Platte and Dave Hoover\n    * improvements to dictionary.rb (no longer a subclass of Hash) thanks Jan!\n    * re-replace openhash with openobject\n    * improvements to ann.rb and ann_attr.rb. works, yea!\n    * fixed bug in string/singular.rb\n    * changed enumerable/cross into enumerable/cart and cartesian_product\n    * openobject returns (openhash was a bad name, thanks george)\n    * moved enumerable/cross to enumerable/cart (cartesian_product)\n\n\n== 1.8.0 / 2007-01-24\n\nThe list of changes also includes intrim releases `1.7.46 September 8, 2006`,\n`1.7.38 August 31, 2006`, and `1.7.30 August 23, 2006`.\n\nChanges:\n\n* Additions\n\n    * Add facets/automatic.rb, very cool, albiet experimental, way to load core methods automatically!\n    * added hash/insert; like store but only if key isn't already present\n    * added module/include_and_extend\n    * added File::mulitglob_sum; accumulates file patterns, and accepts '+' and '-' prefixes\n    * added module/module_method; like module_function but makes method public\n    * added module/include_function_module; attempts to properly include one function_module into another\n    * kernel/yaml convenience method for YAML::load\n    * added kernel/supress; supress errors while executing a block (nice DHH!)\n    * added symbol/chomp, like string#chomp\n    * added proc/to_h; converts an assignment proc into a hash\n    * proc/bind; bind a proc to an object, returning a method\n    * added module/prepend; provides dyanamic method wraps for modules, and static wraps for classes\n    * added module/new; use a module as if it were a class\n    * added module/alias_accessor\n    * kernel/instance_class; yet anouther meta_class name, but a more sensicle name this one\n    * added kernel/populate; populates an object's inst. vars from a hash or assingment block\n    * added kernel/daemonize; one last thanks to DHH!\n    * added enumerable/injecting; like inject but automatically returns the memo from the block\n    * added kernel/object_send, a true public-only send method\n    * added kernel/silence_stream; output to null device; thanks DHH!\n    * added kernel/instance_values, thanks DHH!\n    * added Config:inspect for rbconfig\n    * added hash/pairs_at (aking to values_at)\n    * added _why's metaid methods (meta_class, meta_eval, etc.)\n    * added kernel/enable_warnings to complement silence_warinings\n    * added integer/to_roman\n    * added logical operators for hash (and/or)\n    * array/to_path convert ans array to a path string\n    * array/index takes a block\n    * added fileutils/compress; very simple convenience methods for archiving folders\n    * added fileutils/stage adn staged, a means of transfering files accoring to preset rules\n    * added kernel/ask, simply command to get console input\n    * added populate.rb, mixin for classes that need on a basic initializer\n    * added version_number.rb (a specialized tuple)\n    * added uploadutils.rb\n    * added Joel VanderWerf's great script.rb script\n    * added Austin's minitar.rb --it's just too damn useful!\n    * added htmlfilter.rb very nice html escape class\n    * added dependency.rb, allwos method to have dependend execution (like rake tasks)\n    * added arguments.rb this is for parsing console command arguments\n    * add new version of annotations: ann.rb and ann_attr.rb\n    * added File::yaml? to roughly detect if a file is a yaml file\n\n* Renamed Features\n\n    * Rename #superior to #super_at.\n    * OpenObject = OpenHash (OpenObject will eventually be deprecated)\n    * renamed quaclass to qua_class\n    * renamed openobject to openhash !!!\n\n* Deprecations\n\n    * had to remove taskable.rb for now (implementation won't work as toplevel include)\n    * deprecated (yored) kernel/own, yet another term for the singleton class\n    * removed dataobject.rb (was never used)\n    * deprecated (yored!) module/inject; what a silly method\n    * deprecated kernel/require_facet (no longer needed)\n\n* Bug Fixes\n\n    * Fix enumerable/partition_by.\n    * memoize should now work at toplevel\n    * minor bug fix to httpaccess\n\n* General Enhancments\n\n    * Add buildingblock.rb, replacing builderobject.rb.\n    * HtmlBuilder and XMLBuilder aer now based on BuildingBlock\n    * adjust require for \"yored\" files\n    * minor improvements to basic object (object_self to access kernel methods)\n    * ostuct adjustment, use #instance_delegate to get underneth the open access\n    * module/include_as is now based on module/namespace (thanks Pit!)\n    * minor adjustments to methods for (class<<self;self;end)\n    * facets.rb now references facets/sys.rb\n    * adjust old annotation.rb (now in yore) to use openhash\n\n* Admin Adjustments\n\n    * further updates to project info file (need to stop versioning this)\n    * deprecated (yored) builderobject.rb (poor implementation)\n    * moved deprecated #facet_require to yore lib\n    * minor doc change to instance_intercept.rb\n    * doc change to methodfilter.rb (maybe deprecat in future)\n    * moved old module/namespace implementation to yore\n\n* Unsorted Changes\n\n    * moved plugin.rb to ratchets/library project\n    * proper credit for multiton goes to Ara T. Howard!!!! Also improvements.\n    * remove library.rb (move to ratchets/library project)\n    * updated autovivify.rb to use openhash\n    * improvement to command.rb\n    * imporved time/stamp\n    * reimplemented proc/to_method for more sensible behavior\n    * reimplemented module/namespace, very clever thanks to pit captain\n    * added module_load and module_require, e.g. load into and require into\n    * reimplemented instance_exec, should be much improved\n    * doc updates to inflect.rb\n    * updates to Hash op_add, reverse_merge, and rekey\n    * each_slice is now just an alias via enumerator & fixes to partition_by\n    * minor adjusment to multiglob\n    * modified all.rb (not recommended!) to require facets/sys\n    * modifications to project information file (should this be versioned?)\n    * created yore lib to store deprecated features (good idea!)\n    * modified PROJECT info file\n    * added module class/module_load and _require\n    * remove facet/ redirect lib from darcs repository\n    * OpenObject is now OpenHash (OpenObject still exist for backcompat)\n    * kernel/returning is a stub for kernel/with\n    * added proc/update as alias for #call per Tim Pease use of Proc as Observable\n    * added behavior.rb by Nobuyoshi Nakada (plan to improve)\n    * rewrote taskable.rb using classes to represent tasks; it is much improved\n    * openobject.rb doc updates\n    * major update to functor which is now a subclass of Proc (should be faster)\n    * improvements to dictionary.rb to go along with additions of first and last\n    * small improvements to command.rb\n    * removed uses of __class__ for object_class and solidified usaged of #as in basicobject.rb\n    * deprecated ostruct shadow methods (i.e __table__) in favor of #instance methods\n    * added test to module/alias_method_chain\n    * imporvements to instance_exec thanks to Mauricio Fernandez\n    * improvements to kernel/send_as\n    * improvements to kernel/as\n    * minor doc addition to kernel/as\n    * fixed syntax in hash/op_add.rb\n    * imporvements to hash/partition_by thanks to Gregory of Laurel\n    * added Mauricio Fernandez to authors\n    * added addtional work library lore\n    * moved \"calibre\" project information files\n    * moved a number of \"in the works\" libs to ToadCode project\n    * removed predicate.rb, an expiremental logic system, and moved to ToadCode\n    * Added plugin.rb, an indirect require mechinism, ie. a plugin system\n    * remove one.rb and moved to ToadCode project, this was just silly/fun library\n    * Added library.rb which is a library ledger system (used to be roll.rb)\n    * added kernel/with which instance_eval's a block on with's subject\n    * rekey is an improved version of normalize_keys (ie. the basis of symbolize_keys)\n    * multiglob is like glob but handles a list of patterns\n    * proper access to openstruct's underlying table\n    * minor adjustment to taskable.rb\n    * minor adjustment to #dresner docs\n    * minor adjustment to #as\n    * simple doc addition to setup.rb\n    * doc fixes and losening toplevel constraint to Object in taskable\n    * made OpenObject #update and #merge public; added to_hash\n    * minor \"public\" fix to main_as_object\n    * removed unorder_store and store_only; added first/last to dictionary\n    * continued improvements to command.rb\n      added some new callbacks such as option_missing;\n      also handles method_missing properly now\n    * minor adjustments to module::@+\n    * added string/rewrite\n    * test fixes to module/include_as\n    * documentation fix for class_extension\n    * minor edit to supermethod (also finish #superior removal)\n    * cleanup kernel/set_with code\n    * update kernel/metaclass can now take a block\n    * added hash#+ and hash#- (op_add and op_sub)\n    * added cache to enumerable/every\n    * minor updates to facets.rb\n    * removed kernel/superior (silly name)\n    * minor modifications ot PROJECT file\n    * [add] more/autovivify.rb expiremental lib.\n    * [update] Minor fix to command.rb to not use Kernel methods as subcommands.\n    * [update] Work on annotation.rb to improve support for :self.\n    * [deprecate] enumerable/permute.rb (replaced by permutation) and minor test fix to linkedlist.rb\n    * [added] linkedlist.rb (thanks Kirk Haines!)\n    * [added] enumerable/sum (thanks to Gavin Kistner)\n    * [added] array/each_combo and combos (Eunumerable.combinations will be deprecated eventually)\n    * [rename] changed enumerable/permute to permutation\n    * [update] annotation.rb, fixed :self key\n    * [added] pathname/op_div\n    * [deprecated] hash/each.rb\n    * [removed] hash/each.rb, this variation of Hash#each is too \"dangerous\" in practice\n    * [update] module/self/op_add.rb: fixed inclusion order\n    * annotation.rb, return annotations of self when key is :self [updated]\n    * module/self/op_add.rb and op_sub.rb - traits like features [added]\n    * minor improvemtns to module/clone_using and integrate\n    * command.rb: minor change to docs [update]\n    * openobject.rb (added NilClass#to_openobject) [update]\n    * enumerable/each_slice.rb [replace]\n      Ruby already has #each_slice if you require 'enumerator'. And for 1.9,\n      I believe, this will be present automatically. So Facets' each_slice\n      has been replaced with a simple redirection to require 'enumerator'.\n      Ruby's version is slightly different in that it won't check arity if\n      a slice count is not given. For this, use enumerable/each_by.\n    * array/delete_at.rb [removed]\n      Ruby's Array class already has a #delete_at method,\n      although this is another method at odds with Hash.\n      Use #delete_values_at instead.\n    * moved File.bitbucket to File.null (but bitbucket was so \"fun\"! ;)\n    * added nilclass/to_path\n    * added kernel/load_local\n    * added kernel/callee\n    * added enumerable/eachn, integer/each and integer/of\n    * re-added array/delete_values_at\n    * added filetest/self/root\n    * added cache.rb\n    * moved Dir.bitbucket to File.bitbucket\n    * removed task file in favor of sake based util/\n    * added main_as_module\n    * added doublemetaphone (Thanks Lawrence Philps!)\n    * rewrote taskable.rb\n    * minor doc fix to association.rb\n    * added symbol/to_s which caches the result for speed up\n    * additions and adjusments related to hash/delete_at\n    * added Dir.bitbucket\n    * update to array/op_fetch to include op_store\n    * updated docs and util tasks\n    * minor changes\n    * added filesystem.rb\n    * taskable should now work at the toplevel too\n    * still working the organization as Reap/Sake change\n    * started setting project tasks up for sake\n    * updates to enumerable each_slice\n    * updated names of meta files\n    * added trace to command.rb\n    * organizational changes\n\n\n== 1.7.0 / 2006-07-25\n\nChanges:\n\n* Additions\n\n    * Add Infinity class.\n    * Add `tkxml.rb`.\n    * Add singleton Annotations.\n    * Add Cuts implimentation.\n\n* Improvements\n\n    * Improve command.rb with error catch. (Jonas)\n    * Improve #wrap_method, no need to undef method before redefining.\n    * Improve String#singular and plural.\n    * Improve #normalize_keys to take a proc instead of a \"send\" parameter.\n\n* Bug Fixes\n\n    * Add #to_a to OpenObject.\n    * Fix instance_interception test.\n\n* Miscellaneous Enhancements\n\n    * Add hash/op_div.rb and array/op_div.rb.\n    * Allow tasks to do arguments (all dependent tasks must take same args)\n    * Separated integer/op_mul from compose, op_mul now composes and Integer#of.\n    * added work dir to repo\n\n    * doc cleanup\n\n    * remove kernel/called and fixed callee,__callee__ and __method__.\n    * just about prefected OpenObject\n    * keys_to_sym to symbolize_keys usage\n    * remove explore dir, perhaps better to do without midstage\n\n\n\n== 1.6.0 / 2006-07-20\n\nChanges:\n\n    * PrivateAccess expiremental class\n\n* Additions\n\n    * Add Hash#reverse_merge (from ActiveSupport).\n\n    * adjustments to stringify_keys, record normalize_keys\n    * work on other Hash subclasses Dictionary, OpenCascade, and Hash#having_fallback features\n    * added some core methods enumerable#divide, array and hash op_div, kernel/meta\n    * deprecated generate_method_name and generate_instance_method_name\n    * Hash methods keys_to_s and keys_to_sym to stringify_keys and symbolize_keys\n    Both now depend on normalize_keys\n    * rewrote openobject as a subclass of Hash with a method filter\n    * rewrote annotation.rb and moved into more/\n    * add meta docs to darcs\n    * added Jan Molic's Debugger(Logger) to explore\n    * calibre task (worth the effort?)\n    * added Symbol::generate\n    * remove generate_method_name methods\n    ** removed kernel/generate_method_name\n    ** removed moodule/generate_instance_method_name\n    Neither were thread safe.\n    * new implementation of openobject cont.\n    * updated dictionary class\n    1. created subclass AutoDictionary, now used by Dictionary.auto\n    2. deprecated ::key_new and :value_new, use ::new.by_key and ::new.by_value instead.\n    3. Retained ::alpha but changed ::auto_key to ::auto_alpha.\n    * new implementation of openobject in Facets/EXPLORE\n    * Added deep_clone (thanks Jan Molic)\n    * project metadata work adjustments\n    * minor update to tagiterator.rb\n    * add _darcs expection to FileList\n    * fix to nilclass#status (accept single parameter)\n    * added Hash.auto (thanks Jan Molic)\n    * remove blankslate alias to basicobject\n    * added annotation and instance_intercept to Facets/EXPLORE\n    * added Kernel#to_data\n    * add Daniel Berger's Hash#to_stuct\n    * moved ValueHolder in snapshot.rb to Snapshot::ValueHolder\n    * minor bug fix to alias_method_chain\n    * fix compatiblity with Reap\n    * improved Proc#to_method and Kernel#instance_exec\n    * added instance_exec (duh)\n    * added object_clone and object_dup object_ methods are intended as non-overridable (although you cna if you must).\n    * no Configuration alias for Settings\n    * added facets/explore libs\n    * added settings.rb from glue\n    * openobject uses self[] instead of @table[]\n    also update proj/infp to start 1.5 series\n\n* Deprecations\n\n    * Deprecate BasicObject.\n\n\n== 1.4.5 / 2006-07-05\n\nChanges:\n\n* Additions\n\n    * Add NilClass#status which allows a message to be passed through a failure chain.\n    * Add Module#alias_method_chain from Rails as a cleveridiom for module-based method wrapping.\n      A limited solution, but since there's no standard solution as of yet, well support til then.\n    * Add Enumerable#cascade, cascade a list of actions on each  element of an enumerable.\n\n\n== 1.4.4 / 2006-07-03\n\nChanges:\n\n* Bug Fixes\n\n    * The `#method missing` in HtmlBuilder effected by BasicObject fix\n      (use __self__.method instead of __method__).\n\n* Improved Features\n\n    * Update Functor, by adding `@self = function.binding.self`.\n\n* Renamed Features\n\n    * Change WebAgent to Web.\n\n* Deprecations\n\n    * Removed hash/keys_to_iv b/c it is a poor name. Since the alternative\n      of #keys_to_instance_variables conveys the wrong idea, decided to just\n      get rid of this. Instead use the hash#variablize_keys which is also\n      Rails compatibile.\n\n\n== 1.4.3 / 2006-06-27\n\n* Administrative Adjustments\n\n    * Move ProjectInfo to proj/info.\n    * Better arrangment of repository,\n\n\n== 1.4.2 / 2006-06-21\n\nThis release makes adjustments to BasicObject, further reducing unhidden\nmethods. Among them __object__, __method__ and #as. Also added `#method_missing`\nthat detects shadow methods and rebinds them to Object. Keep in mind that woun't\nhelp you if you override method_missing which is typical for this class.\n\nThis release also marks the first use of Darcs version control manager!\n\nChanges:\n\n* Improvements\n\n    * Adjusted BasicObject slightly, further reducing unhidden methods.\n\n* Bug Fixes\n\n    * Fixed bug in BasicObject#__self__.\n\n* Administrative Adjustments\n\n    * Started using Darcs --finally!\n    * Transition to Darcs has interupted ChangeLog though :(\n\n\n== 1.4.0 / 2006-05-05\n\nChanges:\n\n* Additions\n\n    * Added Cookie, HTTP and HTTPAccess of ...'s library.\n    * Added OpenCascade, which is like OpenObject but chains access.\n    * Added MenTalguy's lazy.rb which include's Future and Promise classes.\n    * Added task.rb, which provides a Rake interface compatible task\n      system, but that can be used in any code.\n\n* Improvements\n\n    * Improved Hash#traverse (it now does all traversing before yielding).\n    * Console::Command also now supports run-on flags (eg. -xvzf).\n    * Updated tuple.rb so that when a string is converted to a Tuple (#to_t)\n      the values wll be made integers if they are composed of only numbers.\n      If you need all strings you can use a block since the block bypasses\n      this auto coercement, eg. to_t{ |v| v }.\n\n* Renames\n\n    * OpenObject's __get__ and __set__ methods have been changed\n      to __fetch__ and __store__ to correspond to the Hash methods.\n\n* Depreacetions\n\n    * kernel/me, kernel/methodname and kernel/method_name have all been\n      deprecated in favor of the 1.9 standard kernel/__method__ and\n      kernel/__callee__.\n    * Console::Application is deprecated and is no longer an alias for\n      Console::Command.\n    * More's classinherit.rb has been removed, and classmethods.rb will be\n      too in  another version or two. You should transition all uses of\n      these to core/module/class_extension.rb.\n\n\n== 1.3.1 / 2006-04-17\n\nChanges:\n\n* Deprecations\n\n    * Deprecated string/to_arr.\n\n* General Enhancements\n\n    * Slightly adjusted string#to_a.\n\n\n== 1.3.0 / 2006-04-05\n\nChanges:\n\n* Additions\n\n  * Ported parts of Nitro's Glue library to Facets.\n      * more/aspects.rb\n      * core/module/on_included.rb\n      * core/module/expirable.rb\n      * core/enumerable/accumulate.rb\n  * Added xoxo.rb, json.rb and rtals.rb.\n\n* General Enhancements\n\n  * Repaired missing data files for units.rb.\n  * Moved cattr methods from module/ to class/.\n  * mattr methods are in limbo at the moment (they were aliases for cattr).\n\n\n== 1.2.1 / 2006-03-29\n\nChanges:\n\n* Renamed Features\n\n  * kernel/meta has been renamed to kernel/instance\n\n\n== 1.2.0 / 2006-03-24\n\nChanges:\n\n* Additions\n\n  * Add zimba.tm's string/modulize, pathize and methodize.\n  * Add some Gem methods, self/active?, self/gemspec, self/gempath.\n\n\n== 1.0.3 / 2006-02-10\n\nChanges:\n\n* Additions\n\n    * Added _why's Array#modulo.\n\n* General Enhancements\n\n    * Last ditch attempt to keep facets and calibre as one project.\n\n\n== 1.0.0 / 2005-12-04\n\nOkay. Now we've finally hit our 1.0.0 relase. Yea! Does it desrve 1.0 at this point?\nAh, well close enough. Mainly there won't be anymore silly development names ;)\n\nChanges:\n\n* General Enhancements\n\n    * Sped up string#similarity.\n    * By popular protest deprecated usage of \"AClass.use Facets, :amethod\".\n    * Created nicer layout of facets/support, /group, /english (one day /method).\n    * Odd sets of facets have been move to facets/group/, eg. facets/group/inflect.\n    * All is now well preped for a Rolls release shoud that come about.\n\n\n","format":"text/rdoc"},"/NOTICE.rdoc":{"!":"document","path":"NOTICE.rdoc","name":"NOTICE.rdoc","mtime":null,"text":"= COPYRIGHT NOTICES\n\n== Ruby Facets\n\nCopyright:: (c) 2005,2011 Thomas Sawyer\n\n  Copyright (c) 2005,2011 Thomas Sawyer\n\n  You may distribute this software under the same terms as Ruby.\n\n\n== Ruby/Extensions\n\nCopyright:: (c) 2004 Gavin Sinclair\nLicense:: Ruby\n\n  Copyright (c) 2004 Gavin Sinclair\n\n  Ruby/Extensions (extensions.rubyforge.org) is copyrighted free software\n  created and maintained by Gavin Sinclair (gsinclair@soyabean.com.au) and\n  released under the same license as Ruby.\n\n  THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS OR\n  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n\n==  Nitro/Glue\n\nCopyright:: (c) 2006, George Moschovitis\nLicense:: BSD-3-Clause\n\n  Copyright (c) 2006, George Moschovitis\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n  * Redistributions of source code must retain the above copyright notice,\n    this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * Neither the name of the <ORGANIZATION> nor the names of its contributors\n    may be used to endorse or promote products derived from this software\n    without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n  POSSIBILITY OF SUCH DAMAGE.\n\n\n== ActiveSupport\n\nCopyright:: (c) 2005-2011 David Heinemeier Hansson\nLicense:: MIT\nWebsite:: http://rails.org\n\n  Copyright (c) 2005-2011 David Heinemeier Hansson\n\n  Permission is hereby granted, free of charge, to any person obtaining\n  a copy of this software and associated documentation files (the\n  \"Software\"), to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, and to\n  permit persons to whom the Software is furnished to do so, subject to\n  the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n== Ruby Treasures\n\nCopyright:: (c) 2001 Paul Brannan\nLicense:: Ruby License\n\n  Ruby Treasures 0.1\n  Copyright (c) 2001 Paul Brannan <paul@atdesk.com>\n\n  You may distribute this software under the same terms as Ruby (see the file\n  RUBY.txt that was distributed with this library).\n\n\n== Metaid\n\nCopyright:: (c) why the lucky stiff\n\n  Copyright (c) why the lucky stiff\n\n\n== CLAP\n\nCopyright:: (c) 2010 Michel Martens\nLicense:: MIT\nWebsite:: https://github.com/soveran/clap\n\n  Copyright (c) 2010 Michel Martens\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n  of the Software, and to permit persons to whom the Software is furnished to\n  do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  IN THE SOFTWARE.\n\n\n== String#natcmp\n\nCopyright:: (c) 2003 by Alan Davies\nLicense:: Custom\n\n  String#natcmp is based on Martin Pool's \"Natural Order String Comparison\"\n  originally written in C. (see http://sourcefrog.net/projects/natsort/)\n\n  This implementation is Copyright (C) 2003 by Alan Davies\n  <cs96and_AT_yahoo_DOT_co_DOT_uk>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n\n  3. This notice may not be removed or altered from any source distribution.\n\n","format":"text/rdoc"},"/RUBY.txt":{"!":"document","path":"RUBY.txt","name":"RUBY.txt","mtime":null,"text":"\n Ruby Facets\n\n Copyright (c) 2005,2010 Thomas Sawyer\n\n\n THE RUBY LICENSE\n (http://www.ruby-lang.org/en/LICENSE.txt)\n\n You may redistribute this software and/or modify it under either the terms of\n the GPL (see below), or the conditions below:\n\n  1. You may make and give away verbatim copies of the source form of the\n     software without restriction, provided that you duplicate all of the\n     original copyright notices and associated disclaimers.\n\n  2. You may modify your copy of the software in any way, provided that\n     you do at least ONE of the following:\n\n       a) place your modifications in the Public Domain or otherwise\n          make them Freely Available, such as by posting said\n          modifications to Usenet or an equivalent medium, or by allowing\n          the author to include your modifications in the software.\n\n       b) use the modified software only within your corporation or\n          organization.\n\n       c) rename any non-standard executables so the names do not conflict\n          with standard executables, which must also be provided.\n\n       d) make other distribution arrangements with the author.\n\n  3. You may distribute the software in object code or executable\n     form, provided that you do at least ONE of the following:\n\n       a) distribute the executables and library files of the software,\n          together with instructions (in the manual page or equivalent)\n          on where to get the original distribution.\n\n       b) accompany the distribution with the machine-readable source of\n          the software.\n\n       c) give non-standard executables non-standard names, with\n          instructions on where to get the original software distribution.\n\n       d) make other distribution arrangements with the author.\n\n  4. You may modify and include the part of the software into any other\n     software (possibly commercial).  But some files in the distribution\n     are not written by the author, so that they are not under these terms.\n\n     For the list of those files and their copying conditions, see the\n     file LEGAL.\n\n  5. The scripts and library files supplied as input to or produced as\n     output from the software do not automatically fall under the\n     copyright of the software, but belong to whomever generated them,\n     and may be sold commercially, and may be aggregated with this\n     software.\n\n  6. THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY EXPRESS OR\n     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n     PURPOSE.\n\n ----------------------------------------------------------------------------\n\n\n                   GNU GENERAL PUBLIC LICENSE\n                     Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n The licenses for most software are designed to take away your\n freedom to share and change it.  By contrast, the GNU General Public\n License is intended to guarantee your freedom to share and change free\n software--to make sure the software is free for all its users.  This\n General Public License applies to most of the Free Software\n Foundation's software and to any other program whose authors commit to\n using it.  (Some other Free Software Foundation software is covered by\n the GNU Library General Public License instead.)  You can apply it to\n your programs, too.\n\n When we speak of free software, we are referring to freedom, not\n price.  Our General Public Licenses are designed to make sure that you\n have the freedom to distribute copies of free software (and charge for\n this service if you wish), that you receive source code or can get it\n if you want it, that you can change the software or use pieces of it\n in new free programs; and that you know you can do these things.\n\n To protect your rights, we need to make restrictions that forbid\n anyone to deny you these rights or to ask you to surrender the rights.\n These restrictions translate to certain responsibilities for you if you\n distribute copies of the software, or if you modify it.\n\n For example, if you distribute copies of such a program, whether\n gratis or for a fee, you must give the recipients all the rights that\n you have.  You must make sure that they, too, receive or can get the\n source code.  And you must show them these terms so they know their\n rights.\n\n We protect your rights with two steps: (1) copyright the software, and\n (2) offer you this license which gives you legal permission to copy,\n distribute and/or modify the software.\n\n Also, for each author's protection and ours, we want to make certain\n that everyone understands that there is no warranty for this free\n software.  If the software is modified by someone else and passed on, we\n want its recipients to know that what they have is not the original, so\n that any problems introduced by others will not reflect on the original\n authors' reputations.\n\n Finally, any free program is threatened constantly by software\n patents.  We wish to avoid the danger that redistributors of a free\n program will individually obtain patent licenses, in effect making the\n program proprietary.  To prevent this, we have made it clear that any\n patent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\n modification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n   0. This License applies to any program or other work which contains\n a notice placed by the copyright holder saying it may be distributed\n under the terms of this General Public License.  The \"Program\", below,\n refers to any such program or work, and a \"work based on the Program\"\n means either the Program or any derivative work under copyright law:\n that is to say, a work containing the Program or a portion of it,\n either verbatim or with modifications and/or translated into another\n language.  (Hereinafter, translation is included without limitation in\n the term \"modification\".)  Each licensee is addressed as \"you\".\n\n Activities other than copying, distribution and modification are not\n covered by this License; they are outside its scope.  The act of\n running the Program is not restricted, and the output from the Program\n is covered only if its contents constitute a work based on the\n Program (independent of having been made by running the Program).\n Whether that is true depends on what the Program does.\n\n    1. You may copy and distribute verbatim copies of the Program's\n  source code as you receive it, in any medium, provided that you\n  conspicuously and appropriately publish on each copy an appropriate\n  copyright notice and disclaimer of warranty; keep intact all the\n  notices that refer to this License and to the absence of any warranty;\n  and give any other recipients of the Program a copy of this License\n  along with the Program.\n\n  You may charge a fee for the physical act of transferring a copy, and\n  you may at your option offer warranty protection in exchange for a fee.\n\n    2. You may modify your copy or copies of the Program or any portion\n  of it, thus forming a work based on the Program, and copy and\n  distribute such modifications or work under the terms of Section 1\n  above, provided that you also meet all of these conditions:\n\n      a) You must cause the modified files to carry prominent notices\n      stating that you changed the files and the date of any change.\n\n      b) You must cause any work that you distribute or publish, that in\n      whole or in part contains or is derived from the Program or any\n      part thereof, to be licensed as a whole at no charge to all third\n      parties under the terms of this License.\n\n      c) If the modified program normally reads commands interactively\n      when run, you must cause it, when started running for such\n      interactive use in the most ordinary way, to print or display an\n      announcement including an appropriate copyright notice and a\n      notice that there is no warranty (or else, saying that you provide\n      a warranty) and that users may redistribute the program under\n      these conditions, and telling the user how to view a copy of this\n      License.  (Exception: if the Program itself is interactive but\n      does not normally print such an announcement, your work based on\n      the Program is not required to print an announcement.)\n  \n  These requirements apply to the modified work as a whole.  If\n  identifiable sections of that work are not derived from the Program,\n  and can be reasonably considered independent and separate works in\n  themselves, then this License, and its terms, do not apply to those\n  sections when you distribute them as separate works.  But when you\n  distribute the same sections as part of a whole which is a work based\n  on the Program, the distribution of the whole must be on the terms of\n  this License, whose permissions for other licensees extend to the\n  entire whole, and thus to each and every part regardless of who wrote it.\n  \n  Thus, it is not the intent of this section to claim rights or contest\n  your rights to work written entirely by you; rather, the intent is to\n  exercise the right to control the distribution of derivative or\n  collective works based on the Program.\n  \n  In addition, mere aggregation of another work not based on the Program\n  with the Program (or with a work based on the Program) on a volume of\n  a storage or distribution medium does not bring the other work under\n  the scope of this License.\n  \n    3. You may copy and distribute the Program (or a work based on it,\n  under Section 2) in object code or executable form under the terms of\n  Sections 1 and 2 above provided that you also do one of the following:\n  \n      a) Accompany it with the complete corresponding machine-readable\n      source code, which must be distributed under the terms of Sections\n      1 and 2 above on a medium customarily used for software interchange; or,\n  \n      b) Accompany it with a written offer, valid for at least three\n      years, to give any third party, for a charge no more than your\n      cost of physically performing source distribution, a complete\n      machine-readable copy of the corresponding source code, to be\n      distributed under the terms of Sections 1 and 2 above on a medium\n      customarily used for software interchange; or,\n  \n      c) Accompany it with the information you received as to the offer\n      to distribute corresponding source code.  (This alternative is\n      allowed only for noncommercial distribution and only if you\n      received the program in object code or executable form with such\n      an offer, in accord with Subsection b above.)\n  \n  The source code for a work means the preferred form of the work for\n  making modifications to it.  For an executable work, complete source\n  code means all the source code for all modules it contains, plus any\n  associated interface definition files, plus the scripts used to\n  control compilation and installation of the executable.  However, as a\n  special exception, the source code distributed need not include\n  anything that is normally distributed (in either source or binary\n  form) with the major components (compiler, kernel, and so on) of the\n  operating system on which the executable runs, unless that component\n  itself accompanies the executable.\n  \n  If distribution of executable or object code is made by offering\n  access to copy from a designated place, then offering equivalent\n  access to copy the source code from the same place counts as\n  distribution of the source code, even though third parties are not\n  compelled to copy the source along with the object code.\n  \n    4. You may not copy, modify, sublicense, or distribute the Program\n  except as expressly provided under this License.  Any attempt\n  otherwise to copy, modify, sublicense or distribute the Program is\n  void, and will automatically terminate your rights under this License.\n  However, parties who have received copies, or rights, from you under\n  this License will not have their licenses terminated so long as such\n  parties remain in full compliance.\n  \n    5. You are not required to accept this License, since you have not\n  signed it.  However, nothing else grants you permission to modify or\n  distribute the Program or its derivative works.  These actions are\n  prohibited by law if you do not accept this License.  Therefore, by\n  modifying or distributing the Program (or any work based on the\n  Program), you indicate your acceptance of this License to do so, and\n  all its terms and conditions for copying, distributing or modifying\n  the Program or works based on it.\n  \n    6. Each time you redistribute the Program (or any work based on the\n  Program), the recipient automatically receives a license from the\n  original licensor to copy, distribute or modify the Program subject to\n  these terms and conditions.  You may not impose any further\n  restrictions on the recipients' exercise of the rights granted herein.\n  You are not responsible for enforcing compliance by third parties to\n  this License.\n  \n    7. If, as a consequence of a court judgment or allegation of patent\n  infringement or for any other reason (not limited to patent issues),\n  conditions are imposed on you (whether by court order, agreement or\n  otherwise) that contradict the conditions of this License, they do not\n  excuse you from the conditions of this License.  If you cannot\n  distribute so as to satisfy simultaneously your obligations under this\n  License and any other pertinent obligations, then as a consequence you\n  may not distribute the Program at all.  For example, if a patent\n  license would not permit royalty-free redistribution of the Program by\n  all those who receive copies directly or indirectly through you, then\n  the only way you could satisfy both it and this License would be to\n  refrain entirely from distribution of the Program.\n  \n  If any portion of this section is held invalid or unenforceable under\n  any particular circumstance, the balance of the section is intended to\n  apply and the section as a whole is intended to apply in other\n  circumstances.\n  \n  It is not the purpose of this section to induce you to infringe any\n  patents or other property right claims or to contest validity of any\n  such claims; this section has the sole purpose of protecting the\n  integrity of the free software distribution system, which is\n  implemented by public license practices.  Many people have made\n  generous contributions to the wide range of software distributed\n  through that system in reliance on consistent application of that\n  system; it is up to the author/donor to decide if he or she is willing\n  to distribute software through any other system and a licensee cannot\n  impose that choice.\n  \n  This section is intended to make thoroughly clear what is believed to\n  be a consequence of the rest of this License.\n  \n    8. If the distribution and/or use of the Program is restricted in\n  certain countries either by patents or by copyrighted interfaces, the\n  original copyright holder who places the Program under this License\n  may add an explicit geographical distribution limitation excluding\n  those countries, so that distribution is permitted only in or among\n  countries not thus excluded.  In such case, this License incorporates\n  the limitation as if written in the body of this License.\n  \n    9. The Free Software Foundation may publish revised and/or new versions\n  of the General Public License from time to time.  Such new versions will\n  be similar in spirit to the present version, but may differ in detail to\n  address new problems or concerns.\n  \n  Each version is given a distinguishing version number.  If the Program\n  specifies a version number of this License which applies to it and \"any\n  later version\", you have the option of following the terms and conditions\n  either of that version or of any later version published by the Free\n  Software Foundation.  If the Program does not specify a version number of\n  this License, you may choose any version ever published by the Free Software\n  Foundation.\n  \n    10. If you wish to incorporate parts of the Program into other free\n  programs whose distribution conditions are different, write to the author\n  to ask for permission.  For software which is copyrighted by the Free\n  Software Foundation, write to the Free Software Foundation; we sometimes\n  make exceptions for this.  Our decision will be guided by the two goals\n  of preserving the free status of all derivatives of our free software and\n  of promoting the sharing and reuse of software generally.\n  \n                              NO WARRANTY\n  \n    11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n  FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n  PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n  OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n  TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n  PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n  REPAIR OR CORRECTION.\n  \n    12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n  REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n  INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n  OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n  TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n  YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n  PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n  POSSIBILITY OF SUCH DAMAGES.\n  \n                      END OF TERMS AND CONDITIONS\n \n","format":"text/plain"},"/lib/core/facets/integer/multiple.rb":{"!":"script","path":"lib/core/facets/integer/multiple.rb","name":"multiple.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/multiple.rb","language":"text/x-ruby"},"/lib/core/facets/integer/ordinal.rb":{"!":"script","path":"lib/core/facets/integer/ordinal.rb","name":"ordinal.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/ordinal.rb","language":"text/x-ruby"},"/lib/core/facets/integer/bit.rb":{"!":"script","path":"lib/core/facets/integer/bit.rb","name":"bit.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/bit.rb","language":"text/x-ruby"},"/lib/core/facets/integer/odd.rb":{"!":"script","path":"lib/core/facets/integer/odd.rb","name":"odd.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/odd.rb","language":"text/x-ruby"},"/lib/core/facets/integer/bitmask.rb":{"!":"script","path":"lib/core/facets/integer/bitmask.rb","name":"bitmask.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/bitmask.rb","language":"text/x-ruby"},"/lib/core/facets/integer/even.rb":{"!":"script","path":"lib/core/facets/integer/even.rb","name":"even.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/even.rb","language":"text/x-ruby"},"/lib/core/facets/integer/factorial.rb":{"!":"script","path":"lib/core/facets/integer/factorial.rb","name":"factorial.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/factorial.rb","language":"text/x-ruby"},"/lib/core/facets/integer/roman.rb":{"!":"script","path":"lib/core/facets/integer/roman.rb","name":"roman.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/roman.rb","language":"text/x-ruby"},"/lib/core/facets/integer/of.rb":{"!":"script","path":"lib/core/facets/integer/of.rb","name":"of.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer/of.rb","language":"text/x-ruby"},"/lib/core/facets/file.rb":{"!":"script","path":"lib/core/facets/file.rb","name":"file.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file.rb","language":"text/x-ruby"},"/lib/core/facets/metaid.rb":{"!":"script","path":"lib/core/facets/metaid.rb","name":"metaid.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/metaid.rb","language":"text/x-ruby"},"/lib/core/facets/object/dup.rb":{"!":"script","path":"lib/core/facets/object/dup.rb","name":"dup.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/object/dup.rb","language":"text/x-ruby"},"/lib/core/facets/object/replace.rb":{"!":"script","path":"lib/core/facets/object/replace.rb","name":"replace.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/object/replace.rb","language":"text/x-ruby"},"/lib/core/facets/object/object_state.rb":{"!":"script","path":"lib/core/facets/object/object_state.rb","name":"object_state.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/object/object_state.rb","language":"text/x-ruby"},"/lib/core/facets/object/clone.rb":{"!":"script","path":"lib/core/facets/object/clone.rb","name":"clone.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/object/clone.rb","language":"text/x-ruby"},"/lib/core/facets/object/try_dup.rb":{"!":"script","path":"lib/core/facets/object/try_dup.rb","name":"try_dup.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/object/try_dup.rb","language":"text/x-ruby"},"/lib/core/facets/matchdata.rb":{"!":"script","path":"lib/core/facets/matchdata.rb","name":"matchdata.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/matchdata.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/thrown.rb":{"!":"script","path":"lib/core/facets/symbol/thrown.rb","name":"thrown.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/thrown.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/bang.rb":{"!":"script","path":"lib/core/facets/symbol/bang.rb","name":"bang.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/bang.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/not.rb":{"!":"script","path":"lib/core/facets/symbol/not.rb","name":"not.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/not.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/setter.rb":{"!":"script","path":"lib/core/facets/symbol/setter.rb","name":"setter.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/setter.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/plain.rb":{"!":"script","path":"lib/core/facets/symbol/plain.rb","name":"plain.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/plain.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/op_div.rb":{"!":"script","path":"lib/core/facets/symbol/op_div.rb","name":"op_div.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/op_div.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/query.rb":{"!":"script","path":"lib/core/facets/symbol/query.rb","name":"query.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/query.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/writer.rb":{"!":"script","path":"lib/core/facets/symbol/writer.rb","name":"writer.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/writer.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/variablize.rb":{"!":"script","path":"lib/core/facets/symbol/variablize.rb","name":"variablize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/variablize.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/reader.rb":{"!":"script","path":"lib/core/facets/symbol/reader.rb","name":"reader.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/reader.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/to_proc.rb":{"!":"script","path":"lib/core/facets/symbol/to_proc.rb","name":"to_proc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/to_proc.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/generate.rb":{"!":"script","path":"lib/core/facets/symbol/generate.rb","name":"generate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/generate.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/succ.rb":{"!":"script","path":"lib/core/facets/symbol/succ.rb","name":"succ.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/succ.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/chomp.rb":{"!":"script","path":"lib/core/facets/symbol/chomp.rb","name":"chomp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/chomp.rb","language":"text/x-ruby"},"/lib/core/facets/symbol/as_s.rb":{"!":"script","path":"lib/core/facets/symbol/as_s.rb","name":"as_s.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol/as_s.rb","language":"text/x-ruby"},"/lib/core/facets/time.rb":{"!":"script","path":"lib/core/facets/time.rb","name":"time.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time.rb","language":"text/x-ruby"},"/lib/core/facets/process/daemon.rb":{"!":"script","path":"lib/core/facets/process/daemon.rb","name":"daemon.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/process/daemon.rb","language":"text/x-ruby"},"/lib/core/facets/object.rb":{"!":"script","path":"lib/core/facets/object.rb","name":"object.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/object.rb","language":"text/x-ruby"},"/lib/core/facets/dir.rb":{"!":"script","path":"lib/core/facets/dir.rb","name":"dir.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir.rb","language":"text/x-ruby"},"/lib/core/facets/to_hash.rb":{"!":"script","path":"lib/core/facets/to_hash.rb","name":"to_hash.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/to_hash.rb","language":"text/x-ruby"},"/lib/core/facets/objectspace/op_fetch.rb":{"!":"script","path":"lib/core/facets/objectspace/op_fetch.rb","name":"op_fetch.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/objectspace/op_fetch.rb","language":"text/x-ruby"},"/lib/core/facets/objectspace/classes.rb":{"!":"script","path":"lib/core/facets/objectspace/classes.rb","name":"classes.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/objectspace/classes.rb","language":"text/x-ruby"},"/lib/core/facets/objectspace/reflect.rb":{"!":"script","path":"lib/core/facets/objectspace/reflect.rb","name":"reflect.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/objectspace/reflect.rb","language":"text/x-ruby"},"/lib/core/facets/unboundmethod/name.rb":{"!":"script","path":"lib/core/facets/unboundmethod/name.rb","name":"name.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/unboundmethod/name.rb","language":"text/x-ruby"},"/lib/core/facets/unboundmethod/arguments.rb":{"!":"script","path":"lib/core/facets/unboundmethod/arguments.rb","name":"arguments.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/unboundmethod/arguments.rb","language":"text/x-ruby"},"/lib/core/facets/objectspace.rb":{"!":"script","path":"lib/core/facets/objectspace.rb","name":"objectspace.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/objectspace.rb","language":"text/x-ruby"},"/lib/core/facets/nilclass/ergo.rb":{"!":"script","path":"lib/core/facets/nilclass/ergo.rb","name":"ergo.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/nilclass/ergo.rb","language":"text/x-ruby"},"/lib/core/facets/nilclass/to_f.rb":{"!":"script","path":"lib/core/facets/nilclass/to_f.rb","name":"to_f.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/nilclass/to_f.rb","language":"text/x-ruby"},"/lib/core/facets/filetest.rb":{"!":"script","path":"lib/core/facets/filetest.rb","name":"filetest.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest.rb","language":"text/x-ruby"},"/lib/core/facets/lazy.rb":{"!":"script","path":"lib/core/facets/lazy.rb","name":"lazy.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/lazy.rb","language":"text/x-ruby"},"/lib/core/facets/range.rb":{"!":"script","path":"lib/core/facets/range.rb","name":"range.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range.rb","language":"text/x-ruby"},"/lib/core/facets/instance.rb":{"!":"script","path":"lib/core/facets/instance.rb","name":"instance.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/instance.rb","language":"text/x-ruby"},"/lib/core/facets/enumerator/fx.rb":{"!":"script","path":"lib/core/facets/enumerator/fx.rb","name":"fx.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerator/fx.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/distance.rb":{"!":"script","path":"lib/core/facets/numeric/distance.rb","name":"distance.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/distance.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/round.rb":{"!":"script","path":"lib/core/facets/numeric/round.rb","name":"round.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/round.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/approx.rb":{"!":"script","path":"lib/core/facets/numeric/approx.rb","name":"approx.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/approx.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/length.rb":{"!":"script","path":"lib/core/facets/numeric/length.rb","name":"length.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/length.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/negative.rb":{"!":"script","path":"lib/core/facets/numeric/negative.rb","name":"negative.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/negative.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/round_to.rb":{"!":"script","path":"lib/core/facets/numeric/round_to.rb","name":"round_to.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/round_to.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/spacing.rb":{"!":"script","path":"lib/core/facets/numeric/spacing.rb","name":"spacing.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/spacing.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/round_at.rb":{"!":"script","path":"lib/core/facets/numeric/round_at.rb","name":"round_at.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/round_at.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/close.rb":{"!":"script","path":"lib/core/facets/numeric/close.rb","name":"close.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/close.rb","language":"text/x-ruby"},"/lib/core/facets/numeric/positive.rb":{"!":"script","path":"lib/core/facets/numeric/positive.rb","name":"positive.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric/positive.rb","language":"text/x-ruby"},"/lib/core/facets/version.rb":{"!":"script","path":"lib/core/facets/version.rb","name":"version.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/version.rb","language":"text/x-ruby"},"/lib/core/facets/indexable.rb":{"!":"script","path":"lib/core/facets/indexable.rb","name":"indexable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/indexable.rb","language":"text/x-ruby"},"/lib/core/facets/module.rb":{"!":"script","path":"lib/core/facets/module.rb","name":"module.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module.rb","language":"text/x-ruby"},"/lib/core/facets/binding/call_stack.rb":{"!":"script","path":"lib/core/facets/binding/call_stack.rb","name":"call_stack.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/call_stack.rb","language":"text/x-ruby"},"/lib/core/facets/binding/caller.rb":{"!":"script","path":"lib/core/facets/binding/caller.rb","name":"caller.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/caller.rb","language":"text/x-ruby"},"/lib/core/facets/binding/op.rb":{"!":"script","path":"lib/core/facets/binding/op.rb","name":"op.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/op.rb","language":"text/x-ruby"},"/lib/core/facets/binding/with.rb":{"!":"script","path":"lib/core/facets/binding/with.rb","name":"with.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/with.rb","language":"text/x-ruby"},"/lib/core/facets/binding/__method__.rb":{"!":"script","path":"lib/core/facets/binding/__method__.rb","name":"__method__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/__method__.rb","language":"text/x-ruby"},"/lib/core/facets/binding/eval.rb":{"!":"script","path":"lib/core/facets/binding/eval.rb","name":"eval.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/eval.rb","language":"text/x-ruby"},"/lib/core/facets/binding/self.rb":{"!":"script","path":"lib/core/facets/binding/self.rb","name":"self.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/self.rb","language":"text/x-ruby"},"/lib/core/facets/binding/local_variables.rb":{"!":"script","path":"lib/core/facets/binding/local_variables.rb","name":"local_variables.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/local_variables.rb","language":"text/x-ruby"},"/lib/core/facets/binding/callstack.rb":{"!":"script","path":"lib/core/facets/binding/callstack.rb","name":"callstack.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/callstack.rb","language":"text/x-ruby"},"/lib/core/facets/binding/op_get.rb":{"!":"script","path":"lib/core/facets/binding/op_get.rb","name":"op_get.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/op_get.rb","language":"text/x-ruby"},"/lib/core/facets/binding/op_set.rb":{"!":"script","path":"lib/core/facets/binding/op_set.rb","name":"op_set.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/op_set.rb","language":"text/x-ruby"},"/lib/core/facets/binding/__callee__.rb":{"!":"script","path":"lib/core/facets/binding/__callee__.rb","name":"__callee__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/__callee__.rb","language":"text/x-ruby"},"/lib/core/facets/binding/defined.rb":{"!":"script","path":"lib/core/facets/binding/defined.rb","name":"defined.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding/defined.rb","language":"text/x-ruby"},"/lib/core/facets/float/round.rb":{"!":"script","path":"lib/core/facets/float/round.rb","name":"round.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/float/round.rb","language":"text/x-ruby"},"/lib/core/facets/hash.rb":{"!":"script","path":"lib/core/facets/hash.rb","name":"hash.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash.rb","language":"text/x-ruby"},"/lib/core/facets/proc/update.rb":{"!":"script","path":"lib/core/facets/proc/update.rb","name":"update.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/update.rb","language":"text/x-ruby"},"/lib/core/facets/proc/curry.rb":{"!":"script","path":"lib/core/facets/proc/curry.rb","name":"curry.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/curry.rb","language":"text/x-ruby"},"/lib/core/facets/proc/partial.rb":{"!":"script","path":"lib/core/facets/proc/partial.rb","name":"partial.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/partial.rb","language":"text/x-ruby"},"/lib/core/facets/proc/bind_to.rb":{"!":"script","path":"lib/core/facets/proc/bind_to.rb","name":"bind_to.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/bind_to.rb","language":"text/x-ruby"},"/lib/core/facets/proc/compose.rb":{"!":"script","path":"lib/core/facets/proc/compose.rb","name":"compose.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/compose.rb","language":"text/x-ruby"},"/lib/core/facets/proc/to_method.rb":{"!":"script","path":"lib/core/facets/proc/to_method.rb","name":"to_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/to_method.rb","language":"text/x-ruby"},"/lib/core/facets/proc/bind.rb":{"!":"script","path":"lib/core/facets/proc/bind.rb","name":"bind.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc/bind.rb","language":"text/x-ruby"},"/lib/core/facets/boolean.rb":{"!":"script","path":"lib/core/facets/boolean.rb","name":"boolean.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/boolean.rb","language":"text/x-ruby"},"/lib/core/facets/range/overlap.rb":{"!":"script","path":"lib/core/facets/range/overlap.rb","name":"overlap.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range/overlap.rb","language":"text/x-ruby"},"/lib/core/facets/range/umbrella.rb":{"!":"script","path":"lib/core/facets/range/umbrella.rb","name":"umbrella.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range/umbrella.rb","language":"text/x-ruby"},"/lib/core/facets/range/quantile.rb":{"!":"script","path":"lib/core/facets/range/quantile.rb","name":"quantile.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range/quantile.rb","language":"text/x-ruby"},"/lib/core/facets/range/combine.rb":{"!":"script","path":"lib/core/facets/range/combine.rb","name":"combine.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range/combine.rb","language":"text/x-ruby"},"/lib/core/facets/range/to_r.rb":{"!":"script","path":"lib/core/facets/range/to_r.rb","name":"to_r.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range/to_r.rb","language":"text/x-ruby"},"/lib/core/facets/range/within.rb":{"!":"script","path":"lib/core/facets/range/within.rb","name":"within.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/range/within.rb","language":"text/x-ruby"},"/lib/core/facets/struct.rb":{"!":"script","path":"lib/core/facets/struct.rb","name":"struct.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/struct.rb","language":"text/x-ruby"},"/lib/core/facets/na.rb":{"!":"script","path":"lib/core/facets/na.rb","name":"na.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/na.rb","language":"text/x-ruby"},"/lib/core/facets/enumerator.rb":{"!":"script","path":"lib/core/facets/enumerator.rb","name":"enumerator.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerator.rb","language":"text/x-ruby"},"/lib/core/facets/nilclass.rb":{"!":"script","path":"lib/core/facets/nilclass.rb","name":"nilclass.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/nilclass.rb","language":"text/x-ruby"},"/lib/core/facets/file/read_binary.rb":{"!":"script","path":"lib/core/facets/file/read_binary.rb","name":"read_binary.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/read_binary.rb","language":"text/x-ruby"},"/lib/core/facets/file/atomic_open.rb":{"!":"script","path":"lib/core/facets/file/atomic_open.rb","name":"atomic_open.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/atomic_open.rb","language":"text/x-ruby"},"/lib/core/facets/file/rootname.rb":{"!":"script","path":"lib/core/facets/file/rootname.rb","name":"rootname.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/rootname.rb","language":"text/x-ruby"},"/lib/core/facets/file/split_root.rb":{"!":"script","path":"lib/core/facets/file/split_root.rb","name":"split_root.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/split_root.rb","language":"text/x-ruby"},"/lib/core/facets/file/sanitize.rb":{"!":"script","path":"lib/core/facets/file/sanitize.rb","name":"sanitize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/sanitize.rb","language":"text/x-ruby"},"/lib/core/facets/file/atomic_write.rb":{"!":"script","path":"lib/core/facets/file/atomic_write.rb","name":"atomic_write.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/atomic_write.rb","language":"text/x-ruby"},"/lib/core/facets/file/null.rb":{"!":"script","path":"lib/core/facets/file/null.rb","name":"null.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/null.rb","language":"text/x-ruby"},"/lib/core/facets/file/read_list.rb":{"!":"script","path":"lib/core/facets/file/read_list.rb","name":"read_list.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/read_list.rb","language":"text/x-ruby"},"/lib/core/facets/file/create.rb":{"!":"script","path":"lib/core/facets/file/create.rb","name":"create.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/create.rb","language":"text/x-ruby"},"/lib/core/facets/file/write.rb":{"!":"script","path":"lib/core/facets/file/write.rb","name":"write.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/write.rb","language":"text/x-ruby"},"/lib/core/facets/file/writelines.rb":{"!":"script","path":"lib/core/facets/file/writelines.rb","name":"writelines.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/writelines.rb","language":"text/x-ruby"},"/lib/core/facets/file/append.rb":{"!":"script","path":"lib/core/facets/file/append.rb","name":"append.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/append.rb","language":"text/x-ruby"},"/lib/core/facets/file/atomic_id.rb":{"!":"script","path":"lib/core/facets/file/atomic_id.rb","name":"atomic_id.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/atomic_id.rb","language":"text/x-ruby"},"/lib/core/facets/file/split_all.rb":{"!":"script","path":"lib/core/facets/file/split_all.rb","name":"split_all.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/split_all.rb","language":"text/x-ruby"},"/lib/core/facets/file/rewrite.rb":{"!":"script","path":"lib/core/facets/file/rewrite.rb","name":"rewrite.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/rewrite.rb","language":"text/x-ruby"},"/lib/core/facets/file/ext.rb":{"!":"script","path":"lib/core/facets/file/ext.rb","name":"ext.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/file/ext.rb","language":"text/x-ruby"},"/lib/core/facets/integer.rb":{"!":"script","path":"lib/core/facets/integer.rb","name":"integer.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/integer.rb","language":"text/x-ruby"},"/lib/core/facets/exception.rb":{"!":"script","path":"lib/core/facets/exception.rb","name":"exception.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/exception.rb","language":"text/x-ruby"},"/lib/core/facets/comparable.rb":{"!":"script","path":"lib/core/facets/comparable.rb","name":"comparable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable.rb","language":"text/x-ruby"},"/lib/core/facets/float.rb":{"!":"script","path":"lib/core/facets/float.rb","name":"float.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/float.rb","language":"text/x-ruby"},"/lib/core/facets/hash/new_with.rb":{"!":"script","path":"lib/core/facets/hash/new_with.rb","name":"new_with.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/new_with.rb","language":"text/x-ruby"},"/lib/core/facets/hash/dearray_values.rb":{"!":"script","path":"lib/core/facets/hash/dearray_values.rb","name":"dearray_values.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/dearray_values.rb","language":"text/x-ruby"},"/lib/core/facets/hash/update_values.rb":{"!":"script","path":"lib/core/facets/hash/update_values.rb","name":"update_values.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/update_values.rb","language":"text/x-ruby"},"/lib/core/facets/hash/alias.rb":{"!":"script","path":"lib/core/facets/hash/alias.rb","name":"alias.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/alias.rb","language":"text/x-ruby"},"/lib/core/facets/hash/update.rb":{"!":"script","path":"lib/core/facets/hash/update.rb","name":"update.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/update.rb","language":"text/x-ruby"},"/lib/core/facets/hash/autonew.rb":{"!":"script","path":"lib/core/facets/hash/autonew.rb","name":"autonew.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/autonew.rb","language":"text/x-ruby"},"/lib/core/facets/hash/recursively.rb":{"!":"script","path":"lib/core/facets/hash/recursively.rb","name":"recursively.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/recursively.rb","language":"text/x-ruby"},"/lib/core/facets/hash/delete_unless.rb":{"!":"script","path":"lib/core/facets/hash/delete_unless.rb","name":"delete_unless.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/delete_unless.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op_and.rb":{"!":"script","path":"lib/core/facets/hash/op_and.rb","name":"op_and.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op_and.rb","language":"text/x-ruby"},"/lib/core/facets/hash/graph.rb":{"!":"script","path":"lib/core/facets/hash/graph.rb","name":"graph.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/graph.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op_sub.rb":{"!":"script","path":"lib/core/facets/hash/op_sub.rb","name":"op_sub.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op_sub.rb","language":"text/x-ruby"},"/lib/core/facets/hash/except.rb":{"!":"script","path":"lib/core/facets/hash/except.rb","name":"except.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/except.rb","language":"text/x-ruby"},"/lib/core/facets/hash/stringify_keys.rb":{"!":"script","path":"lib/core/facets/hash/stringify_keys.rb","name":"stringify_keys.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/stringify_keys.rb","language":"text/x-ruby"},"/lib/core/facets/hash/keys.rb":{"!":"script","path":"lib/core/facets/hash/keys.rb","name":"keys.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/keys.rb","language":"text/x-ruby"},"/lib/core/facets/hash/deep_merge.rb":{"!":"script","path":"lib/core/facets/hash/deep_merge.rb","name":"deep_merge.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/deep_merge.rb","language":"text/x-ruby"},"/lib/core/facets/hash/recurse.rb":{"!":"script","path":"lib/core/facets/hash/recurse.rb","name":"recurse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/recurse.rb","language":"text/x-ruby"},"/lib/core/facets/hash/traverse.rb":{"!":"script","path":"lib/core/facets/hash/traverse.rb","name":"traverse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/traverse.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op_or.rb":{"!":"script","path":"lib/core/facets/hash/op_or.rb","name":"op_or.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op_or.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op.rb":{"!":"script","path":"lib/core/facets/hash/op.rb","name":"op.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op_mul.rb":{"!":"script","path":"lib/core/facets/hash/op_mul.rb","name":"op_mul.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op_mul.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op_push.rb":{"!":"script","path":"lib/core/facets/hash/op_push.rb","name":"op_push.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op_push.rb","language":"text/x-ruby"},"/lib/core/facets/hash/inverse.rb":{"!":"script","path":"lib/core/facets/hash/inverse.rb","name":"inverse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/inverse.rb","language":"text/x-ruby"},"/lib/core/facets/hash/data.rb":{"!":"script","path":"lib/core/facets/hash/data.rb","name":"data.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/data.rb","language":"text/x-ruby"},"/lib/core/facets/hash/to_proc.rb":{"!":"script","path":"lib/core/facets/hash/to_proc.rb","name":"to_proc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/to_proc.rb","language":"text/x-ruby"},"/lib/core/facets/hash/insert.rb":{"!":"script","path":"lib/core/facets/hash/insert.rb","name":"insert.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/insert.rb","language":"text/x-ruby"},"/lib/core/facets/hash/select.rb":{"!":"script","path":"lib/core/facets/hash/select.rb","name":"select.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/select.rb","language":"text/x-ruby"},"/lib/core/facets/hash/to_options.rb":{"!":"script","path":"lib/core/facets/hash/to_options.rb","name":"to_options.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/to_options.rb","language":"text/x-ruby"},"/lib/core/facets/hash/diff.rb":{"!":"script","path":"lib/core/facets/hash/diff.rb","name":"diff.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/diff.rb","language":"text/x-ruby"},"/lib/core/facets/hash/mash.rb":{"!":"script","path":"lib/core/facets/hash/mash.rb","name":"mash.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/mash.rb","language":"text/x-ruby"},"/lib/core/facets/hash/reverse_merge.rb":{"!":"script","path":"lib/core/facets/hash/reverse_merge.rb","name":"reverse_merge.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/reverse_merge.rb","language":"text/x-ruby"},"/lib/core/facets/hash/zip.rb":{"!":"script","path":"lib/core/facets/hash/zip.rb","name":"zip.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/zip.rb","language":"text/x-ruby"},"/lib/core/facets/hash/delete_at.rb":{"!":"script","path":"lib/core/facets/hash/delete_at.rb","name":"delete_at.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/delete_at.rb","language":"text/x-ruby"},"/lib/core/facets/hash/collate.rb":{"!":"script","path":"lib/core/facets/hash/collate.rb","name":"collate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/collate.rb","language":"text/x-ruby"},"/lib/core/facets/hash/delete.rb":{"!":"script","path":"lib/core/facets/hash/delete.rb","name":"delete.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/delete.rb","language":"text/x-ruby"},"/lib/core/facets/hash/weave.rb":{"!":"script","path":"lib/core/facets/hash/weave.rb","name":"weave.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/weave.rb","language":"text/x-ruby"},"/lib/core/facets/hash/swap.rb":{"!":"script","path":"lib/core/facets/hash/swap.rb","name":"swap.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/swap.rb","language":"text/x-ruby"},"/lib/core/facets/hash/to_struct.rb":{"!":"script","path":"lib/core/facets/hash/to_struct.rb","name":"to_struct.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/to_struct.rb","language":"text/x-ruby"},"/lib/core/facets/hash/symbolize_keys.rb":{"!":"script","path":"lib/core/facets/hash/symbolize_keys.rb","name":"symbolize_keys.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/symbolize_keys.rb","language":"text/x-ruby"},"/lib/core/facets/hash/to_mod.rb":{"!":"script","path":"lib/core/facets/hash/to_mod.rb","name":"to_mod.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/to_mod.rb","language":"text/x-ruby"},"/lib/core/facets/hash/join.rb":{"!":"script","path":"lib/core/facets/hash/join.rb","name":"join.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/join.rb","language":"text/x-ruby"},"/lib/core/facets/hash/delete_values.rb":{"!":"script","path":"lib/core/facets/hash/delete_values.rb","name":"delete_values.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/delete_values.rb","language":"text/x-ruby"},"/lib/core/facets/hash/replace_each.rb":{"!":"script","path":"lib/core/facets/hash/replace_each.rb","name":"replace_each.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/replace_each.rb","language":"text/x-ruby"},"/lib/core/facets/hash/slice.rb":{"!":"script","path":"lib/core/facets/hash/slice.rb","name":"slice.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/slice.rb","language":"text/x-ruby"},"/lib/core/facets/hash/to_h.rb":{"!":"script","path":"lib/core/facets/hash/to_h.rb","name":"to_h.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/to_h.rb","language":"text/x-ruby"},"/lib/core/facets/hash/count.rb":{"!":"script","path":"lib/core/facets/hash/count.rb","name":"count.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/count.rb","language":"text/x-ruby"},"/lib/core/facets/hash/url_params.rb":{"!":"script","path":"lib/core/facets/hash/url_params.rb","name":"url_params.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/url_params.rb","language":"text/x-ruby"},"/lib/core/facets/hash/op_add.rb":{"!":"script","path":"lib/core/facets/hash/op_add.rb","name":"op_add.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/op_add.rb","language":"text/x-ruby"},"/lib/core/facets/hash/rekey.rb":{"!":"script","path":"lib/core/facets/hash/rekey.rb","name":"rekey.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/rekey.rb","language":"text/x-ruby"},"/lib/core/facets/hash/update_each.rb":{"!":"script","path":"lib/core/facets/hash/update_each.rb","name":"update_each.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/update_each.rb","language":"text/x-ruby"},"/lib/core/facets/hash/update_keys.rb":{"!":"script","path":"lib/core/facets/hash/update_keys.rb","name":"update_keys.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/update_keys.rb","language":"text/x-ruby"},"/lib/core/facets/hash/argumentize.rb":{"!":"script","path":"lib/core/facets/hash/argumentize.rb","name":"argumentize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/argumentize.rb","language":"text/x-ruby"},"/lib/core/facets/hash/subset.rb":{"!":"script","path":"lib/core/facets/hash/subset.rb","name":"subset.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/subset.rb","language":"text/x-ruby"},"/lib/core/facets/hash/at.rb":{"!":"script","path":"lib/core/facets/hash/at.rb","name":"at.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/hash/at.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/here.rb":{"!":"script","path":"lib/core/facets/kernel/here.rb","name":"here.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/here.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/as.rb":{"!":"script","path":"lib/core/facets/kernel/as.rb","name":"as.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/as.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/extension.rb":{"!":"script","path":"lib/core/facets/kernel/extension.rb","name":"extension.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/extension.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/silence_warnings.rb":{"!":"script","path":"lib/core/facets/kernel/silence_warnings.rb","name":"silence_warnings.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/silence_warnings.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/__class__.rb":{"!":"script","path":"lib/core/facets/kernel/__class__.rb","name":"__class__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/__class__.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/writers.rb":{"!":"script","path":"lib/core/facets/kernel/writers.rb","name":"writers.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/writers.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/ask.rb":{"!":"script","path":"lib/core/facets/kernel/ask.rb","name":"ask.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/ask.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/require_relative.rb":{"!":"script","path":"lib/core/facets/kernel/require_relative.rb","name":"require_relative.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/require_relative.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/not.rb":{"!":"script","path":"lib/core/facets/kernel/not.rb","name":"not.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/not.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/trap_chain.rb":{"!":"script","path":"lib/core/facets/kernel/trap_chain.rb","name":"trap_chain.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/trap_chain.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/call_stack.rb":{"!":"script","path":"lib/core/facets/kernel/call_stack.rb","name":"call_stack.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/call_stack.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/meta_eval.rb":{"!":"script","path":"lib/core/facets/kernel/meta_eval.rb","name":"meta_eval.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/meta_eval.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/demo.rb":{"!":"script","path":"lib/core/facets/kernel/demo.rb","name":"demo.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/demo.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/case.rb":{"!":"script","path":"lib/core/facets/kernel/case.rb","name":"case.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/case.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/hierarchical_send.rb":{"!":"script","path":"lib/core/facets/kernel/hierarchical_send.rb","name":"hierarchical_send.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/hierarchical_send.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/maybe.rb":{"!":"script","path":"lib/core/facets/kernel/maybe.rb","name":"maybe.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/maybe.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/eigen.rb":{"!":"script","path":"lib/core/facets/kernel/eigen.rb","name":"eigen.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/eigen.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/instance_send.rb":{"!":"script","path":"lib/core/facets/kernel/instance_send.rb","name":"instance_send.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/instance_send.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/disable_warnings.rb":{"!":"script","path":"lib/core/facets/kernel/disable_warnings.rb","name":"disable_warnings.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/disable_warnings.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/assign_from.rb":{"!":"script","path":"lib/core/facets/kernel/assign_from.rb","name":"assign_from.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/assign_from.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/equate.rb":{"!":"script","path":"lib/core/facets/kernel/equate.rb","name":"equate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/equate.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/object_hexid.rb":{"!":"script","path":"lib/core/facets/kernel/object_hexid.rb","name":"object_hexid.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/object_hexid.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/object_class.rb":{"!":"script","path":"lib/core/facets/kernel/object_class.rb","name":"object_class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/object_class.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/tap.rb":{"!":"script","path":"lib/core/facets/kernel/tap.rb","name":"tap.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/tap.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/object_send.rb":{"!":"script","path":"lib/core/facets/kernel/object_send.rb","name":"object_send.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/object_send.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/ergo.rb":{"!":"script","path":"lib/core/facets/kernel/ergo.rb","name":"ergo.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/ergo.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/load_relative.rb":{"!":"script","path":"lib/core/facets/kernel/load_relative.rb","name":"load_relative.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/load_relative.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/complete.rb":{"!":"script","path":"lib/core/facets/kernel/complete.rb","name":"complete.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/complete.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/identical.rb":{"!":"script","path":"lib/core/facets/kernel/identical.rb","name":"identical.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/identical.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/__get__.rb":{"!":"script","path":"lib/core/facets/kernel/__get__.rb","name":"__get__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/__get__.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/memo.rb":{"!":"script","path":"lib/core/facets/kernel/memo.rb","name":"memo.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/memo.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/y.rb":{"!":"script","path":"lib/core/facets/kernel/y.rb","name":"y.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/y.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/not_nil.rb":{"!":"script","path":"lib/core/facets/kernel/not_nil.rb","name":"not_nil.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/not_nil.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/yes.rb":{"!":"script","path":"lib/core/facets/kernel/yes.rb","name":"yes.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/yes.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/deep_copy.rb":{"!":"script","path":"lib/core/facets/kernel/deep_copy.rb","name":"deep_copy.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/deep_copy.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/silence.rb":{"!":"script","path":"lib/core/facets/kernel/silence.rb","name":"silence.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/silence.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/load_all.rb":{"!":"script","path":"lib/core/facets/kernel/load_all.rb","name":"load_all.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/load_all.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/require_all.rb":{"!":"script","path":"lib/core/facets/kernel/require_all.rb","name":"require_all.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/require_all.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/qua_class.rb":{"!":"script","path":"lib/core/facets/kernel/qua_class.rb","name":"qua_class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/qua_class.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/eigenclass.rb":{"!":"script","path":"lib/core/facets/kernel/eigenclass.rb","name":"eigenclass.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/eigenclass.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/instance_assign.rb":{"!":"script","path":"lib/core/facets/kernel/instance_assign.rb","name":"instance_assign.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/instance_assign.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/meta_class.rb":{"!":"script","path":"lib/core/facets/kernel/meta_class.rb","name":"meta_class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/meta_class.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/presence.rb":{"!":"script","path":"lib/core/facets/kernel/presence.rb","name":"presence.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/presence.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/with.rb":{"!":"script","path":"lib/core/facets/kernel/with.rb","name":"with.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/with.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/present.rb":{"!":"script","path":"lib/core/facets/kernel/present.rb","name":"present.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/present.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/d.rb":{"!":"script","path":"lib/core/facets/kernel/d.rb","name":"d.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/d.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/__set__.rb":{"!":"script","path":"lib/core/facets/kernel/__set__.rb","name":"__set__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/__set__.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/__method__.rb":{"!":"script","path":"lib/core/facets/kernel/__method__.rb","name":"__method__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/__method__.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/meta_def.rb":{"!":"script","path":"lib/core/facets/kernel/meta_def.rb","name":"meta_def.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/meta_def.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/no.rb":{"!":"script","path":"lib/core/facets/kernel/no.rb","name":"no.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/no.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/source_location.rb":{"!":"script","path":"lib/core/facets/kernel/source_location.rb","name":"source_location.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/source_location.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/instance_class.rb":{"!":"script","path":"lib/core/facets/kernel/instance_class.rb","name":"instance_class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/instance_class.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/instance_exec.rb":{"!":"script","path":"lib/core/facets/kernel/instance_exec.rb","name":"instance_exec.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/instance_exec.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/attr_singleton.rb":{"!":"script","path":"lib/core/facets/kernel/attr_singleton.rb","name":"attr_singleton.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/attr_singleton.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/p.rb":{"!":"script","path":"lib/core/facets/kernel/p.rb","name":"p.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/p.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/assign.rb":{"!":"script","path":"lib/core/facets/kernel/assign.rb","name":"assign.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/assign.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/singleton_class.rb":{"!":"script","path":"lib/core/facets/kernel/singleton_class.rb","name":"singleton_class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/singleton_class.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/try.rb":{"!":"script","path":"lib/core/facets/kernel/try.rb","name":"try.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/try.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/true.rb":{"!":"script","path":"lib/core/facets/kernel/true.rb","name":"true.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/true.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/super_method.rb":{"!":"script","path":"lib/core/facets/kernel/super_method.rb","name":"super_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/super_method.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/__dir__.rb":{"!":"script","path":"lib/core/facets/kernel/__dir__.rb","name":"__dir__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/__dir__.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/meta_alias.rb":{"!":"script","path":"lib/core/facets/kernel/meta_alias.rb","name":"meta_alias.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/meta_alias.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/enable_warnings.rb":{"!":"script","path":"lib/core/facets/kernel/enable_warnings.rb","name":"enable_warnings.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/enable_warnings.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/extend.rb":{"!":"script","path":"lib/core/facets/kernel/extend.rb","name":"extend.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/extend.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/returning.rb":{"!":"script","path":"lib/core/facets/kernel/returning.rb","name":"returning.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/returning.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/callstack.rb":{"!":"script","path":"lib/core/facets/kernel/callstack.rb","name":"callstack.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/callstack.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/val.rb":{"!":"script","path":"lib/core/facets/kernel/val.rb","name":"val.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/val.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/constant.rb":{"!":"script","path":"lib/core/facets/kernel/constant.rb","name":"constant.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/constant.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/method.rb":{"!":"script","path":"lib/core/facets/kernel/method.rb","name":"method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/method.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/__callee__.rb":{"!":"script","path":"lib/core/facets/kernel/__callee__.rb","name":"__callee__.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/__callee__.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/respond.rb":{"!":"script","path":"lib/core/facets/kernel/respond.rb","name":"respond.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/respond.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/deep_clone.rb":{"!":"script","path":"lib/core/facets/kernel/deep_clone.rb","name":"deep_clone.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/deep_clone.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/false.rb":{"!":"script","path":"lib/core/facets/kernel/false.rb","name":"false.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/false.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/blank.rb":{"!":"script","path":"lib/core/facets/kernel/blank.rb","name":"blank.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/blank.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/in.rb":{"!":"script","path":"lib/core/facets/kernel/in.rb","name":"in.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/in.rb","language":"text/x-ruby"},"/lib/core/facets/kernel/temporarily.rb":{"!":"script","path":"lib/core/facets/kernel/temporarily.rb","name":"temporarily.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel/temporarily.rb","language":"text/x-ruby"},"/lib/core/facets/struct/attributes.rb":{"!":"script","path":"lib/core/facets/struct/attributes.rb","name":"attributes.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/struct/attributes.rb","language":"text/x-ruby"},"/lib/core/facets/fixnum.rb":{"!":"script","path":"lib/core/facets/fixnum.rb","name":"fixnum.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/fixnum.rb","language":"text/x-ruby"},"/lib/core/facets/applique/file_helpers.rb":{"!":"script","path":"lib/core/facets/applique/file_helpers.rb","name":"file_helpers.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/applique/file_helpers.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/cap.rb":{"!":"script","path":"lib/core/facets/comparable/cap.rb","name":"cap.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/cap.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/bound.rb":{"!":"script","path":"lib/core/facets/comparable/bound.rb","name":"bound.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/bound.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/cmp.rb":{"!":"script","path":"lib/core/facets/comparable/cmp.rb","name":"cmp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/cmp.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/clip.rb":{"!":"script","path":"lib/core/facets/comparable/clip.rb","name":"clip.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/clip.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/at_least.rb":{"!":"script","path":"lib/core/facets/comparable/at_least.rb","name":"at_least.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/at_least.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/at_most.rb":{"!":"script","path":"lib/core/facets/comparable/at_most.rb","name":"at_most.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/at_most.rb","language":"text/x-ruby"},"/lib/core/facets/comparable/op_get.rb":{"!":"script","path":"lib/core/facets/comparable/op_get.rb","name":"op_get.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/comparable/op_get.rb","language":"text/x-ruby"},"/lib/core/facets/method/memoize.rb":{"!":"script","path":"lib/core/facets/method/memoize.rb","name":"memoize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/method/memoize.rb","language":"text/x-ruby"},"/lib/core/facets/method/op_mul.rb":{"!":"script","path":"lib/core/facets/method/op_mul.rb","name":"op_mul.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/method/op_mul.rb","language":"text/x-ruby"},"/lib/core/facets/method/composition.rb":{"!":"script","path":"lib/core/facets/method/composition.rb","name":"composition.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/method/composition.rb","language":"text/x-ruby"},"/lib/core/facets/method/op_pow.rb":{"!":"script","path":"lib/core/facets/method/op_pow.rb","name":"op_pow.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/method/op_pow.rb","language":"text/x-ruby"},"/lib/core/facets/regexp.rb":{"!":"script","path":"lib/core/facets/regexp.rb","name":"regexp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/regexp.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/take.rb":{"!":"script","path":"lib/core/facets/enumerable/take.rb","name":"take.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/take.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/expand.rb":{"!":"script","path":"lib/core/facets/enumerable/expand.rb","name":"expand.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/expand.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/one.rb":{"!":"script","path":"lib/core/facets/enumerable/one.rb","name":"one.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/one.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/zip_map.rb":{"!":"script","path":"lib/core/facets/enumerable/zip_map.rb","name":"zip_map.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/zip_map.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/each_with_object.rb":{"!":"script","path":"lib/core/facets/enumerable/each_with_object.rb","name":"each_with_object.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/each_with_object.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/cluster_by.rb":{"!":"script","path":"lib/core/facets/enumerable/cluster_by.rb","name":"cluster_by.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/cluster_by.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/group_by.rb":{"!":"script","path":"lib/core/facets/enumerable/group_by.rb","name":"group_by.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/group_by.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/sum.rb":{"!":"script","path":"lib/core/facets/enumerable/sum.rb","name":"sum.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/sum.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/map_detect.rb":{"!":"script","path":"lib/core/facets/enumerable/map_detect.rb","name":"map_detect.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/map_detect.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/visit.rb":{"!":"script","path":"lib/core/facets/enumerable/visit.rb","name":"visit.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/visit.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/recursively.rb":{"!":"script","path":"lib/core/facets/enumerable/recursively.rb","name":"recursively.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/recursively.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/map_with.rb":{"!":"script","path":"lib/core/facets/enumerable/map_with.rb","name":"map_with.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/map_with.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/graph.rb":{"!":"script","path":"lib/core/facets/enumerable/graph.rb","name":"graph.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/graph.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/ewise.rb":{"!":"script","path":"lib/core/facets/enumerable/ewise.rb","name":"ewise.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/ewise.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/occur.rb":{"!":"script","path":"lib/core/facets/enumerable/occur.rb","name":"occur.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/occur.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/frequency.rb":{"!":"script","path":"lib/core/facets/enumerable/frequency.rb","name":"frequency.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/frequency.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/find_yield.rb":{"!":"script","path":"lib/core/facets/enumerable/find_yield.rb","name":"find_yield.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/find_yield.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/hashify.rb":{"!":"script","path":"lib/core/facets/enumerable/hashify.rb","name":"hashify.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/hashify.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/per.rb":{"!":"script","path":"lib/core/facets/enumerable/per.rb","name":"per.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/per.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/none.rb":{"!":"script","path":"lib/core/facets/enumerable/none.rb","name":"none.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/none.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/defer.rb":{"!":"script","path":"lib/core/facets/enumerable/defer.rb","name":"defer.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/defer.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/uniq_by.rb":{"!":"script","path":"lib/core/facets/enumerable/uniq_by.rb","name":"uniq_by.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/uniq_by.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/accumulate.rb":{"!":"script","path":"lib/core/facets/enumerable/accumulate.rb","name":"accumulate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/accumulate.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/incase.rb":{"!":"script","path":"lib/core/facets/enumerable/incase.rb","name":"incase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/incase.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/mash.rb":{"!":"script","path":"lib/core/facets/enumerable/mash.rb","name":"mash.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/mash.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/modulate.rb":{"!":"script","path":"lib/core/facets/enumerable/modulate.rb","name":"modulate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/modulate.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/filter.rb":{"!":"script","path":"lib/core/facets/enumerable/filter.rb","name":"filter.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/filter.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/map_send.rb":{"!":"script","path":"lib/core/facets/enumerable/map_send.rb","name":"map_send.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/map_send.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/map_by.rb":{"!":"script","path":"lib/core/facets/enumerable/map_by.rb","name":"map_by.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/map_by.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/map_with_index.rb":{"!":"script","path":"lib/core/facets/enumerable/map_with_index.rb","name":"map_with_index.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/map_with_index.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/count.rb":{"!":"script","path":"lib/core/facets/enumerable/count.rb","name":"count.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/count.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/every.rb":{"!":"script","path":"lib/core/facets/enumerable/every.rb","name":"every.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/every.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/exclude.rb":{"!":"script","path":"lib/core/facets/enumerable/exclude.rb","name":"exclude.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/exclude.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/each_by.rb":{"!":"script","path":"lib/core/facets/enumerable/each_by.rb","name":"each_by.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/each_by.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/purge.rb":{"!":"script","path":"lib/core/facets/enumerable/purge.rb","name":"purge.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/purge.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/collect_with_index.rb":{"!":"script","path":"lib/core/facets/enumerable/collect_with_index.rb","name":"collect_with_index.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/collect_with_index.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable/compact_map.rb":{"!":"script","path":"lib/core/facets/enumerable/compact_map.rb","name":"compact_map.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable/compact_map.rb","language":"text/x-ruby"},"/lib/core/facets/class.rb":{"!":"script","path":"lib/core/facets/class.rb","name":"class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class.rb","language":"text/x-ruby"},"/lib/core/facets/roman.rb":{"!":"script","path":"lib/core/facets/roman.rb","name":"roman.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/roman.rb","language":"text/x-ruby"},"/lib/core/facets/symbol.rb":{"!":"script","path":"lib/core/facets/symbol.rb","name":"symbol.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/symbol.rb","language":"text/x-ruby"},"/lib/core/facets/numeric.rb":{"!":"script","path":"lib/core/facets/numeric.rb","name":"numeric.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/numeric.rb","language":"text/x-ruby"},"/lib/core/facets/string/shatter.rb":{"!":"script","path":"lib/core/facets/string/shatter.rb","name":"shatter.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/shatter.rb","language":"text/x-ruby"},"/lib/core/facets/string/file.rb":{"!":"script","path":"lib/core/facets/string/file.rb","name":"file.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/file.rb","language":"text/x-ruby"},"/lib/core/facets/string/to_re.rb":{"!":"script","path":"lib/core/facets/string/to_re.rb","name":"to_re.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/to_re.rb","language":"text/x-ruby"},"/lib/core/facets/string/fold.rb":{"!":"script","path":"lib/core/facets/string/fold.rb","name":"fold.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/fold.rb","language":"text/x-ruby"},"/lib/core/facets/string/start_with.rb":{"!":"script","path":"lib/core/facets/string/start_with.rb","name":"start_with.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/start_with.rb","language":"text/x-ruby"},"/lib/core/facets/string/store.rb":{"!":"script","path":"lib/core/facets/string/store.rb","name":"store.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/store.rb","language":"text/x-ruby"},"/lib/core/facets/string/camelcase.rb":{"!":"script","path":"lib/core/facets/string/camelcase.rb","name":"camelcase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/camelcase.rb","language":"text/x-ruby"},"/lib/core/facets/string/range_of_line.rb":{"!":"script","path":"lib/core/facets/string/range_of_line.rb","name":"range_of_line.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/range_of_line.rb","language":"text/x-ruby"},"/lib/core/facets/string/lines.rb":{"!":"script","path":"lib/core/facets/string/lines.rb","name":"lines.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/lines.rb","language":"text/x-ruby"},"/lib/core/facets/string/modulize.rb":{"!":"script","path":"lib/core/facets/string/modulize.rb","name":"modulize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/modulize.rb","language":"text/x-ruby"},"/lib/core/facets/string/word_wrap.rb":{"!":"script","path":"lib/core/facets/string/word_wrap.rb","name":"word_wrap.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/word_wrap.rb","language":"text/x-ruby"},"/lib/core/facets/string/edit_distance.rb":{"!":"script","path":"lib/core/facets/string/edit_distance.rb","name":"edit_distance.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/edit_distance.rb","language":"text/x-ruby"},"/lib/core/facets/string/op_div.rb":{"!":"script","path":"lib/core/facets/string/op_div.rb","name":"op_div.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/op_div.rb","language":"text/x-ruby"},"/lib/core/facets/string/align.rb":{"!":"script","path":"lib/core/facets/string/align.rb","name":"align.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/align.rb","language":"text/x-ruby"},"/lib/core/facets/string/squish.rb":{"!":"script","path":"lib/core/facets/string/squish.rb","name":"squish.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/squish.rb","language":"text/x-ruby"},"/lib/core/facets/string/lchomp.rb":{"!":"script","path":"lib/core/facets/string/lchomp.rb","name":"lchomp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/lchomp.rb","language":"text/x-ruby"},"/lib/core/facets/string/tab.rb":{"!":"script","path":"lib/core/facets/string/tab.rb","name":"tab.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/tab.rb","language":"text/x-ruby"},"/lib/core/facets/string/random_binary.rb":{"!":"script","path":"lib/core/facets/string/random_binary.rb","name":"random_binary.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/random_binary.rb","language":"text/x-ruby"},"/lib/core/facets/string/briefcase.rb":{"!":"script","path":"lib/core/facets/string/briefcase.rb","name":"briefcase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/briefcase.rb","language":"text/x-ruby"},"/lib/core/facets/string/unindent.rb":{"!":"script","path":"lib/core/facets/string/unindent.rb","name":"unindent.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/unindent.rb","language":"text/x-ruby"},"/lib/core/facets/string/methodize.rb":{"!":"script","path":"lib/core/facets/string/methodize.rb","name":"methodize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/methodize.rb","language":"text/x-ruby"},"/lib/core/facets/string/op_sub.rb":{"!":"script","path":"lib/core/facets/string/op_sub.rb","name":"op_sub.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/op_sub.rb","language":"text/x-ruby"},"/lib/core/facets/string/compress_lines.rb":{"!":"script","path":"lib/core/facets/string/compress_lines.rb","name":"compress_lines.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/compress_lines.rb","language":"text/x-ruby"},"/lib/core/facets/string/range.rb":{"!":"script","path":"lib/core/facets/string/range.rb","name":"range.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/range.rb","language":"text/x-ruby"},"/lib/core/facets/string/snakecase.rb":{"!":"script","path":"lib/core/facets/string/snakecase.rb","name":"snakecase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/snakecase.rb","language":"text/x-ruby"},"/lib/core/facets/string/each_char.rb":{"!":"script","path":"lib/core/facets/string/each_char.rb","name":"each_char.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/each_char.rb","language":"text/x-ruby"},"/lib/core/facets/string/divide.rb":{"!":"script","path":"lib/core/facets/string/divide.rb","name":"divide.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/divide.rb","language":"text/x-ruby"},"/lib/core/facets/string/characters.rb":{"!":"script","path":"lib/core/facets/string/characters.rb","name":"characters.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/characters.rb","language":"text/x-ruby"},"/lib/core/facets/string/range_all.rb":{"!":"script","path":"lib/core/facets/string/range_all.rb","name":"range_all.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/range_all.rb","language":"text/x-ruby"},"/lib/core/facets/string/margin.rb":{"!":"script","path":"lib/core/facets/string/margin.rb","name":"margin.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/margin.rb","language":"text/x-ruby"},"/lib/core/facets/string/mscan.rb":{"!":"script","path":"lib/core/facets/string/mscan.rb","name":"mscan.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/mscan.rb","language":"text/x-ruby"},"/lib/core/facets/string/cmp.rb":{"!":"script","path":"lib/core/facets/string/cmp.rb","name":"cmp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/cmp.rb","language":"text/x-ruby"},"/lib/core/facets/string/capitalized.rb":{"!":"script","path":"lib/core/facets/string/capitalized.rb","name":"capitalized.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/capitalized.rb","language":"text/x-ruby"},"/lib/core/facets/string/acronym.rb":{"!":"script","path":"lib/core/facets/string/acronym.rb","name":"acronym.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/acronym.rb","language":"text/x-ruby"},"/lib/core/facets/string/expand_tab.rb":{"!":"script","path":"lib/core/facets/string/expand_tab.rb","name":"expand_tab.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/expand_tab.rb","language":"text/x-ruby"},"/lib/core/facets/string/natcmp.rb":{"!":"script","path":"lib/core/facets/string/natcmp.rb","name":"natcmp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/natcmp.rb","language":"text/x-ruby"},"/lib/core/facets/string/variablize.rb":{"!":"script","path":"lib/core/facets/string/variablize.rb","name":"variablize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/variablize.rb","language":"text/x-ruby"},"/lib/core/facets/string/bytes.rb":{"!":"script","path":"lib/core/facets/string/bytes.rb","name":"bytes.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/bytes.rb","language":"text/x-ruby"},"/lib/core/facets/string/subtract.rb":{"!":"script","path":"lib/core/facets/string/subtract.rb","name":"subtract.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/subtract.rb","language":"text/x-ruby"},"/lib/core/facets/string/pathize.rb":{"!":"script","path":"lib/core/facets/string/pathize.rb","name":"pathize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/pathize.rb","language":"text/x-ruby"},"/lib/core/facets/string/unfold.rb":{"!":"script","path":"lib/core/facets/string/unfold.rb","name":"unfold.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/unfold.rb","language":"text/x-ruby"},"/lib/core/facets/string/outdent.rb":{"!":"script","path":"lib/core/facets/string/outdent.rb","name":"outdent.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/outdent.rb","language":"text/x-ruby"},"/lib/core/facets/string/indent.rb":{"!":"script","path":"lib/core/facets/string/indent.rb","name":"indent.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/indent.rb","language":"text/x-ruby"},"/lib/core/facets/string/quote.rb":{"!":"script","path":"lib/core/facets/string/quote.rb","name":"quote.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/quote.rb","language":"text/x-ruby"},"/lib/core/facets/string/titlecase.rb":{"!":"script","path":"lib/core/facets/string/titlecase.rb","name":"titlecase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/titlecase.rb","language":"text/x-ruby"},"/lib/core/facets/string/newlines.rb":{"!":"script","path":"lib/core/facets/string/newlines.rb","name":"newlines.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/newlines.rb","language":"text/x-ruby"},"/lib/core/facets/string/similarity.rb":{"!":"script","path":"lib/core/facets/string/similarity.rb","name":"similarity.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/similarity.rb","language":"text/x-ruby"},"/lib/core/facets/string/tabto.rb":{"!":"script","path":"lib/core/facets/string/tabto.rb","name":"tabto.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/tabto.rb","language":"text/x-ruby"},"/lib/core/facets/string/cleanlines.rb":{"!":"script","path":"lib/core/facets/string/cleanlines.rb","name":"cleanlines.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/cleanlines.rb","language":"text/x-ruby"},"/lib/core/facets/string/words.rb":{"!":"script","path":"lib/core/facets/string/words.rb","name":"words.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/words.rb","language":"text/x-ruby"},"/lib/core/facets/string/interpolate.rb":{"!":"script","path":"lib/core/facets/string/interpolate.rb","name":"interpolate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/interpolate.rb","language":"text/x-ruby"},"/lib/core/facets/string/cleave.rb":{"!":"script","path":"lib/core/facets/string/cleave.rb","name":"cleave.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/cleave.rb","language":"text/x-ruby"},"/lib/core/facets/string/roman.rb":{"!":"script","path":"lib/core/facets/string/roman.rb","name":"roman.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/roman.rb","language":"text/x-ruby"},"/lib/core/facets/string/line_wrap.rb":{"!":"script","path":"lib/core/facets/string/line_wrap.rb","name":"line_wrap.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/line_wrap.rb","language":"text/x-ruby"},"/lib/core/facets/string/bracket.rb":{"!":"script","path":"lib/core/facets/string/bracket.rb","name":"bracket.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/bracket.rb","language":"text/x-ruby"},"/lib/core/facets/string/lowercase.rb":{"!":"script","path":"lib/core/facets/string/lowercase.rb","name":"lowercase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/lowercase.rb","language":"text/x-ruby"},"/lib/core/facets/string/unquote.rb":{"!":"script","path":"lib/core/facets/string/unquote.rb","name":"unquote.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/unquote.rb","language":"text/x-ruby"},"/lib/core/facets/string/splice.rb":{"!":"script","path":"lib/core/facets/string/splice.rb","name":"splice.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/splice.rb","language":"text/x-ruby"},"/lib/core/facets/string/rewrite.rb":{"!":"script","path":"lib/core/facets/string/rewrite.rb","name":"rewrite.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/rewrite.rb","language":"text/x-ruby"},"/lib/core/facets/string/uppercase.rb":{"!":"script","path":"lib/core/facets/string/uppercase.rb","name":"uppercase.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/uppercase.rb","language":"text/x-ruby"},"/lib/core/facets/string/unbracket.rb":{"!":"script","path":"lib/core/facets/string/unbracket.rb","name":"unbracket.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/unbracket.rb","language":"text/x-ruby"},"/lib/core/facets/string/exclude.rb":{"!":"script","path":"lib/core/facets/string/exclude.rb","name":"exclude.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/exclude.rb","language":"text/x-ruby"},"/lib/core/facets/string/nchar.rb":{"!":"script","path":"lib/core/facets/string/nchar.rb","name":"nchar.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/nchar.rb","language":"text/x-ruby"},"/lib/core/facets/string/xor.rb":{"!":"script","path":"lib/core/facets/string/xor.rb","name":"xor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/xor.rb","language":"text/x-ruby"},"/lib/core/facets/string/crypt.rb":{"!":"script","path":"lib/core/facets/string/crypt.rb","name":"crypt.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/crypt.rb","language":"text/x-ruby"},"/lib/core/facets/string/end_with.rb":{"!":"script","path":"lib/core/facets/string/end_with.rb","name":"end_with.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/end_with.rb","language":"text/x-ruby"},"/lib/core/facets/string/each_word.rb":{"!":"script","path":"lib/core/facets/string/each_word.rb","name":"each_word.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/each_word.rb","language":"text/x-ruby"},"/lib/core/facets/string/index_all.rb":{"!":"script","path":"lib/core/facets/string/index_all.rb","name":"index_all.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/index_all.rb","language":"text/x-ruby"},"/lib/core/facets/string/underscore.rb":{"!":"script","path":"lib/core/facets/string/underscore.rb","name":"underscore.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string/underscore.rb","language":"text/x-ruby"},"/lib/core/facets/module/include_as.rb":{"!":"script","path":"lib/core/facets/module/include_as.rb","name":"include_as.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/include_as.rb","language":"text/x-ruby"},"/lib/core/facets/module/attr_validator.rb":{"!":"script","path":"lib/core/facets/module/attr_validator.rb","name":"attr_validator.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/attr_validator.rb","language":"text/x-ruby"},"/lib/core/facets/module/alias_accessor.rb":{"!":"script","path":"lib/core/facets/module/alias_accessor.rb","name":"alias_accessor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/alias_accessor.rb","language":"text/x-ruby"},"/lib/core/facets/module/enclosure.rb":{"!":"script","path":"lib/core/facets/module/enclosure.rb","name":"enclosure.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/enclosure.rb","language":"text/x-ruby"},"/lib/core/facets/module/class_accessor.rb":{"!":"script","path":"lib/core/facets/module/class_accessor.rb","name":"class_accessor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/class_accessor.rb","language":"text/x-ruby"},"/lib/core/facets/module/to_obj.rb":{"!":"script","path":"lib/core/facets/module/to_obj.rb","name":"to_obj.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/to_obj.rb","language":"text/x-ruby"},"/lib/core/facets/module/ancestor.rb":{"!":"script","path":"lib/core/facets/module/ancestor.rb","name":"ancestor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/ancestor.rb","language":"text/x-ruby"},"/lib/core/facets/module/attr_class_accessor.rb":{"!":"script","path":"lib/core/facets/module/attr_class_accessor.rb","name":"attr_class_accessor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/attr_class_accessor.rb","language":"text/x-ruby"},"/lib/core/facets/module/memoize.rb":{"!":"script","path":"lib/core/facets/module/memoize.rb","name":"memoize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/memoize.rb","language":"text/x-ruby"},"/lib/core/facets/module/method_clash.rb":{"!":"script","path":"lib/core/facets/module/method_clash.rb","name":"method_clash.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/method_clash.rb","language":"text/x-ruby"},"/lib/core/facets/module/redirect_method.rb":{"!":"script","path":"lib/core/facets/module/redirect_method.rb","name":"redirect_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/redirect_method.rb","language":"text/x-ruby"},"/lib/core/facets/module/class_extend.rb":{"!":"script","path":"lib/core/facets/module/class_extend.rb","name":"class_extend.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/class_extend.rb","language":"text/x-ruby"},"/lib/core/facets/module/methodize.rb":{"!":"script","path":"lib/core/facets/module/methodize.rb","name":"methodize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/methodize.rb","language":"text/x-ruby"},"/lib/core/facets/module/op_sub.rb":{"!":"script","path":"lib/core/facets/module/op_sub.rb","name":"op_sub.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/op_sub.rb","language":"text/x-ruby"},"/lib/core/facets/module/preextend.rb":{"!":"script","path":"lib/core/facets/module/preextend.rb","name":"preextend.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/preextend.rb","language":"text/x-ruby"},"/lib/core/facets/module/nodef.rb":{"!":"script","path":"lib/core/facets/module/nodef.rb","name":"nodef.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/nodef.rb","language":"text/x-ruby"},"/lib/core/facets/module/can.rb":{"!":"script","path":"lib/core/facets/module/can.rb","name":"can.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/can.rb","language":"text/x-ruby"},"/lib/core/facets/module/modname.rb":{"!":"script","path":"lib/core/facets/module/modname.rb","name":"modname.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/modname.rb","language":"text/x-ruby"},"/lib/core/facets/module/enclosures.rb":{"!":"script","path":"lib/core/facets/module/enclosures.rb","name":"enclosures.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/enclosures.rb","language":"text/x-ruby"},"/lib/core/facets/module/anonymous.rb":{"!":"script","path":"lib/core/facets/module/anonymous.rb","name":"anonymous.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/anonymous.rb","language":"text/x-ruby"},"/lib/core/facets/module/housing.rb":{"!":"script","path":"lib/core/facets/module/housing.rb","name":"housing.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/housing.rb","language":"text/x-ruby"},"/lib/core/facets/module/instance_function.rb":{"!":"script","path":"lib/core/facets/module/instance_function.rb","name":"instance_function.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/instance_function.rb","language":"text/x-ruby"},"/lib/core/facets/module/include_function_module.rb":{"!":"script","path":"lib/core/facets/module/include_function_module.rb","name":"include_function_module.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/include_function_module.rb","language":"text/x-ruby"},"/lib/core/facets/module/redefine_method.rb":{"!":"script","path":"lib/core/facets/module/redefine_method.rb","name":"redefine_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/redefine_method.rb","language":"text/x-ruby"},"/lib/core/facets/module/singleton_method_defined.rb":{"!":"script","path":"lib/core/facets/module/singleton_method_defined.rb","name":"singleton_method_defined.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/singleton_method_defined.rb","language":"text/x-ruby"},"/lib/core/facets/module/class_inheritor.rb":{"!":"script","path":"lib/core/facets/module/class_inheritor.rb","name":"class_inheritor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/class_inheritor.rb","language":"text/x-ruby"},"/lib/core/facets/module/class_def.rb":{"!":"script","path":"lib/core/facets/module/class_def.rb","name":"class_def.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/class_def.rb","language":"text/x-ruby"},"/lib/core/facets/module/op.rb":{"!":"script","path":"lib/core/facets/module/op.rb","name":"op.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/op.rb","language":"text/x-ruby"},"/lib/core/facets/module/op_mul.rb":{"!":"script","path":"lib/core/facets/module/op_mul.rb","name":"op_mul.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/op_mul.rb","language":"text/x-ruby"},"/lib/core/facets/module/pathize.rb":{"!":"script","path":"lib/core/facets/module/pathize.rb","name":"pathize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/pathize.rb","language":"text/x-ruby"},"/lib/core/facets/module/alias_module_function.rb":{"!":"script","path":"lib/core/facets/module/alias_module_function.rb","name":"alias_module_function.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/alias_module_function.rb","language":"text/x-ruby"},"/lib/core/facets/module/let.rb":{"!":"script","path":"lib/core/facets/module/let.rb","name":"let.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/let.rb","language":"text/x-ruby"},"/lib/core/facets/module/mattr.rb":{"!":"script","path":"lib/core/facets/module/mattr.rb","name":"mattr.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/mattr.rb","language":"text/x-ruby"},"/lib/core/facets/module/module_load.rb":{"!":"script","path":"lib/core/facets/module/module_load.rb","name":"module_load.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/module_load.rb","language":"text/x-ruby"},"/lib/core/facets/module/is.rb":{"!":"script","path":"lib/core/facets/module/is.rb","name":"is.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/is.rb","language":"text/x-ruby"},"/lib/core/facets/module/copy_inheritor.rb":{"!":"script","path":"lib/core/facets/module/copy_inheritor.rb","name":"copy_inheritor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/copy_inheritor.rb","language":"text/x-ruby"},"/lib/core/facets/module/class.rb":{"!":"script","path":"lib/core/facets/module/class.rb","name":"class.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/class.rb","language":"text/x-ruby"},"/lib/core/facets/module/instance_method_defined.rb":{"!":"script","path":"lib/core/facets/module/instance_method_defined.rb","name":"instance_method_defined.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/instance_method_defined.rb","language":"text/x-ruby"},"/lib/core/facets/module/set.rb":{"!":"script","path":"lib/core/facets/module/set.rb","name":"set.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/set.rb","language":"text/x-ruby"},"/lib/core/facets/module/module_def.rb":{"!":"script","path":"lib/core/facets/module/module_def.rb","name":"module_def.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/module_def.rb","language":"text/x-ruby"},"/lib/core/facets/module/method_space.rb":{"!":"script","path":"lib/core/facets/module/method_space.rb","name":"method_space.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/method_space.rb","language":"text/x-ruby"},"/lib/core/facets/module/abstract.rb":{"!":"script","path":"lib/core/facets/module/abstract.rb","name":"abstract.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/abstract.rb","language":"text/x-ruby"},"/lib/core/facets/module/rename_method.rb":{"!":"script","path":"lib/core/facets/module/rename_method.rb","name":"rename_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/rename_method.rb","language":"text/x-ruby"},"/lib/core/facets/module/integrate.rb":{"!":"script","path":"lib/core/facets/module/integrate.rb","name":"integrate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/integrate.rb","language":"text/x-ruby"},"/lib/core/facets/module/alias_method_chain.rb":{"!":"script","path":"lib/core/facets/module/alias_method_chain.rb","name":"alias_method_chain.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/alias_method_chain.rb","language":"text/x-ruby"},"/lib/core/facets/module/home.rb":{"!":"script","path":"lib/core/facets/module/home.rb","name":"home.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/home.rb","language":"text/x-ruby"},"/lib/core/facets/module/remove.rb":{"!":"script","path":"lib/core/facets/module/remove.rb","name":"remove.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/remove.rb","language":"text/x-ruby"},"/lib/core/facets/module/homename.rb":{"!":"script","path":"lib/core/facets/module/homename.rb","name":"homename.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/homename.rb","language":"text/x-ruby"},"/lib/core/facets/module/class_method_defined.rb":{"!":"script","path":"lib/core/facets/module/class_method_defined.rb","name":"class_method_defined.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/class_method_defined.rb","language":"text/x-ruby"},"/lib/core/facets/module/revise.rb":{"!":"script","path":"lib/core/facets/module/revise.rb","name":"revise.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/revise.rb","language":"text/x-ruby"},"/lib/core/facets/module/extend.rb":{"!":"script","path":"lib/core/facets/module/extend.rb","name":"extend.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/extend.rb","language":"text/x-ruby"},"/lib/core/facets/module/instance_method.rb":{"!":"script","path":"lib/core/facets/module/instance_method.rb","name":"instance_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/instance_method.rb","language":"text/x-ruby"},"/lib/core/facets/module/attr_tester.rb":{"!":"script","path":"lib/core/facets/module/attr_tester.rb","name":"attr_tester.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/attr_tester.rb","language":"text/x-ruby"},"/lib/core/facets/module/spacename.rb":{"!":"script","path":"lib/core/facets/module/spacename.rb","name":"spacename.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/spacename.rb","language":"text/x-ruby"},"/lib/core/facets/module/wrap_method.rb":{"!":"script","path":"lib/core/facets/module/wrap_method.rb","name":"wrap_method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/wrap_method.rb","language":"text/x-ruby"},"/lib/core/facets/module/op_add.rb":{"!":"script","path":"lib/core/facets/module/op_add.rb","name":"op_add.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/op_add.rb","language":"text/x-ruby"},"/lib/core/facets/module/attr_setter.rb":{"!":"script","path":"lib/core/facets/module/attr_setter.rb","name":"attr_setter.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/attr_setter.rb","language":"text/x-ruby"},"/lib/core/facets/module/basename.rb":{"!":"script","path":"lib/core/facets/module/basename.rb","name":"basename.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/basename.rb","language":"text/x-ruby"},"/lib/core/facets/module/all_instance_methods.rb":{"!":"script","path":"lib/core/facets/module/all_instance_methods.rb","name":"all_instance_methods.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/module/all_instance_methods.rb","language":"text/x-ruby"},"/lib/core/facets/proc.rb":{"!":"script","path":"lib/core/facets/proc.rb","name":"proc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/proc.rb","language":"text/x-ruby"},"/lib/core/facets/array.rb":{"!":"script","path":"lib/core/facets/array.rb","name":"array.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array.rb","language":"text/x-ruby"},"/lib/core/facets/time/elapse.rb":{"!":"script","path":"lib/core/facets/time/elapse.rb","name":"elapse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/elapse.rb","language":"text/x-ruby"},"/lib/core/facets/time/past.rb":{"!":"script","path":"lib/core/facets/time/past.rb","name":"past.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/past.rb","language":"text/x-ruby"},"/lib/core/facets/time/shift.rb":{"!":"script","path":"lib/core/facets/time/shift.rb","name":"shift.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/shift.rb","language":"text/x-ruby"},"/lib/core/facets/time/ago.rb":{"!":"script","path":"lib/core/facets/time/ago.rb","name":"ago.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/ago.rb","language":"text/x-ruby"},"/lib/core/facets/time/trunc.rb":{"!":"script","path":"lib/core/facets/time/trunc.rb","name":"trunc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/trunc.rb","language":"text/x-ruby"},"/lib/core/facets/time/dst_adjustment.rb":{"!":"script","path":"lib/core/facets/time/dst_adjustment.rb","name":"dst_adjustment.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/dst_adjustment.rb","language":"text/x-ruby"},"/lib/core/facets/time/future.rb":{"!":"script","path":"lib/core/facets/time/future.rb","name":"future.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/future.rb","language":"text/x-ruby"},"/lib/core/facets/time/less.rb":{"!":"script","path":"lib/core/facets/time/less.rb","name":"less.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/less.rb","language":"text/x-ruby"},"/lib/core/facets/time/hence.rb":{"!":"script","path":"lib/core/facets/time/hence.rb","name":"hence.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/hence.rb","language":"text/x-ruby"},"/lib/core/facets/time/set.rb":{"!":"script","path":"lib/core/facets/time/set.rb","name":"set.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/set.rb","language":"text/x-ruby"},"/lib/core/facets/time/round_to.rb":{"!":"script","path":"lib/core/facets/time/round_to.rb","name":"round_to.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/round_to.rb","language":"text/x-ruby"},"/lib/core/facets/time/to_time.rb":{"!":"script","path":"lib/core/facets/time/to_time.rb","name":"to_time.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/to_time.rb","language":"text/x-ruby"},"/lib/core/facets/time/change.rb":{"!":"script","path":"lib/core/facets/time/change.rb","name":"change.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/change.rb","language":"text/x-ruby"},"/lib/core/facets/time/stamp.rb":{"!":"script","path":"lib/core/facets/time/stamp.rb","name":"stamp.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/stamp.rb","language":"text/x-ruby"},"/lib/core/facets/time/in.rb":{"!":"script","path":"lib/core/facets/time/in.rb","name":"in.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/time/in.rb","language":"text/x-ruby"},"/lib/core/facets/enumerable.rb":{"!":"script","path":"lib/core/facets/enumerable.rb","name":"enumerable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/enumerable.rb","language":"text/x-ruby"},"/lib/core/facets/functor.rb":{"!":"script","path":"lib/core/facets/functor.rb","name":"functor.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/functor.rb","language":"text/x-ruby"},"/lib/core/facets/dir/ascend.rb":{"!":"script","path":"lib/core/facets/dir/ascend.rb","name":"ascend.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir/ascend.rb","language":"text/x-ruby"},"/lib/core/facets/dir/each_child.rb":{"!":"script","path":"lib/core/facets/dir/each_child.rb","name":"each_child.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir/each_child.rb","language":"text/x-ruby"},"/lib/core/facets/dir/multiglob.rb":{"!":"script","path":"lib/core/facets/dir/multiglob.rb","name":"multiglob.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir/multiglob.rb","language":"text/x-ruby"},"/lib/core/facets/dir/recurse.rb":{"!":"script","path":"lib/core/facets/dir/recurse.rb","name":"recurse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir/recurse.rb","language":"text/x-ruby"},"/lib/core/facets/dir/parent.rb":{"!":"script","path":"lib/core/facets/dir/parent.rb","name":"parent.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir/parent.rb","language":"text/x-ruby"},"/lib/core/facets/dir/descend.rb":{"!":"script","path":"lib/core/facets/dir/descend.rb","name":"descend.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/dir/descend.rb","language":"text/x-ruby"},"/lib/core/facets/denumerable.rb":{"!":"script","path":"lib/core/facets/denumerable.rb","name":"denumerable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/denumerable.rb","language":"text/x-ruby"},"/lib/core/facets/unboundmethod.rb":{"!":"script","path":"lib/core/facets/unboundmethod.rb","name":"unboundmethod.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/unboundmethod.rb","language":"text/x-ruby"},"/lib/core/facets/filetest/absolute.rb":{"!":"script","path":"lib/core/facets/filetest/absolute.rb","name":"absolute.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest/absolute.rb","language":"text/x-ruby"},"/lib/core/facets/filetest/separator_pattern.rb":{"!":"script","path":"lib/core/facets/filetest/separator_pattern.rb","name":"separator_pattern.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest/separator_pattern.rb","language":"text/x-ruby"},"/lib/core/facets/filetest/root.rb":{"!":"script","path":"lib/core/facets/filetest/root.rb","name":"root.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest/root.rb","language":"text/x-ruby"},"/lib/core/facets/filetest/safe.rb":{"!":"script","path":"lib/core/facets/filetest/safe.rb","name":"safe.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest/safe.rb","language":"text/x-ruby"},"/lib/core/facets/filetest/relative.rb":{"!":"script","path":"lib/core/facets/filetest/relative.rb","name":"relative.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest/relative.rb","language":"text/x-ruby"},"/lib/core/facets/filetest/contains.rb":{"!":"script","path":"lib/core/facets/filetest/contains.rb","name":"contains.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/filetest/contains.rb","language":"text/x-ruby"},"/lib/core/facets/class/methodize.rb":{"!":"script","path":"lib/core/facets/class/methodize.rb","name":"methodize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/methodize.rb","language":"text/x-ruby"},"/lib/core/facets/class/subclasses.rb":{"!":"script","path":"lib/core/facets/class/subclasses.rb","name":"subclasses.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/subclasses.rb","language":"text/x-ruby"},"/lib/core/facets/class/preallocate.rb":{"!":"script","path":"lib/core/facets/class/preallocate.rb","name":"preallocate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/preallocate.rb","language":"text/x-ruby"},"/lib/core/facets/class/pathize.rb":{"!":"script","path":"lib/core/facets/class/pathize.rb","name":"pathize.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/pathize.rb","language":"text/x-ruby"},"/lib/core/facets/class/singleton.rb":{"!":"script","path":"lib/core/facets/class/singleton.rb","name":"singleton.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/singleton.rb","language":"text/x-ruby"},"/lib/core/facets/class/to_proc.rb":{"!":"script","path":"lib/core/facets/class/to_proc.rb","name":"to_proc.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/to_proc.rb","language":"text/x-ruby"},"/lib/core/facets/class/hierarchically.rb":{"!":"script","path":"lib/core/facets/class/hierarchically.rb","name":"hierarchically.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/hierarchically.rb","language":"text/x-ruby"},"/lib/core/facets/class/descendants.rb":{"!":"script","path":"lib/core/facets/class/descendants.rb","name":"descendants.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/class/descendants.rb","language":"text/x-ruby"},"/lib/core/facets/process.rb":{"!":"script","path":"lib/core/facets/process.rb","name":"process.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/process.rb","language":"text/x-ruby"},"/lib/core/facets/array/each_value.rb":{"!":"script","path":"lib/core/facets/array/each_value.rb","name":"each_value.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/each_value.rb","language":"text/x-ruby"},"/lib/core/facets/array/collapse.rb":{"!":"script","path":"lib/core/facets/array/collapse.rb","name":"collapse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/collapse.rb","language":"text/x-ruby"},"/lib/core/facets/array/product.rb":{"!":"script","path":"lib/core/facets/array/product.rb","name":"product.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/product.rb","language":"text/x-ruby"},"/lib/core/facets/array/store.rb":{"!":"script","path":"lib/core/facets/array/store.rb","name":"store.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/store.rb","language":"text/x-ruby"},"/lib/core/facets/array/collisions.rb":{"!":"script","path":"lib/core/facets/array/collisions.rb","name":"collisions.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/collisions.rb","language":"text/x-ruby"},"/lib/core/facets/array/mode.rb":{"!":"script","path":"lib/core/facets/array/mode.rb","name":"mode.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/mode.rb","language":"text/x-ruby"},"/lib/core/facets/array/occurent.rb":{"!":"script","path":"lib/core/facets/array/occurent.rb","name":"occurent.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/occurent.rb","language":"text/x-ruby"},"/lib/core/facets/array/recursively.rb":{"!":"script","path":"lib/core/facets/array/recursively.rb","name":"recursively.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/recursively.rb","language":"text/x-ruby"},"/lib/core/facets/array/not_empty.rb":{"!":"script","path":"lib/core/facets/array/not_empty.rb","name":"not_empty.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/not_empty.rb","language":"text/x-ruby"},"/lib/core/facets/array/delete_unless.rb":{"!":"script","path":"lib/core/facets/array/delete_unless.rb","name":"delete_unless.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/delete_unless.rb","language":"text/x-ruby"},"/lib/core/facets/array/extract_options.rb":{"!":"script","path":"lib/core/facets/array/extract_options.rb","name":"extract_options.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/extract_options.rb","language":"text/x-ruby"},"/lib/core/facets/array/rotate.rb":{"!":"script","path":"lib/core/facets/array/rotate.rb","name":"rotate.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/rotate.rb","language":"text/x-ruby"},"/lib/core/facets/array/each_pair.rb":{"!":"script","path":"lib/core/facets/array/each_pair.rb","name":"each_pair.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/each_pair.rb","language":"text/x-ruby"},"/lib/core/facets/array/commonality.rb":{"!":"script","path":"lib/core/facets/array/commonality.rb","name":"commonality.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/commonality.rb","language":"text/x-ruby"},"/lib/core/facets/array/conjoin.rb":{"!":"script","path":"lib/core/facets/array/conjoin.rb","name":"conjoin.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/conjoin.rb","language":"text/x-ruby"},"/lib/core/facets/array/divide.rb":{"!":"script","path":"lib/core/facets/array/divide.rb","name":"divide.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/divide.rb","language":"text/x-ruby"},"/lib/core/facets/array/indexable.rb":{"!":"script","path":"lib/core/facets/array/indexable.rb","name":"indexable.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/indexable.rb","language":"text/x-ruby"},"/lib/core/facets/array/duplicates.rb":{"!":"script","path":"lib/core/facets/array/duplicates.rb","name":"duplicates.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/duplicates.rb","language":"text/x-ruby"},"/lib/core/facets/array/recurse.rb":{"!":"script","path":"lib/core/facets/array/recurse.rb","name":"recurse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/recurse.rb","language":"text/x-ruby"},"/lib/core/facets/array/merge.rb":{"!":"script","path":"lib/core/facets/array/merge.rb","name":"merge.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/merge.rb","language":"text/x-ruby"},"/lib/core/facets/array/traverse.rb":{"!":"script","path":"lib/core/facets/array/traverse.rb","name":"traverse.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/traverse.rb","language":"text/x-ruby"},"/lib/core/facets/array/permutation.rb":{"!":"script","path":"lib/core/facets/array/permutation.rb","name":"permutation.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/permutation.rb","language":"text/x-ruby"},"/lib/core/facets/array/median.rb":{"!":"script","path":"lib/core/facets/array/median.rb","name":"median.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/median.rb","language":"text/x-ruby"},"/lib/core/facets/array/nonuniq.rb":{"!":"script","path":"lib/core/facets/array/nonuniq.rb","name":"nonuniq.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/nonuniq.rb","language":"text/x-ruby"},"/lib/core/facets/array/from.rb":{"!":"script","path":"lib/core/facets/array/from.rb","name":"from.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/from.rb","language":"text/x-ruby"},"/lib/core/facets/array/uniq_by.rb":{"!":"script","path":"lib/core/facets/array/uniq_by.rb","name":"uniq_by.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/uniq_by.rb","language":"text/x-ruby"},"/lib/core/facets/array/select.rb":{"!":"script","path":"lib/core/facets/array/select.rb","name":"select.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/select.rb","language":"text/x-ruby"},"/lib/core/facets/array/index.rb":{"!":"script","path":"lib/core/facets/array/index.rb","name":"index.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/index.rb","language":"text/x-ruby"},"/lib/core/facets/array/entropy.rb":{"!":"script","path":"lib/core/facets/array/entropy.rb","name":"entropy.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/entropy.rb","language":"text/x-ruby"},"/lib/core/facets/array/only.rb":{"!":"script","path":"lib/core/facets/array/only.rb","name":"only.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/only.rb","language":"text/x-ruby"},"/lib/core/facets/array/before.rb":{"!":"script","path":"lib/core/facets/array/before.rb","name":"before.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/before.rb","language":"text/x-ruby"},"/lib/core/facets/array/split.rb":{"!":"script","path":"lib/core/facets/array/split.rb","name":"split.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/split.rb","language":"text/x-ruby"},"/lib/core/facets/array/delete.rb":{"!":"script","path":"lib/core/facets/array/delete.rb","name":"delete.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/delete.rb","language":"text/x-ruby"},"/lib/core/facets/array/combination.rb":{"!":"script","path":"lib/core/facets/array/combination.rb","name":"combination.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/combination.rb","language":"text/x-ruby"},"/lib/core/facets/array/delete_values.rb":{"!":"script","path":"lib/core/facets/array/delete_values.rb","name":"delete_values.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/delete_values.rb","language":"text/x-ruby"},"/lib/core/facets/array/after.rb":{"!":"script","path":"lib/core/facets/array/after.rb","name":"after.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/after.rb","language":"text/x-ruby"},"/lib/core/facets/array/probability.rb":{"!":"script","path":"lib/core/facets/array/probability.rb","name":"probability.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/probability.rb","language":"text/x-ruby"},"/lib/core/facets/array/peek.rb":{"!":"script","path":"lib/core/facets/array/peek.rb","name":"peek.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/peek.rb","language":"text/x-ruby"},"/lib/core/facets/array/poke.rb":{"!":"script","path":"lib/core/facets/array/poke.rb","name":"poke.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/poke.rb","language":"text/x-ruby"},"/lib/core/facets/array/splice.rb":{"!":"script","path":"lib/core/facets/array/splice.rb","name":"splice.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/splice.rb","language":"text/x-ruby"},"/lib/core/facets/array/thru.rb":{"!":"script","path":"lib/core/facets/array/thru.rb","name":"thru.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/thru.rb","language":"text/x-ruby"},"/lib/core/facets/array/pad.rb":{"!":"script","path":"lib/core/facets/array/pad.rb","name":"pad.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/pad.rb","language":"text/x-ruby"},"/lib/core/facets/array/pull.rb":{"!":"script","path":"lib/core/facets/array/pull.rb","name":"pull.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/pull.rb","language":"text/x-ruby"},"/lib/core/facets/array/op_pow.rb":{"!":"script","path":"lib/core/facets/array/op_pow.rb","name":"op_pow.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/op_pow.rb","language":"text/x-ruby"},"/lib/core/facets/array/contains.rb":{"!":"script","path":"lib/core/facets/array/contains.rb","name":"contains.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/array/contains.rb","language":"text/x-ruby"},"/lib/core/facets/kernel.rb":{"!":"script","path":"lib/core/facets/kernel.rb","name":"kernel.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/kernel.rb","language":"text/x-ruby"},"/lib/core/facets/regexp/to_re.rb":{"!":"script","path":"lib/core/facets/regexp/to_re.rb","name":"to_re.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/regexp/to_re.rb","language":"text/x-ruby"},"/lib/core/facets/regexp/arity.rb":{"!":"script","path":"lib/core/facets/regexp/arity.rb","name":"arity.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/regexp/arity.rb","language":"text/x-ruby"},"/lib/core/facets/regexp/multiline.rb":{"!":"script","path":"lib/core/facets/regexp/multiline.rb","name":"multiline.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/regexp/multiline.rb","language":"text/x-ruby"},"/lib/core/facets/regexp/op_or.rb":{"!":"script","path":"lib/core/facets/regexp/op_or.rb","name":"op_or.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/regexp/op_or.rb","language":"text/x-ruby"},"/lib/core/facets/regexp/op_add.rb":{"!":"script","path":"lib/core/facets/regexp/op_add.rb","name":"op_add.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/regexp/op_add.rb","language":"text/x-ruby"},"/lib/core/facets/matchdata/match.rb":{"!":"script","path":"lib/core/facets/matchdata/match.rb","name":"match.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/matchdata/match.rb","language":"text/x-ruby"},"/lib/core/facets/matchdata/matchset.rb":{"!":"script","path":"lib/core/facets/matchdata/matchset.rb","name":"matchset.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/matchdata/matchset.rb","language":"text/x-ruby"},"/lib/core/facets/method.rb":{"!":"script","path":"lib/core/facets/method.rb","name":"method.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/method.rb","language":"text/x-ruby"},"/lib/core/facets/exception/raised.rb":{"!":"script","path":"lib/core/facets/exception/raised.rb","name":"raised.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/exception/raised.rb","language":"text/x-ruby"},"/lib/core/facets/exception/suppress.rb":{"!":"script","path":"lib/core/facets/exception/suppress.rb","name":"suppress.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/exception/suppress.rb","language":"text/x-ruby"},"/lib/core/facets/exception/detail.rb":{"!":"script","path":"lib/core/facets/exception/detail.rb","name":"detail.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/exception/detail.rb","language":"text/x-ruby"},"/lib/core/facets/exception/error_print.rb":{"!":"script","path":"lib/core/facets/exception/error_print.rb","name":"error_print.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/exception/error_print.rb","language":"text/x-ruby"},"/lib/core/facets/string.rb":{"!":"script","path":"lib/core/facets/string.rb","name":"string.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/string.rb","language":"text/x-ruby"},"/lib/core/facets/binding.rb":{"!":"script","path":"lib/core/facets/binding.rb","name":"binding.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets/binding.rb","language":"text/x-ruby"},"/lib/core/facets.rb":{"!":"script","path":"lib/core/facets.rb","name":"facets.rb","mtime":null,"uri":"https://github.com/rubyworks/facets/tree/master/lib/core/facets.rb","language":"text/x-ruby"},"/lib/core/facets.yml":{"!":"document","path":"lib/core/facets.yml","name":"facets.yml","mtime":null,"text":"---\nauthors:\n- name: Thomas Sawyer\n  email: transfire@gmail.com\ncopyrights:\n- holder: Thomas Sawyer\n  year: '2004'\n  license: Ruby\nreplacements: []\nconflicts: []\nrequirements:\n- name: lemon\n  groups:\n  - test\n  development: true\n- name: qed\n  groups:\n  - test\n  development: true\n- name: detroit\n  groups:\n  - build\n  development: true\ndependencies: []\nrepositories:\n- uri: git@github.com:rubyworks/facets.git\n  scm: git\n  name: upstream\nresources:\n  home: http://rubyworks.github.com/facets\n  code: http://github.com/rubyworks/facets\n  docs: http://rubyworks.github.com/facets/learn.html\n  wiki: http://wiki.github.com/rubyworks/facets\n  talk: http://groups.google.com/group/facets-universal\nload_path:\n- lib/core\n- lib/core-uncommon\n- lib/standard\n- lib/supplemental\nextra:\n  slogan: ALL YOUR BASE ARE BELONG TO RUBY!\n  manifest: MANIFEST\nsource: []\nalternatives: []\nrevision: 0\ntitle: Facets\nname: facets\nsummary: Premium Ruby Extensions\ncreated: '2004-12-16'\ndescription: Facets is the premier collection of extension methods for the Ruby programming\n  language. Facets extensions are unique by virtue of thier atomicity. They are stored\n  in individual files allowing for highly granular control of requirements. In addition,\n  Facets includes a few additional classes and mixins suitable to wide variety of\n  applications.\norganization: rubyworks\nversion: 2.9.2\ndate: '2011-08-23'\n","format":"text/plain"}}
